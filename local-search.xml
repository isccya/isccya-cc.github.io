<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>虚拟内存</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><ul><li>程序使用的内存是虚拟内存，操作系统内部将其与物理内存映射。避免各个程序物理地址冲突。操作系统通过 <strong>内存分段、内存分页</strong>两种方式实现虚拟内存到物理内存的映射。</li></ul><ol><li>内存扩展：物理内存有限，虚拟内存可以先把程序部分数据暂存到硬盘中，需要时候再调度进来。</li><li>进程隔离：各个进程运行在自己的虚拟内存中，操作系统内实现虚拟内存到物理内存的映射，避免进程访问错误。</li><li>内存管理：通过分页分段管理内存，更加有效的分配和回收内存，减少内存碎片化。</li></ol><!-- 操作系统是如何管理虚拟地址与物理地址之间的关系？主要有两种方式，分别是内存分段和内存分页 --><h2 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li>程序由若干个逻辑段组成，比如程序段、数据段，分段就是把这些段分离开来。分段的虚拟内存由<em><strong>段选择因子</strong></em>和<em><strong>段内偏移量</strong></em>。</li></ul><ol><li><em><strong>段选择因子</strong></em>：核心是<em><strong>段号</strong></em>，段号索引到段表的一个条目，这个条目有<strong>段基地址和段边界</strong></li><li><em><strong>段内偏移量</strong></em>：位于0和段边界之间，段基地址 + 段偏移量 &#x3D; 物理地址</li></ol><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ol><li><em><strong>外部内存碎片</strong></em>：每个段大小长度不固定，会产生多个不连续的小段内存（外部内存碎片），导致新程序无法加载。</li></ol><h3 id="解决方方案"><a href="#解决方方案" class="headerlink" title="解决方方案"></a>解决方方案</h3><ol><li><em><strong>内存交换</strong></em>：将内存中的应用写到硬盘上，再写回内存中，但写回的位置不再是原来的位置，而是紧跟前面的内存。</li></ol><h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><ul><li>分页是把物理内存提前划分好为一个个固定大小的空间，页与页之间紧密排列，虚拟地址和物理地址通过页表映射。</li><li>分页机制下，虚拟地址分为<em><strong>页号</strong></em>和<em><strong>页内偏移量</strong></em>，页号是页表的索引，页表包含物理页每页的基地址，再加上偏移量就得到物理地址。</li></ul><h3 id="存在的问题-1"><a href="#存在的问题-1" class="headerlink" title="存在的问题"></a>存在的问题</h3><ul><li><em><strong>内存分页机制会有内部内存碎片</strong></em>：采用了分页，页与页之间是紧密排列的，所以不会有外部内存碎片；但内存分配最小是一页，即使程序不足一页也会分配一个页，所以页面内会出现内存浪费。</li><li><em><strong>页表占据大量内存空间</strong></em>：每一页内存大小不大的话，大量内存会对应<strong>很多个</strong>页表项，每个进程又有自己的页表；（段的话因为一个程序只对应五六个段，段表不会占特别大空间）。</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><em><strong>多级页表</strong></em>：程序用不到那么多内存，不需要真正创建所有的页号和页的映射。一级页表可以覆盖全部的虚拟内存，记录二级页表目录；二级列表记录真正的映射关系，只有一级页表项用到的部分才创建二级部分。</li></ol><h2 id="TLB页表缓存"><a href="#TLB页表缓存" class="headerlink" title="TLB页表缓存"></a>TLB页表缓存</h2><ul><li>最常用的页表进行缓存，常用的页不多，TLB命中率很高。</li></ul><!-- - 缓存思想，速度慢了就缓存常用的。 --><h2 id="分段和分页相同处和不同处"><a href="#分段和分页相同处和不同处" class="headerlink" title="分段和分页相同处和不同处"></a>分段和分页相同处和不同处</h2><ul><li>相同处：</li></ul><ol><li>地址转换过程：都是从段表页表中获取基地址，再加上偏移量获取物理地址。</li><li>记录表：分段或者分页都使用了表来记录段或页的映射关系。</li></ol><ul><li>不同处：</li></ul><ol><li>大小：段的大小是根据逻辑需求而定的，且是动态变化的；页的大小是固定的，解决了内存碎片问题。</li><li>碎片：分段产生外部碎片，分页产生内部碎片。</li><li>表结构：段表记录的是段基地址和段边界，页表记录的是页号对应的页框。</li></ol><h2 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h2><!-- 现在更多是纯分页 --><ul><li>优点：<strong>逻辑分段+无外部碎片。</strong></li><li>先将程序按逻辑分成多个逻辑段。</li><li>每个段再分成固定大小的页，对段划出连续空间。</li><li>虚拟地址由：<em><strong>段号，段内页号，页面偏移量</strong></em>组成。<br><img src="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image.png" alt="alt text"></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vite</title>
    <link href="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/vite/"/>
    <url>/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/vite/</url>
    
    <content type="html"><![CDATA[<h1 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h1><ul><li>深入理解Vite核心原理: <a href="https://juejin.cn/post/7064853960636989454">https://juejin.cn/post/7064853960636989454</a></li><li>vite为什么这么快：<a href="https://juejin.cn/post/7280747221510144054#heading-1">https://juejin.cn/post/7280747221510144054#heading-1</a></li></ul><h2 id="vite预构建"><a href="#vite预构建" class="headerlink" title="vite预构建"></a>vite预构建</h2><ul><li>转换为esm模块。</li></ul><h2 id="vite核心原理-vite构建流程"><a href="#vite核心原理-vite构建流程" class="headerlink" title="vite核心原理&#x2F;vite构建流程"></a>vite核心原理&#x2F;vite构建流程</h2><ol><li>vite直接启动开发服务器，不用进行整个项目的打包编译。</li><li>vite会预处理所有文件为esm格式，利用浏览器对esm的支持，就是我们浏览器现在支持运行一些模块化的语言，比如import语句，遇到import再去发送http请求对应的模块，vite会在服务器中间拦截处理文件（比如vue编译）</li></ol><h2 id="vite本地开发esbuild，生产rollup"><a href="#vite本地开发esbuild，生产rollup" class="headerlink" title="vite本地开发esbuild，生产rollup"></a>vite本地开发esbuild，生产rollup</h2><ol><li><p>esbuild：go编写构建速度快；利用浏览器原生支持ESM模块，请求一个模块，再去加载对应的模块，拦截请求进行代码转换。</p></li><li><p>rollup：esbuild只能做简单转换，一些插件API与esbuild打包还不兼容，rollup有打包生命周期钩子，可进行模块解析加载代码分割、treeShaking、生成的代码体积更小、更高效。</p></li></ol><p><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/vite/esbuildAndRollup.png" alt="对比图"></p>]]></content>
    
    
    <categories>
      
      <category>打包工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>打包工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/"/>
    <url>/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/</url>
    
    <content type="html"><![CDATA[<p><a href="https://vue3js.cn/interview/webpack/webpack.html#%E4%B8%80%E3%80%81%E8%83%8C%E6%99%AF">https://vue3js.cn/interview/webpack/webpack.html#%E4%B8%80%E3%80%81%E8%83%8C%E6%99%AF</a></p><p><a href="https://juejin.cn/post/6844904094281236487?searchId=20241027155907A6653545D1F9EE98EE4D">https://juejin.cn/post/6844904094281236487?searchId=20241027155907A6653545D1F9EE98EE4D</a></p><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><ul><li>loader本质是一个函数，翻译官，对接收的内容进行转换。</li><li>默认情况下，webpack只能对js，json进行转换，遇到css，png等文件时候需要loader对文件分析，webpack遇到无法解析的文件时候会去loader配置查找，进行预处理编译压缩。</li><li>常见的loader：<br>css-loader，style-loader，解析css代码，将css代码作为style标签插入到页面中。<br>json-loader,默认包含。<br>image-loader：加载压缩图片。<br><strong>babel-loader</strong>：es6+语法转换为es5<br><strong>ts-loader</strong>：ts转换为js</li></ul><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><ul><li>插件，扩充webpack功能，webpack在生命周期会广播事件，plugin监听事件来执行改变结果。</li><li>HtmlWebpackPlugin，创建一个html，并把打包生成的js插入到其中。</li><li>Dllplugin</li><li>webpack-bundle-analyzer，打包后体积可视化</li></ul><h2 id="编写loader"><a href="#编写loader" class="headerlink" title="编写loader"></a>编写loader</h2><p><a href="https://juejin.cn/post/7100534685134454815?searchId=2024111811590127047A1230DEEC4E5372">https://juejin.cn/post/7100534685134454815?searchId=2024111811590127047A1230DEEC4E5372</a></p><ul><li>loader职责是单一、链式传输、易维护。</li></ul><ol><li>本质是函数，this会被webpack填充，不能用箭头函数。</li><li>接受一个参数，为webpack传递loader的文件源，源文件字符串。</li><li>this.async标明loader是个异步的，async()接受一个回调函数；<br>this.getOptions()获取 loader 的配置选项</li></ol><!-- 4. 获取配置文件配置项options：loader-utils.getOptions。(就是在webpack配置文件中给loader配置的内容) --><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; getOptions &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;loader-utils&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) &#123;<br>  <span class="hljs-keyword">const</span> options = <span class="hljs-title function_">getOptions</span>(<span class="hljs-variable language_">this</span>) || &#123;&#125;;<br>  <span class="hljs-keyword">const</span> result = source.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/foo/g</span>, options.<span class="hljs-property">replacement</span> || <span class="hljs-string">&#x27;bar&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br>在 <span class="hljs-title class_">Webpack</span> 配置中传递选项：<br>&#123;<br>  <span class="hljs-attr">loader</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;path/to/my-loader.js&#x27;</span>),<br>  <span class="hljs-attr">options</span>: &#123;<br>    <span class="hljs-attr">replacement</span>: <span class="hljs-string">&#x27;baz&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="编写plugin"><a href="#编写plugin" class="headerlink" title="编写plugin"></a>编写plugin</h2><ul><li>先说本质是一个类，然后两个核心对象compiler（每次编译的总指挥）、complication（每次编译的所有信息（模块、依赖）、资源生成输出等方面工作）。</li></ul><ol><li>一个类，有apply方法；apply方法在webpack装置插件时候会调用传入compiler对象。</li><li>类除了apply方法外，constructor里面可以收到options，就是webpack配置文件中的配置项。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options = &#123;&#125;</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = options.<span class="hljs-property">message</span> || <span class="hljs-string">&#x27;Hello, Webpack!&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">done</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>);<br>    &#125;);<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>compiler每次编译的总指挥，该对象上有生命周期钩子，使用不同的hooks钩子指定自己特定时期需要发生的处理行为。（hooks：emit：输出资源到文件系统之前触发、done：完成构建后触发，适合输出统计信息；compile：编译器开始编译时候触发）</li><li>complication生成文件、遍历模块然后操作。<br>tap：同步触发；<br> tapAsync：异步回调触发；<br> tapPromise：异步promise模式；</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 生成一个 version.txt 文件：</span><br><span class="hljs-keyword">const</span> &#123; version &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./package.json&#x27;</span>);、<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> &#123;<br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">compilation</span>) =&gt;</span> &#123;<br>      compilation.<span class="hljs-property">assets</span>[<span class="hljs-string">&#x27;version.txt&#x27;</span>] = &#123;<br>        <span class="hljs-attr">source</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-string">`版本号: <span class="hljs-subst">$&#123;version&#125;</span>`</span>,<br>        <span class="hljs-attr">size</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-string">`版本号: <span class="hljs-subst">$&#123;version&#125;</span>`</span>.<span class="hljs-property">length</span>,<br>      &#125;;<br>    &#125;);<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;<br><br><br><span class="hljs-comment">// 遍历所有模块并打印模块路径：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> &#123;<br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">compilation</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">compilation</span>) =&gt;</span> &#123;<br>      compilation.<span class="hljs-property">hooks</span>.<span class="hljs-property">succeedModule</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;模块路径:&#x27;</span>, <span class="hljs-variable language_">module</span>.<span class="hljs-property">resource</span>);<br>      &#125;);<br>    &#125;);<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;<br></code></pre></td></tr></table></figure><h2 id="webpack构建流程"><a href="#webpack构建流程" class="headerlink" title="webpack构建流程"></a>webpack构建流程</h2><ol><li>初始化参数：从配置文件，shell语句中读取参数</li><li>开始编译：用参数初始化complier对象，加载所有的插件<strong>plugin</strong>，执行对象的run方法开始编译。</li><li>确定入口，编译模块：从entry文件出发，调用loader对模块进行翻译，翻译完后解析生成AST语法树，分析AST语法树：遇到导入模块语句时，再找出该模块依赖的模块，递归处理所有依赖。<strong>module &#x3D;&gt; ast &#x3D;&gt; dependences &#x3D;&gt; module</strong></li><li>输出：将依赖关系组成一个个或多个chunk，再把每个chunk转换为文件输出</li><li>plugin：在上述过程中，webpack在特定时间暴露特定事件，插件监听到会执行特定的逻辑，改变输出的结果。</li></ol><h2 id="如何提高构建速度？"><a href="#如何提高构建速度？" class="headerlink" title="如何提高构建速度？"></a>如何提高构建速度？</h2><ol><li>cache-loader：（对loader缓存）将性能开销大的loader输出结果缓存到磁盘，后续使用到该loader的文件先交给cache-loader处理，计算hash值，如果发现有缓存直接复用。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-1.png" alt="alt text"><br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/cache-loader.png" alt="alt text"></li><li>thread-loader：许多loader比如babel-loader支持并行处理，利用多核CPU加速构建。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-2.png" alt="alt text"></li><li>缩小构建作用域：合理配置 loader 的 exclude 和 include 选项，避免不必要的文件被处理<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-3.png" alt="alt text"></li><li>dllplugin：可以帮助将一些第三方依赖（如 React、Vue、Lodash 等）提前打包生成动态链接库（DLL），并且让 Webpack 跳过这些库的重新编译。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-4.png" alt="alt text"></li><li>代码分割：将模块依赖原本的大文件拆分为多个文件，加载页面更快。</li></ol><ul><li>入口分割：指定多个入口点，每个入口点生成独立的chunk</li><li>基于模块的分割：动态调用import，按需加载模块。webpack会把该模块分割成独立的chunk，在路由配置component时候可以用箭头函数调用import引入组件，webpackChunkName申明chunk名，因为每个路由一般是单独的模块。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-8.png" alt="alt text"></li></ul><ol start="6"><li>extrenals，避免打包的资源，通过cdn引入。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-9.png" alt="alt text"><br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-10.png" alt="alt text"></li></ol><h2 id="如何减少打包体积？"><a href="#如何减少打包体积？" class="headerlink" title="如何减少打包体积？"></a>如何减少打包体积？</h2><ol><li>启动tree-shaking：剔除没使用到的模块。</li><li>删除没必要的依赖：webpack-bundle-analyzer这些依赖下载到开发环境中，而不是生产环境。</li><li>按需引入：组件库不要全部引入，使用对应的插件自动引入使用的组件。</li><li>优化图片资源：image-webpack-loader 可以在打包过程中压缩图片。</li><li>压缩js：TerserPlugin（webpack5默认启用），去除注释、空格等。合并变量、函数。删除无用代码（Dead Code Elimination）。</li><li>压缩css：css-minimizer-webpack-plugin。</li></ol><h2 id="webpack热模块更新"><a href="#webpack热模块更新" class="headerlink" title="webpack热模块更新"></a>webpack热模块更新</h2><!-- 思路查阅很多资料、询问deepseek确定是没问题的 --><ul><li>热更新又称为热替换，不用刷新浏览器将新变更的模块替换掉旧的模块。</li></ul><ol><li>webpack开发服务器会与浏览器建立websocket连接，允许客户端和服务端实时通信。</li><li>当webpack检测到有模块变化时，重新编译模块。</li><li>通过socket将hash传送给客户端，客户端对比hash区别，请求更改的文件。</li><li>在客户端进行模块更新。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-5.png" alt="alt text"></li></ol><h2 id="vite和webpack区别"><a href="#vite和webpack区别" class="headerlink" title="vite和webpack区别"></a>vite和webpack区别</h2><ul><li><a href="https://juejin.cn/post/7283682738497765413">https://juejin.cn/post/7283682738497765413</a></li></ul><ol><li>快速冷启动:vite直接启动开发服务器,不用分析模块依赖.利用ESModule的特性,<em><strong>请求某个模块时候再对模块内容编译</strong></em>.webpack是对静态资源打包生成对应的静态资源,使用一些loader,plugin插件等等.</li><li>构建方式：vite构建和按需编译都是esbuild完成，esbuild是go语言编写，可以利用多核CPU；webpack是基于node.js实现，无法利用多核CPU。</li><li>http2：vite采用http2请求，将打包产物分成多个小模块并行加载，请求资源速度更快。</li><li>热模块更新：vite检测到变更后通知浏览器重新请求，浏览器重新请求后再进行编译，并做了强制缓存（依赖模块）和协商缓存（自己的源码模块）；webpack需要将对应的依赖关系重新打包，再进行模块更新。</li></ol><ul><li>webpack适合大型复杂的项目,生态更稳定，vite更适合小型应用开发.<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-6.png" alt="alt text"><br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-7.png" alt="alt text"></li></ul><h2 id="externals优化"><a href="#externals优化" class="headerlink" title="externals优化"></a>externals优化</h2><!-- 穹顶有使用 --><ul><li>部分资源不会打包到输出目录中，而是作为外部依赖通过script标签引入。</li><li>减少打包体积也能提高构建速度。</li></ul><h2 id="chunk是什么-bundle是什么"><a href="#chunk是什么-bundle是什么" class="headerlink" title="chunk是什么 bundle是什么"></a>chunk是什么 bundle是什么</h2><ul><li>chunk：根据模块之间的依赖，将多个模块组成的代码块。</li><li>bundle：最后输出的文件，浏览器可以直接加载。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image.png" alt="alt text"></li></ul><h2 id="npm-和pnpm区别"><a href="#npm-和pnpm区别" class="headerlink" title="npm 和pnpm区别"></a>npm 和pnpm区别</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/683757720">https://zhuanlan.zhihu.com/p/683757720</a></li></ul><ol><li><em><strong>存储方式</strong></em>:pnpm的依赖项下载在全局存储,同一依赖性只会存储一次,节省了磁盘空间.npm将依赖项存储在项目目录中.</li><li><em><strong>硬链接</strong></em>:依赖项不会被复制到项目中,使用硬链接从全局引入到项目中.提高下载速度.npm将依赖项复制到项目目录中.</li><li><em><strong>扁平化依赖树</strong></em>:将依赖树扁平化,避免幽灵依赖的下载.npm保持项目树的原来结构.</li></ol>]]></content>
    
    
    <categories>
      
      <category>打包工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>磁盘调度算法</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>磁盘调度算法的目的很简单，就是为了提高磁盘的访问性能，一般是通过<strong>优化磁盘的访问请求顺序</strong>来做到的。<br><strong>寻道的时间</strong>是磁盘访问最耗时的部分，如果请求顺序优化的得当，必然可以节省一些不必要的寻道时间，从而提高磁盘的访问性能。</li></ul><h2 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h2><ul><li>先到来的请求先被服务。</li></ul><h2 id="最短寻道算法"><a href="#最短寻道算法" class="headerlink" title="最短寻道算法"></a>最短寻道算法</h2><ul><li>优先选择从当前磁头位置所需寻道时间最短的请求。</li><li>饥饿：产生饥饿的原因是磁头在一小块区域来回移动。</li></ul><h2 id="扫描算法（电梯算法）"><a href="#扫描算法（电梯算法）" class="headerlink" title="扫描算法（电梯算法）"></a>扫描算法（电梯算法）</h2><ul><li>往左扫描到没有请求为止，再往右。</li><li>中间的磁道占优势。</li></ul><h2 id="循环扫描"><a href="#循环扫描" class="headerlink" title="循环扫描"></a>循环扫描</h2><ul><li>往左扫描完后，立即磁头回到<strong>最右边0</strong>，又开始往左扫描。</li><li>响应频率更平均。</li></ul><h2 id="LOOK-与-C-LOOK算法"><a href="#LOOK-与-C-LOOK算法" class="headerlink" title="LOOK 与 C-LOOK算法"></a>LOOK 与 C-LOOK算法</h2><ul><li>扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换方向。优化的思路就是磁头在移动到「最远的请求」位置，然后立即反向移动。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>调度算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>页面调度算法</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="内存页面置换算法"><a href="#内存页面置换算法" class="headerlink" title="内存页面置换算法"></a>内存页面置换算法</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>缺页中断：CPU访问的页面不在物理内存中的时候,便会产生缺页中断，会请求操作系统将所缺页调入到物理内存中。</li><li>具体流程：<br><img src="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image.png" alt="图片说明"><br>注意：有空闲页先调度到空闲页，没有空闲页则才需要使用页面置换算法。</li></ul><h2 id="最佳页面置换算法"><a href="#最佳页面置换算法" class="headerlink" title="最佳页面置换算法"></a>最佳页面置换算法</h2><ul><li>置换未来最长时间不访问的页面。</li><li>理想算法，实际中无法预知每个页面下次被访问的时间。</li></ul><h2 id="先进先出置换算法"><a href="#先进先出置换算法" class="headerlink" title="先进先出置换算法"></a>先进先出置换算法</h2><ul><li>选择在内存中滞留时间很长的页面进行置换。</li></ul><h2 id="最近最久未使用LRU置换算法"><a href="#最近最久未使用LRU置换算法" class="headerlink" title="最近最久未使用LRU置换算法"></a>最近最久未使用LRU置换算法</h2><ul><li>选择最长时间没有被访问的页面进行置换。</li><li>很少使用，需要维护一个链表，最近使用的放链表头部，每次访问页面都需要更新链表。</li></ul><h2 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h2><ul><li>所有页面在一个链表中，一个表针指向最老的页面。</li><li>如果访问位是0：置换该页面，并把表针指向前一位。<br>  访问位是1：改为0，并把表针前移一位。</li></ul><h2 id="最不常用算法"><a href="#最不常用算法" class="headerlink" title="最不常用算法"></a>最不常用算法</h2><ul><li>选择访问次数最少的页面进行置换。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>调度算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
