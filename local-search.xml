<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>校招结束后学习记录.md</title>
    <link href="/2025/04/07/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/4.%E6%A0%A1%E6%8B%9B%E7%BB%93%E6%9D%9F%E5%90%8E%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/04/07/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/4.%E6%A0%A1%E6%8B%9B%E7%BB%93%E6%9D%9F%E5%90%8E%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<hr><ol><li>搭建自己的博客。&#9989;</li><li>每天都刷道算法。&#9989;</li><li>微前端除了qiankun，其他解决方案。 入职前完成。</li><li>vue3源码</li><li>node 后端学习</li><li>业务代码</li><li>低代码</li><li>组件库</li></ol><hr><h1 id="3-30"><a href="#3-30" class="headerlink" title="3.30"></a>3.30</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="相等行列对"><a href="#相等行列对" class="headerlink" title="相等行列对"></a>相等行列对</h3><h3 id="从字符串中删除星号"><a href="#从字符串中删除星号" class="headerlink" title="从字符串中删除星号"></a>从字符串中删除星号</h3><ul><li>栈：后进先出的特点。</li></ul><h3 id="小行星碰撞"><a href="#小行星碰撞" class="headerlink" title="小行星碰撞"></a>小行星碰撞</h3><ul><li>栈：要思考特性。</li></ul><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><h1 id="3-31"><a href="#3-31" class="headerlink" title="3.31"></a>3.31</h1><h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><ul><li>复习栈</li><li>刷几道题</li></ul><h2 id="专注"><a href="#专注" class="headerlink" title="专注"></a>专注</h2><h3 id="美团薪资怎么谈"><a href="#美团薪资怎么谈" class="headerlink" title="美团薪资怎么谈"></a>美团薪资怎么谈</h3><h3 id="滴滴offer、两方、三方到哪一步毁约要钱"><a href="#滴滴offer、两方、三方到哪一步毁约要钱" class="headerlink" title="滴滴offer、两方、三方到哪一步毁约要钱"></a>滴滴offer、两方、三方到哪一步毁约要钱</h3><h3 id="准备HR面试"><a href="#准备HR面试" class="headerlink" title="准备HR面试"></a>准备HR面试</h3><h1 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h1><h2 id="专注-1"><a href="#专注-1" class="headerlink" title="专注"></a>专注</h2><h3 id="上午美团HR面"><a href="#上午美团HR面" class="headerlink" title="上午美团HR面"></a>上午美团HR面</h3><h1 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h1><h2 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h2><h3 id="链表最大孪生和"><a href="#链表最大孪生和" class="headerlink" title="链表最大孪生和"></a>链表最大孪生和</h3><h3 id="Dota2参议院"><a href="#Dota2参议院" class="headerlink" title="Dota2参议院"></a>Dota2参议院</h3><ul><li>队列的使用</li></ul><h2 id="专注-2"><a href="#专注-2" class="headerlink" title="专注"></a>专注</h2><h3 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h3><ul><li>挂载到github上，可以访问；统计功能；</li></ul><h1 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h1><h2 id="专注-3"><a href="#专注-3" class="headerlink" title="专注"></a>专注</h2><h3 id="自动文件分类插件"><a href="#自动文件分类插件" class="headerlink" title="自动文件分类插件"></a>自动文件分类插件</h3><h3 id="解决图片"><a href="#解决图片" class="headerlink" title="解决图片"></a>解决图片</h3><h3 id="更换主题色，样式"><a href="#更换主题色，样式" class="headerlink" title="更换主题色，样式"></a>更换主题色，样式</h3><h3 id="迁移八股"><a href="#迁移八股" class="headerlink" title="迁移八股"></a>迁移八股</h3><h1 id="4-4"><a href="#4-4" class="headerlink" title="4.4"></a>4.4</h1><h2 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h2><h3 id="翻转字符串I"><a href="#翻转字符串I" class="headerlink" title="翻转字符串I"></a>翻转字符串I</h3><h3 id="翻转字符串II"><a href="#翻转字符串II" class="headerlink" title="翻转字符串II"></a>翻转字符串II</h3><h2 id="专注-4"><a href="#专注-4" class="headerlink" title="专注"></a>专注</h2><h3 id="博客解决了分类排序问题"><a href="#博客解决了分类排序问题" class="headerlink" title="博客解决了分类排序问题"></a>博客解决了分类排序问题</h3><ul><li>编写一段js代码操作DOM元素。</li></ul><h3 id="劳动教育项目都可运行"><a href="#劳动教育项目都可运行" class="headerlink" title="劳动教育项目都可运行"></a>劳动教育项目都可运行</h3><ul><li>正常功能：登录；学生信息；管理员信息；系统日志；公告管理；</li><li>目前bug：<br>劳动记录发布无法查到；移动端无法获取到学期。<br>管理端：首页，审核，劳动计划；<br>移动端：劳动计划，劳动记录。</li></ul><h1 id="4-5"><a href="#4-5" class="headerlink" title="4.5"></a>4.5</h1><h2 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h2><h3 id="将所有数字用字符串替代"><a href="#将所有数字用字符串替代" class="headerlink" title="将所有数字用字符串替代"></a>将所有数字用字符串替代</h3><ol><li>String.fromCharCode()：将数字转换为字符。</li><li>str.charCodeAt(str字符串的下标)：将str第i个下标字符转换为数字。</li></ol><h3 id="重复的字符串"><a href="#重复的字符串" class="headerlink" title="重复的字符串"></a>重复的字符串</h3><ul><li>暴力写的，KMP没学。</li></ul><h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><h2 id="专注-5"><a href="#专注-5" class="headerlink" title="专注"></a>专注</h2><h3 id="博客迁移完毕"><a href="#博客迁移完毕" class="headerlink" title="博客迁移完毕"></a>博客迁移完毕</h3><h1 id="4-6出去放松一天"><a href="#4-6出去放松一天" class="headerlink" title="4.6出去放松一天"></a>4.6出去放松一天</h1><h1 id="4-7"><a href="#4-7" class="headerlink" title="4.7"></a>4.7</h1><h2 id="算法-5"><a href="#算法-5" class="headerlink" title="算法"></a>算法</h2><h3 id="所有可能的路径"><a href="#所有可能的路径" class="headerlink" title="所有可能的路径"></a>所有可能的路径</h3><h3 id="岛屿数量：深搜、广搜。"><a href="#岛屿数量：深搜、广搜。" class="headerlink" title="岛屿数量：深搜、广搜。"></a>岛屿数量：深搜、广搜。</h3>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>代理</title>
    <link href="/2025/04/05/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%BB%A3%E7%90%86/"/>
    <url>/2025/04/05/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h2 id="Whistle"><a href="#Whistle" class="headerlink" title="Whistle"></a>Whistle</h2><p>Whistle 是一个用于网络调试和抓包的代理工具。简单来说，它能帮助你查看、修改和控制网络请求和响应，类似于一个中间人，可以拦截和处理你电脑或手机上的网络流量。<br>whistle代理作用是获取某个域名下的cookie配置,方便在本地开发时候有访问接口请求的权限.<br>作用:</p><ul><li>重定向请求：你可以把某个请求重定向到另一个服务器或者文件，<em><strong>比如把一个图片请求重定向到本地的图片文件，这样即使服务器上的图片改变了，你也能看到你本地的版本。</strong></em></li><li>抓包和调试：当你访问一个网站或使用一个应用时，Whistle 可以拦截这些请求，帮你看到后台发送的所有数据，比如HTTP请求和响应。这对开发者调试和分析网络问题特别有用。</li><li>修改请求和响应：你可以用 Whistle 来修改网络请求或响应的数据，比如替换请求中的某些参数，或者篡改服务器返回的数据。这对于测试某些功能或者做一些特殊处理很有帮助。</li></ul><h2 id="要启动-Whistle-代理工具，你需要按照以下步骤进行操作。这些步骤涵盖了安装、配置和启动-Whistle-的基本过程。"><a href="#要启动-Whistle-代理工具，你需要按照以下步骤进行操作。这些步骤涵盖了安装、配置和启动-Whistle-的基本过程。" class="headerlink" title="要启动 Whistle 代理工具，你需要按照以下步骤进行操作。这些步骤涵盖了安装、配置和启动 Whistle 的基本过程。"></a>要启动 Whistle 代理工具，你需要按照以下步骤进行操作。这些步骤涵盖了安装、配置和启动 Whistle 的基本过程。</h2><p>步骤 1：安装 Node.js<br>Whistle 是基于 Node.js 的，因此你需要先安装 Node.js.</p><p>步骤 2: 输入以下命令安装 Whistle：<br>npm install -g whistle<br>这将全局安装 Whistle，使你可以在任何地方使用 w2 命令启动 Whistle。</p><p>步骤 3：启动 Whistle<br>在终端中输入以下命令启动 Whistle：<br>w2 start<br>启动成功后，Whistle 会在默认的端口 8899 上运行。你可以在浏览器中访问以下地址来打开 Whistle 的 Web 界面：<a href="http://127.0.0.1:8899/">http://127.0.0.1:8899</a></p><p>步骤 4：配置代理<br>为了使你的设备通过 Whistle 代理，你需要进行一些配置：</p><p>配置浏览器代理：</p><p>在浏览器中，找到代理设置（通常在网络或高级设置中）。<br>将 HTTP 和 HTTPS 代理都设置为 127.0.0.1，端口为 8899。</p><p>步骤 5：使用 Whistle<br>打开浏览器访问任何网站，Whistle 会拦截并显示所有请求和响应。<br>在 Whistle 的 Web 界面中，你可以看到所有被拦截的流量，进行调试、修改和分析。</p><p>步骤6:停止 Whistle<br>如果你想停止 Whistle，可以在终端中输入以下命令：<br>w2 stop<br>这会停止 Whistle 代理。</p><p>通过以上步骤，你应该可以成功安装、启动并使用 Whistle 代理工具来进行网络调试和分析。</p><h2 id="浏览器配置代理"><a href="#浏览器配置代理" class="headerlink" title="浏览器配置代理"></a>浏览器配置代理</h2><ul><li>为了让浏览器走whistle代理规则,比如这个网站获取的资源是本地的一个网站.<br>SwitchyOmega 插件配置：<br>安装 SwitchyOmega 扩展（可在 Chrome 和 Firefox 的扩展商店找到）。<br>打开 SwitchyOmega 的选项页面。<br>创建一个新情景模式，命名为“Whistle”。<br>在代理服务器设置中，设置 HTTP 和 HTTPS 代理为 127.0.0.1，端口为 8899。<br>保存设置并激活“Whistle”情景模式</li></ul><h2 id="为什么浏览器配置是127-0-0-1"><a href="#为什么浏览器配置是127-0-0-1" class="headerlink" title="为什么浏览器配置是127.0.0.1"></a>为什么浏览器配置是127.0.0.1</h2><ul><li>什么是 127.0.0.1？</li><li>本地回环地址：127.0.0.1 是一个特殊的 IP 地址，表示本地计算机自身。所有发送到这个地址的网络流量都不会离开本地计算机，而是直接在本地处理。</li><li>本地主机名：也叫 localhost，它用于测试和开发过程中，便于网络应用在本地运行和调试。</li></ul><h2 id="整个代理过程"><a href="#整个代理过程" class="headerlink" title="整个代理过程"></a>整个代理过程</h2><ul><li>详细流程步骤</li></ul><ol><li>浏览器发送请求<br>输入网址：你在浏览器地址栏输入 <a href="http://example.com/">http://example.com</a> 并按下回车。<br>浏览器生成请求：浏览器生成一个 HTTP 请求，准备发送到配置的代理服务器。</li><li>浏览器代理设置拦截请求<br>浏览器检查代理配置：浏览器发现已配置代理服务器地址为 127.0.0.1 和端口 8899。<br>发送到代理服务器：浏览器将请求发送到本地代理服务器（Whistle）而不是直接发送到 example.com。</li><li>Whistle 处理请求<br>接收请求：Whistle 在 127.0.0.1:8899 端口接收到浏览器的请求。<br>拦截和处理：Whistle 根据配置文件或规则对请求进行处理，例如记录请求日志、修改请求头或内容。<br>决定后续操作：Whistle 可以选择直接返回本地响应（例如缓存响应）或将请求转发到目标服务器。</li><li>Whistle 代理向目标服务器发送请求<br>转发请求：Whistle 将处理后的请求转发到目标服务器 example.com。<br>实际网络请求：这个请求现在通过网络发送到 example.com 的服务器。</li></ol>]]></content>
    
    
    <categories>
      
      <category>其它知识点</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>场景</title>
    <link href="/2025/04/05/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%9C%BA%E6%99%AF/"/>
    <url>/2025/04/05/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="string的replace方法-10024"><a href="#string的replace方法-10024" class="headerlink" title="string的replace方法 &#10024;"></a>string的replace方法 &#10024;</h2><ul><li><a href="https://blog.csdn.net/qq_46658751/article/details/123390095">https://blog.csdn.net/qq_46658751/article/details/123390095</a></li></ul><ol><li>replace(字符串，字符串)，只能替换一次</li><li>replace（正则，字符串）多次替换</li><li>replace（正则，函数）核心用法，函数第一个参数是匹配到的子串，第二个是起始索引，第三个是字符串本身。如果有捕获器的值则插入在第二个参数，起始索引变第三个参数，字符串本身变第四个参数。</li></ol><h2 id="虚拟DOM相比真实DOM的优点？"><a href="#虚拟DOM相比真实DOM的优点？" class="headerlink" title="虚拟DOM相比真实DOM的优点？"></a>虚拟DOM相比真实DOM的优点？</h2><ol><li><strong>异步批量更新</strong>（watch队列，nextTick的缓冲队列），减少频繁的DOM操作。</li><li><strong>最小化DOM操作</strong>：通过diff算法对比两次虚拟DOM树的区别，尽可能复用现有的真实DOM。</li><li><strong>跨平台渲染</strong>：浏览器渲染，服务端渲染。</li></ol><h2 id="虚拟DOM一定比真实DOM更快吗？"><a href="#虚拟DOM一定比真实DOM更快吗？" class="headerlink" title="虚拟DOM一定比真实DOM更快吗？"></a>虚拟DOM一定比真实DOM更快吗？</h2><ol><li>不一定。解析模板、ast语法树、渲染函数、虚拟DOM创建、diff对比、真实DOM创建都是要消耗性能的。如果是简单的页面，直接操作真实DOM效率更高。</li><li>也增加了内存消耗。</li></ol><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><ul><li><a href="https://blog.csdn.net/leman314/article/details/111936863">https://blog.csdn.net/leman314/article/details/111936863</a></li></ul><ol><li>布局视口：文档对象的逻辑尺寸，pc端和浏览器窗口大小差不多。移动端远大于手机尺寸。</li><li>理想视口：是布局视口的理想尺寸，和设备宽度相同。</li><li>视觉视口：用户在网页看到的区域。理想视口尺寸&#x2F;缩放比例。</li></ol><h2 id="只设置initial-scale，不设置width可以吗？"><a href="#只设置initial-scale，不设置width可以吗？" class="headerlink" title="只设置initial-scale，不设置width可以吗？"></a>只设置initial-scale，不设置width可以吗？</h2><ol><li>问题：initial-scale是理想&#x2F;视觉，如果不设置width，那么布局也等于视觉（这是一条定律），布局＝视觉＝理想不就可以了吗？</li><li>IE浏览器使用横屏时候，布局会等于竖屏的理想视口。</li></ol><h2 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h2><ol><li>使用视口配置，width定义布局视口大小等于理想视口，initial-scale设置理想视口和视觉视口比例。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span> = <span class="hljs-string">&quot;width = device-width ,initial-scale = 1.0&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>媒体查询</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span> :<span class="hljs-number">1024px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>:<span class="hljs-number">768px</span>)&#123;<br>  <span class="hljs-selector-tag">html</span> : &#123;<br>    <span class="hljs-attribute">font-size</span>:<span class="hljs-number">18px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>百分比布局</li></ol><ul><li>使用%、em、rem相对单位，不要用px绝对单位。</li></ul><ol start="4"><li>弹性盒子flex</li></ol><ul><li>flex：主轴、侧轴、排列方式（align-items、justify-content）</li></ul><ol start="5"><li><p>组件库vant</p></li><li><p>设计稿匹配</p></li></ol><ul><li>主流设备的375px（iphone6&#x2F;7&#x2F;8）</li></ul><h2 id="后端存储的是密码吗？"><a href="#后端存储的是密码吗？" class="headerlink" title="后端存储的是密码吗？"></a>后端存储的是密码吗？</h2><ul><li>不是的。后端只有请求过来时候看得到密码。实际存储在数据库里的是加盐然后用加密算法加密后的暗文。所以找回密码是找不到之前的密码的。</li></ul><h2 id="token解析不就会暴露信息吗？"><a href="#token解析不就会暴露信息吗？" class="headerlink" title="token解析不就会暴露信息吗？"></a>token解析不就会暴露信息吗？</h2><ul><li>token组成是三个部分，第三个部分是对前两个部分的加密，前两个可以解析，第三个不能解析。</li></ul>]]></content>
    
    
    <categories>
      
      <category>其它知识点</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>春招学习记录</title>
    <link href="/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/3.%E6%98%A5%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/3.%E6%98%A5%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="春招计划"><a href="#春招计划" class="headerlink" title="春招计划"></a>春招计划</h1><ol><li>上午算法</li><li>下午刚开始js手写</li><li>下午晚上八股 + 项目</li><li>晚上回去看面经或者js手写</li></ol><hr><p>css &#9989;</p><p>js：基础、代码输出题。&#9989;</p><p>vue：源码、八股。 &#9989;</p><p>ts：八股、手写。 &#9989;</p><p>webpack、vite：八股。 &#9989;</p><p>git：八股。 &#9989;</p><p>计算机网络 &#9989;</p><p>操作系统 &#9989;</p><p>算法 &#9989; &#x2F;&#x2F; 每天上午复习算法</p><p>js手写 &#9989; &#x2F;&#x2F; 每天晚上回去搞一两道</p><p>浏览器原理 &#9989;</p><p>微前端 &#9989;</p><p>项目 &#9989;</p><hr><h1 id="2-14"><a href="#2-14" class="headerlink" title="2.14"></a>2.14</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="总结背包问题递推公式、遍历顺序（完全背包的组合和排列问题）"><a href="#总结背包问题递推公式、遍历顺序（完全背包的组合和排列问题）" class="headerlink" title="总结背包问题递推公式、遍历顺序（完全背包的组合和排列问题）"></a>总结背包问题递推公式、遍历顺序（完全背包的组合和排列问题）</h3><h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h3><h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h3><h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h3><h1 id="2-15"><a href="#2-15" class="headerlink" title="2.15"></a>2.15</h1><h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><h3 id="打家结舍1"><a href="#打家结舍1" class="headerlink" title="打家结舍1"></a>打家结舍1</h3><h3 id="打家结舍2"><a href="#打家结舍2" class="headerlink" title="打家结舍2"></a>打家结舍2</h3><h3 id="打家结舍3"><a href="#打家结舍3" class="headerlink" title="打家结舍3"></a>打家结舍3</h3><h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><ul><li>二叉搜索树的插入：返回值是节点，要接受。<strong>二叉搜索树遍历特征：遍历是有顺序的，可以在遍历终止条件操作。</strong></li><li>删除二叉搜索树的节点：考虑多种情况，两边都没子节点，一边有子节点，两边都有子节点。<br><strong>改变树，最后结果要返回树：返回值是节点，先用left &#x3D; root.left, right &#x3D; root.right保留一遍，再用root.left &#x3D; left,root.right &#x3D; right接受一遍值。</strong></li></ul><h2 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h2><h3 id="代码输出题：this"><a href="#代码输出题：this" class="headerlink" title="代码输出题：this"></a>代码输出题：this</h3><h3 id="代码输出题：作用域"><a href="#代码输出题：作用域" class="headerlink" title="代码输出题：作用域"></a>代码输出题：作用域</h3><h3 id="代码输出题：原型链"><a href="#代码输出题：原型链" class="headerlink" title="代码输出题：原型链"></a>代码输出题：原型链</h3><h3 id="xss，csrf"><a href="#xss，csrf" class="headerlink" title="xss，csrf"></a>xss，csrf</h3><ul><li>xss：是什么？有什么危害？哪些类型？如何预防？</li><li>csrf：是什么？分类？如何预防？</li></ul><h3 id="强制缓存，协商缓存"><a href="#强制缓存，协商缓存" class="headerlink" title="强制缓存，协商缓存"></a>强制缓存，协商缓存</h3><ul><li>强制缓存三种，expires&#x2F;cache-control</li><li>协商缓存两种，last-modified&#x2F;if-modified-since，etag&#x2F;if-none-match</li></ul><h3 id="浏览器组成"><a href="#浏览器组成" class="headerlink" title="浏览器组成"></a>浏览器组成</h3><ol><li>用户界面：书签栏、前进后退、地址栏等等。</li><li>浏览器主引擎：处理用户交互，传递信息给渲染引擎。</li><li>渲染引擎：负责解析html、css，浏览器渲染的过程。</li><li>js引擎：解析执行js。</li><li>网络：发送请求，加载资源。</li><li>数据存储：localstroge、cookie、indexedDB、历史记录、书签等等。</li></ol><h3 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h3><ul><li><a href="https://segmentfault.com/a/1190000042909353">https://segmentfault.com/a/1190000042909353</a></li></ul><ol><li>解析html文档,生成DOM树,由html元素和属性节点组成.</li><li>解析css,生成css树.</li><li>根据DOM树和CSS树构建渲染树</li><li>布局(回流):渲染树进行布局计算每个渲染节点的位置和大小.</li><li>绘制(重绘):将渲染树的节点绘制到页面上.</li><li>复合: 浏览器的绘制是绘制到多层,每一层单独渲染,最后合成到一起形成页面.</li><li>重绘:重绘不会带来重新布局,一般是修改背景颜色,边框阴影等属性.</li><li>回流:消耗性能,改变元素位置,DOM结构发生变化.</li></ol><h1 id="2-16"><a href="#2-16" class="headerlink" title="2.16"></a>2.16</h1><h2 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h2><h3 id="买卖股票最佳时机1"><a href="#买卖股票最佳时机1" class="headerlink" title="买卖股票最佳时机1"></a>买卖股票最佳时机1</h3><ul><li>动态规划：dp【i】【0】表示持有股票的最大现金，dp【i】【1】表示不持有股票的最大现金。</li></ul><h3 id="买卖股票最佳时机2"><a href="#买卖股票最佳时机2" class="headerlink" title="买卖股票最佳时机2"></a>买卖股票最佳时机2</h3><h3 id="摆动队列"><a href="#摆动队列" class="headerlink" title="摆动队列"></a>摆动队列</h3><ul><li>动态规划</li></ul><h3 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h3><ul><li>返回值是节点。</li></ul><h3 id="有序数组转换为平衡二叉搜索树"><a href="#有序数组转换为平衡二叉搜索树" class="headerlink" title="有序数组转换为平衡二叉搜索树"></a>有序数组转换为平衡二叉搜索树</h3><ul><li>递归参数是数组，返回值是节点，要被接受。</li></ul><h3 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h3><ul><li>遍历，修改值。不需要返回值，单独写一个函数。</li></ul><h2 id="八股-1"><a href="#八股-1" class="headerlink" title="八股"></a>八股</h2><ul><li>浏览器事件机制，同源，本地存储。（记深一点）（计算机网络）</li></ul><h3 id="浏览器渲染优化"><a href="#浏览器渲染优化" class="headerlink" title="浏览器渲染优化"></a>浏览器渲染优化</h3><ol><li>js: script标签写在body后面. 用async和defer.</li><li>css:用link引入,开启一个线程去加载,不阻塞GUI渲染线程. @import:GUI线程会停止渲染去加载资源. css少的话就写在style标签中直接GUI渲染.</li></ol><!-- 3. html:减少嵌套层次,减少回流重绘操作 --><h3 id="减少回流和重绘操作"><a href="#减少回流和重绘操作" class="headerlink" title="减少回流和重绘操作"></a>减少回流和重绘操作</h3><ol><li>操作低层次的DOM.</li><li>脱离文档流,减少对其他元素影响.</li><li>将DOM读写操作分别放到一起,浏览器的渲染队列机制.</li><li>一些css属性形成新的合成层: transform,opacity等等.浏览器把这些变化交给GPU处理(不是所有合成层都给GPU,只有动画视觉效果时候交给GPU),GPU直接在显存中更改元素显示位置,无需CPU进行布局绘制的计算.</li><li>不要使用table布局，一个小的改动可能导致整个table重新布局。</li><li><strong>documentFragment</strong>：避免频繁操作DOM，可以创建一个文档片段documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中</li></ol><h3 id="DocumentFragments-10024"><a href="#DocumentFragments-10024" class="headerlink" title="DocumentFragments &#10024;"></a>DocumentFragments &#10024;</h3><ul><li>轻量级、批量操作DOM元素，临时存储的容器。</li><li>DocumentFragments存在于内存中，不是主 DOM 树的一部分，将子元素插入到文档片段时不会引起页面回流。通常的用例是创建文档片段，元素附加到文档片段，然后将文档片段附加到 DOM 树。</li></ul><h3 id="cookie、localStorage、SessionStorage区别"><a href="#cookie、localStorage、SessionStorage区别" class="headerlink" title="cookie、localStorage、SessionStorage区别"></a>cookie、localStorage、SessionStorage区别</h3><ul><li>cookie：内存小4KB；请求会携带发送，通常配合session。</li><li>localStorage：内存更大5MB；请求不会携带；持久存储，不主动删除会一直存在；不同标签页能共享数据。</li><li>sessionStorage：关闭页面就会清除；不同标签页之间不能共享数据。</li></ul><h3 id="cookie字段-10024"><a href="#cookie字段-10024" class="headerlink" title="cookie字段 &#10024;"></a>cookie字段 &#10024;</h3><ol><li>name、value、size。</li><li>domain、path。</li><li>Secure，sameSite，http-only</li><li>Expires&#x2F;Max-size</li></ol><h3 id="cookie特性-10024"><a href="#cookie特性-10024" class="headerlink" title="cookie特性 &#10024;"></a>cookie特性 &#10024;</h3><ol><li>服务端响应头里面有set-cookie属性可以设置cookie；客户端document.cookie可以设置cookie。</li><li>cookie发送条件：domain、path与发送的域名匹配；security只能通过https发送；cookie时间还有效。</li><li>cookie安全性：http-only限制不被js读取；sameSite防止csrf攻击；Secure只允许https请求。</li><li>cookie默认请求都会携带，除非配置不携带。</li></ol><h3 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h3><ul><li>键值对、异步、内存大、事务。</li></ul><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><ul><li>协议、域名、端口号都要相等。</li><li>限制：js不能访问其他源的cookie、localStorage；js不能访问dom；js不能跨域请求。</li></ul><h3 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h3><ol><li>CORS跨域资源共享：浏览器允许某个域接受来自其他源的资源。由服务端配置响应头，浏览器自动处理。</li><li>JSONP：利用script标签没有跨域限制。但只能发送get请求。请求携带一个全局回调函数，script标签里将返回数据拼凑到回调函数中，返回给浏览器。浏览器解析执行，从而前端拿到数据。</li><li>postmessage：多个页面之间、iframe之间通信。父应用里面获取子应用iframe，然后用contentWindow.postmessage发送消息，子应用里面监听message事件获取数据。</li><li>vue配置代理服务器，在开发时候解决跨域。</li></ol><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><ol><li>DOM0：没有事件流。</li><li>IE事件模型：事件触发，事件冒泡。</li><li>DOM2：事件捕获从外到里，事件触发，事件冒泡。</li></ol><p>stopPropagation</p><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><ol><li>利用事件冒泡的机制，子元素的监听事件绑定到父元素上，父元素集中处理子元素的事件</li><li>减少内存消耗、动态事件绑定</li><li>缺点：focus事件没有冒泡机制、DOM层数深不建议消耗性能。</li></ol><h1 id="2-17"><a href="#2-17" class="headerlink" title="2.17"></a>2.17</h1><h2 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h2><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><h3 id="最长连续递增子序列"><a href="#最长连续递增子序列" class="headerlink" title="最长连续递增子序列"></a>最长连续递增子序列</h3><h3 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h3><ul><li>这三个题目dp数组都要以第i个元素为结尾来定义。</li></ul><h3 id="复习-1"><a href="#复习-1" class="headerlink" title="复习"></a>复习</h3><ul><li>分发饼干</li><li>摆动队列</li><li>最大子序列和：动态规划，前面的加上我和我自己独立开始哪个更大。</li><li>跳跃游戏：每次跳最远的下标处，当下标超过数组长度-1时候返回true。</li></ul><h2 id="八股-2"><a href="#八股-2" class="headerlink" title="八股"></a>八股</h2><h3 id="事件委托-1"><a href="#事件委托-1" class="headerlink" title="事件委托"></a>事件委托</h3><ol><li>利用事件冒泡的机制，子元素的监听事件绑定到父元素上，父元素集中处理子元素的事件</li><li>减少内存消耗、动态事件绑定</li><li>缺点：focus事件没有冒泡机制、DOM层数深不建议消耗性能。</li></ol><h3 id="同步，异步"><a href="#同步，异步" class="headerlink" title="同步，异步"></a>同步，异步</h3><ul><li>举一个发送请求的例子，同步要等请求回来再执行后面的代码，异步是先去执行其他任务，异步任务执行完后再去执行对应的回调。</li></ul><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><ul><li>js代码执行，函数执行时候创建执行上下文，压入执行栈中执行。</li></ul><h3 id="宏任务，微任务"><a href="#宏任务，微任务" class="headerlink" title="宏任务，微任务"></a>宏任务，微任务</h3><ul><li>宏任务：setTimeout、setInterval、script脚本。</li><li>微任务：promise的回调、async回调、监听DOM的mutationObserver。</li></ul><h3 id="复习-2"><a href="#复习-2" class="headerlink" title="复习"></a>复习</h3><ul><li>csrf、xss。</li><li>浏览器缓存</li><li>浏览器组成</li><li>浏览器渲染过程</li><li>浏览器渲染优化，减少回流、重绘，文档碎片。</li><li>cookie、localStorage、SessionStorage。</li><li>同源策略</li><li>跨域</li></ul><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><ul><li>TCP&#x2F;IP四层模型：应用层、传输层、网络层、网络接口层。</li><li>OSI模型：七层。</li></ul><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul><li>200，204，206</li><li>301，302，304</li><li>400，403，404</li><li>500</li></ul><h3 id="http常见字段"><a href="#http常见字段" class="headerlink" title="http常见字段"></a>http常见字段</h3><ul><li>origin、host</li><li>connection：keep-alive，长连接。</li><li>accept、content-type</li><li>accpet-encoding、content-encoding</li><li>authorization</li><li>cookie</li></ul><h3 id="请求和响应组成"><a href="#请求和响应组成" class="headerlink" title="请求和响应组成"></a>请求和响应组成</h3><ul><li>请求行（方法，路径，http版本），请求头，空行，请求体（get请求一般没有）</li><li>状态行（http版本，状态码，描述），响应头，空行，响应体</li></ul><h3 id="get、post区别"><a href="#get、post区别" class="headerlink" title="get、post区别"></a>get、post区别</h3><ol><li>获取数据，新增、修改数据。</li><li>get一般是幂等，post不是。</li><li>get请求是在url后面长度和编码都有限制，post请求没有，post请求有请求体。</li><li>get请求一般可以缓存。</li></ol><h3 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>长连接，无需重复建立TCP连接。在http1.0每次通信都要重新进行tcp三次握手。</li><li>管道运输：第一个请求发送后，不用等其回来就能发送第二个请求。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>无状态 &#x3D;》 cookie</li><li>明文传输 &#x3D;》 https</li><li>队头阻塞，后面排序的请求无法发出。（管道传输大部分浏览器不支持）</li></ol><h4 id="http1-0和http1-1"><a href="#http1-0和http1-1" class="headerlink" title="http1.0和http1.1"></a>http1.0和http1.1</h4><ol><li><strong>长短连接</strong>：长连接短链接</li><li><strong>缓存字段</strong>：强制缓存协商缓存字段区别，cache-control是1.1的。</li><li><strong>状态码</strong>：新增了状态码，比如206.</li><li><strong>范围请求</strong>：请求头加入range字段，请求部分数据，返回206。</li><li><strong>管道运输</strong>：是否支持管道运输</li><li><strong>Host头部字段</strong>：解决一个ip地址对应多个域名情况。</li></ol><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><ul><li>在tcp三次握手后还要进行tls握手</li></ul><ol><li>明文传输：使用混合加密，非对称加密协商出会话密钥，后续通信采用会话密钥的对称加密进行加密通信。</li><li>消息篡改：先进行哈希运算，再通过私钥加密哈希值生成数字签名。将数字签名和内容一同发送。客户端通过公钥解密，对内容进行hash运算，对比hash值是否相同。</li><li>身份认证：防止公钥被替换，用数字证书给公钥加密。CA的私钥加密，CA的公钥在操作系统或者浏览器内部嵌入了。</li></ol><h3 id="TLS握手"><a href="#TLS握手" class="headerlink" title="TLS握手"></a>TLS握手</h3><ol><li>随机数、密码套件、支持的tls版本号。</li><li>选择密码、tls版本，生成随机数，数字证书。</li><li>取出公钥，第三个随机数用公钥加密发送，三个随机数生成会话密钥，通知后续用会话密钥通信。</li><li>服务端私钥解密获取第三个随机数，生成会话密钥，通知后续用会话密钥通信。</li></ol><h1 id="2-18"><a href="#2-18" class="headerlink" title="2.18"></a>2.18</h1><h2 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h2><!-- - 三四天搞完动态规划和贪心复习，然后开始链表刷题 + 复习回溯。 --><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><h3 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a>不相交的线</h3><ul><li>就是最长公共子序列</li></ul><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><h3 id="复习-3"><a href="#复习-3" class="headerlink" title="复习"></a>复习</h3><ul><li>子序列问题小总结</li><li><strong>跳跃游戏II</strong>:while(最远范围下标 &lt; 数组长度)考虑每次能跳到的最远范围,然后次数加1.</li><li>k次取反后的最大化的数组:按绝对值的从大到小排列,k先给大负数取反.剩余k给最小值反复取反.</li></ul><h2 id="八股-3"><a href="#八股-3" class="headerlink" title="八股"></a>八股</h2><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><ul><li>RSA是大整数分解困难的数学难题，ECDHE是离散对数的数学难题。</li><li>RSA不支持前向保密：私钥被破解前面的通信都会被破解，ECDHE支持：私钥会不断变化，会话密钥也会变化。</li></ul><h3 id="https优化"><a href="#https优化" class="headerlink" title="https优化"></a>https优化</h3><ol><li>tls1.2 &#x3D;》1.3，第三次握手后就可以通信，升级到ECDHE算法：支持前向保密。</li><li>验证证书有效性：不要让客户端去轮询问CA有效性，由服务端请求证书有效性并且用CA加密，让服务端无法篡改，再发送给客户端。</li><li>会话复用：类似sesstion、token的机制。</li></ol><h3 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h3><ol><li><strong>头部压缩</strong>：静态表（在一张表中有常见的头部字段，对应下标1，2，3，4，5），动态表（双方通信过程中出现的字符，添加到hash表中，用更短下标表示字符），哈夫曼编码（高频出现的字符，用更短的编码编写）。</li><li><strong>二进制帧</strong>：http2将请求响应分解为二进制帧，每个帧对应streamID，区分不同请求响应。</li><li><strong>并发传输</strong>：多个stream流利用同一个TCP连接，一个stream流中有请求线和响应线，每个请求或响应对应多个frame帧，帧根据streamID重新组装。</li><li><strong>服务端主动推送</strong>：比如用户请求html，服务端可以在当前流回应html数据，并通知另一个流中发送了css数据。</li></ol><h3 id="http3-0"><a href="#http3-0" class="headerlink" title="http3.0"></a>http3.0</h3><ul><li>抛弃了TCP，采用了基于UDP的quic协议。速度更快，没有复杂的连接建立。</li></ul><ol><li><strong>http层</strong>：静态表扩充：更多的字段可以用简短的下标表示；有单独的流去同步双方动态表信息，防止前面请求包丢失，后续请求到达无法解码的问题。</li><li><strong>无队头阻塞</strong>：TCP的问题是：前面的包未接受，后面的也就无法接受。比如某第三个流数据全部到达，但第二个流数据未全部到达，就无法读取第三个流数据。而在3.0中各个流之间不会影响，当前流数据丢弃，其它流数据能正常接受，只会重传当前流数据。</li><li>更快的连接建立：在以前tcp和tls握手是分层的（2.0，3.0都基于https），3.0中quic协议握手确认双方的连接id和tls协议能够一同发送。</li><li><strong>连接迁移</strong>：以前是通过ip+端口确认连接，如果设备ip地址改变，则需要重新tcp三次握手、tls四次握手建立连接。</li></ol><h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><ol><li>不断轮询</li><li>长轮询</li><li>websocket：tcp本就是全双工，可以双向通信。客户端需要先进行一次http请求，请求头携带upgrade，服务端返回101.</li></ol><h3 id="TCP、UDP区别"><a href="#TCP、UDP区别" class="headerlink" title="TCP、UDP区别"></a>TCP、UDP区别</h3><ol><li>连接：TCP三次握手四次挥手，UDP直接发送数据。</li><li>服务对象：TCP一对一，UDP一对多。</li><li>可靠：TCP通过停止等待协议、超时重传等机制保证可靠性，UDP不可靠。</li><li>拥塞控制、流量控制</li><li>字节流、包</li></ol><h1 id="2-19"><a href="#2-19" class="headerlink" title="2.19"></a>2.19</h1><h2 id="算法-5"><a href="#算法-5" class="headerlink" title="算法"></a>算法</h2><h3 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h3><h3 id="两个字符串删除操作"><a href="#两个字符串删除操作" class="headerlink" title="两个字符串删除操作"></a>两个字符串删除操作</h3><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><h3 id="复习-4"><a href="#复习-4" class="headerlink" title="复习"></a>复习</h3><ul><li>最长公共子序列：dp[i][j] &#x3D; dp[i - 1][j - 1] + 1；dp[i][j] &#x3D; Math.max(dp[i - 1][j], dp[i][j - 1]);</li><li>判断子序列、两个字符串删除、编辑距离。</li></ul><!-- - 加油站、柠檬水找零、根据身高重建队列。晚上有空再看 --><h2 id="八股-4"><a href="#八股-4" class="headerlink" title="八股"></a>八股</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul><li>开始客户端和服务端都处于关闭状态，服务端主动进入监听。</li></ul><ol><li>客户端发送SYN信号+序列号</li><li>服务端返回ACK信号+ack（是客户端序列号加1），再发送自己的SYN信号+序列号。</li><li>客户端返回ACK信号+ack（服务端序列号+1）.第三次握手还可以携带数据，前两次不可以。</li></ol><h3 id="四次握手，两次握手问题"><a href="#四次握手，两次握手问题" class="headerlink" title="四次握手，两次握手问题"></a>四次握手，两次握手问题</h3><ul><li>四次握手也可以，但是服务端的ack和syn可以一同发送，所以合并成了一次握手。</li><li>两次握手不行原因？</li></ul><ol><li>避免历史连接。发送一个请求，但因为网络原因滞留在网络中，后面重新连接发送请求但之前的握手先到达，两次握手会直接建立连接，消耗性能。三次握手有中间状态，第二次握手请求过来后如果客户端发现不是自己的连接可以回复RST报文中止连接。</li><li>同步双方序列号，服务端发送请求后，客户端要确认序列号，这样服务端才能保证客户端收到了同步信息。</li></ol><h3 id="握手丢失会发生什么？"><a href="#握手丢失会发生什么？" class="headerlink" title="握手丢失会发生什么？"></a>握手丢失会发生什么？</h3><ol><li>第一次握手：因为没收到服务端应答超时重传，1s，2s，4s每次等待时间是上次两倍，到达最大次数后断开连接。</li><li>第二次握手：第一次握手也会重传因为客户端没收到应答认为自己的消息丢失。服务端也会超时重传因为没收收到客户端应答，也是达到最大次数断开连接。</li><li>第三次握手：服务端超时重传因为没有收到客户端应答，客户端ack信息有个特征：收到请求才会发送一次，不会多次发送。</li></ol><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><ol><li>第一次挥手：客户端发送FIN信号，请求断开连接。</li><li>第二次握手：服务端收到FIN信号后，回复ACK确认信号。继续发送完自己的消息。</li><li>第三次握手：等服务端消息发送完毕后，发送FIN信号请求断开连接。</li><li>第四次握手：客户端回应ACK。等待2MSL时间后关闭。服务端收到ack后关闭。</li></ol><h3 id="三次挥手问题"><a href="#三次挥手问题" class="headerlink" title="三次挥手问题"></a>三次挥手问题</h3><ul><li>如果服务端没有数据要发送，并且开启了TCP延迟确认机制，就可以变成三次握手。</li><li>发送没有携带数据的ACK是效率比较低的，如果有数据要发送，ACK可以携带部分数据。如果没有数据发送ACK会等待一段时间后看是否有数据携带发送。</li></ul><h3 id="挥手丢失会发生什么？"><a href="#挥手丢失会发生什么？" class="headerlink" title="挥手丢失会发生什么？"></a>挥手丢失会发生什么？</h3><ol><li>第一次挥手：客户端超时重传因为没有收到应答，达到最大次数后断开连接。</li><li>第二次挥手：客户端超时重传因为没有收到应答，服务端收到一次就会回应一次ACK。</li><li>第三次挥手：服务端超时重传因为没有收到应答，客户端达到最大时间会直接关闭。</li><li>第四次挥手：服务端超时重传因为没有收到应答，客户端收到一次就会回应一次，然后重置2MSL时间。</li></ol><h3 id="为什么等待时间是2MSL"><a href="#为什么等待时间是2MSL" class="headerlink" title="为什么等待时间是2MSL"></a>为什么等待时间是2MSL</h3><ul><li>MSL：报文最大生存时间。</li><li>允许ACK丢失，服务端重传的FIN可以在2MSL内到达。最差情况就是ack快到达时候丢失，这时候损失一个MSL，服务端重传在一个MSL时间到达。</li></ul><h3 id="time-wait作用"><a href="#time-wait作用" class="headerlink" title="time-wait作用"></a>time-wait作用</h3><ul><li>序列号是循环利用的，避免历史数据接受。确保这次通信的数据在2MSL内接受、发送、丢失完毕。</li><li>确保主动关闭的一方可以正确关闭。被关闭一方没收到ack可以重传。</li></ul><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><ol><li><strong>是什么</strong>：TCP采用的是请求-应答的机制，确保数据传输的可靠性。如果请求一次，等待应答再发送下一次就导致效率很低。所以引入了窗口概念，无需等待应答，窗口内的数据都能够发送.</li><li><strong>工作流程</strong>：发送方：收到应答后，滑动窗口就往后移动，后面的数据就可以继续发送。接收方：收到数据并确认后往后移动，可以接受更多的数据发送。</li></ol><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><ul><li>让发送方发送速率不要过快，要让接收方来得及接受。流量控制是端到端的问题，拥塞控制是中间网络带宽的问题。</li></ul><ol><li>接收窗口：接收方在tcp头部告诉发送方自己的接收窗口大小，接收方的发送窗口大小不能超过接收窗口大小。</li><li>零窗口探测：接收窗口是零；接收方发送更改接收窗口大小不为0情况，但丢失。&#x3D;&gt; 持续计时器，收到零窗口通知后开启，到达时间后发送零窗口探测报文。</li></ol><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><ul><li>防止过多数据注入网络，避免路由器或链路过载。</li></ul><ol><li><em><strong>慢开始算法</strong></em>：呈<em><strong>指数增长</strong></em>往网络中注入字节数据，同时有个慢开始门限，避免增长过快。</li><li><em><strong>拥塞避免算法</strong></em>：当拥塞窗口大于慢开始门限后进行拥塞避免算法，线性增长窗口大小.</li><li><em><strong>超时重传</strong></em>：拥塞窗口设置为1，慢开始门限设置为滑动窗口大小的一半，重新开始慢开始算法和拥塞避免算法。</li><li><em><strong>快重传</strong></em>：对已收到的报文立即确认，重复的报文也发送确认，发送方收到三次确认后立即发送。</li><li><em><strong>快恢复</strong></em>：快重传后执行，将慢开始门限调整到滑动窗口大小的一半，再将窗口大小设置和慢开始门限一样，后续进行拥塞避免算法。</li></ol><h1 id="2-20"><a href="#2-20" class="headerlink" title="2.20"></a>2.20</h1><h2 id="算法-6"><a href="#算法-6" class="headerlink" title="算法"></a>算法</h2><h3 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h3><h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h3><h3 id="复习-5"><a href="#复习-5" class="headerlink" title="复习"></a>复习</h3><ul><li>分割回文串（回溯）：把字符串拆分成多个子串，每个子串都是回文串，记录每次拆分后的结果。这个用回溯拆分所有情况去判断。</li><li>加油站：两个变量</li></ul><h2 id="八股-5"><a href="#八股-5" class="headerlink" title="八股"></a>八股</h2><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ol><li>状态码</li><li>头部字段</li><li>get、post区别</li><li>http1.1和1.0区别</li><li>https</li><li>tls握手</li><li>1.1如何优化</li><li>https如何优化</li><li>RSA、ECDHE</li><li>http2.0</li><li>http3.0</li><li>tcp、udp</li><li>三次握手</li><li>握手丢失</li><li>两次握手、四次握手问题</li><li>四次挥手</li><li>挥手丢失</li><li>三次挥手问题</li><li>滑动窗口</li><li>流量控制</li><li>拥塞控制</li></ol><h3 id="解释性语言（py，js）和编译性语言（c）"><a href="#解释性语言（py，js）和编译性语言（c）" class="headerlink" title="解释性语言（py，js）和编译性语言（c）"></a>解释性语言（py，js）和编译性语言（c）</h3><ol><li>解释性是代码逐行解释执行，编译性语言是统一转换为机器码之后执行。</li><li>解释性执行速度慢，编译性执行机器码快。</li><li>解释性跨平台更好（解释器跨平台即可），编译性需要编译成不同的机器码。</li></ol><h3 id="axios比fetch、ajax的好处"><a href="#axios比fetch、ajax的好处" class="headerlink" title="axios比fetch、ajax的好处"></a>axios比fetch、ajax的好处</h3><ol><li>json格式化处理</li><li>兼容性：避免fetch不兼容</li><li>api简洁：基于promise封装，避免xhr的回调</li><li>超时配置、baseURL、拦截器功能</li></ol><h3 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h3><ul><li>进程基本概念</li><li>进程状态</li><li>进程管理</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>线程基本概念</li><li>线程与进程区别</li></ul><h1 id="2-21"><a href="#2-21" class="headerlink" title="2.21"></a>2.21</h1><h2 id="算法-7"><a href="#算法-7" class="headerlink" title="算法"></a>算法</h2><h3 id="用最少的箭引爆气球"><a href="#用最少的箭引爆气球" class="headerlink" title="用最少的箭引爆气球"></a>用最少的箭引爆气球</h3><ul><li>各个区间合并：思路是将当前区间和前一个区间合并，合并完结果保留在当前区间，方便和下一个区间合并。</li></ul><h3 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h3><ul><li>也是各个区间合并：思路是将当前区间和前一个区间对比保留对后面影响更短的，结果保留在当前区间，方便和下一个区间对比。</li></ul><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><ul><li>也是各个区间合并：思路是将当前区间和前一个区间合并，合并完结果保留在当前区间，如果当前区间不能和前一个区间合并则把前一个区间放到结果集中。</li></ul><h3 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h3><ul><li>遍历一遍找到所有字符的最后下标，再遍历一遍找到遍历过的字符最远的下标。</li></ul><h2 id="八股-6"><a href="#八股-6" class="headerlink" title="八股"></a>八股</h2><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ul><li>进程状态改变时候比如：运行态到终止、运行到阻塞、就绪到运行，都会使用到调度算法。CPU更换新的进程来执行。</li></ul><ol><li>先来先服务算法：对短作业不利，要等长作业很久。</li><li>短作业优先算法：对长作业不利，可能一直等。</li><li>最高响应比算法：理想型算法，无法实现。<br>(等待时间 + 要求服务时间)&#x2F; 要求服务时间</li><li>时间片轮转算法：每个进程分配一个时间片，允许进程在该时间片执行。</li><li>最高优先级算法：CPU选择优先级最高的进程执行代码。静态优先级、动态优先级；抢占式、非抢占式。抢占式可能导致优先级低的永远无法执行。</li><li>多级反馈队列算法：多个队列，每个队列优先级从高到低排列，同时优先级越高时间片越短。  先进入最高优先级队列，没执行完进入下一级优先队列。对于短作业来说，很可能在最高优先级队列的时间片就执行完毕；对于长作业来说，进入到后面优先级更低的队列，但是执行时间变长了。<strong>短作业优先级高，执行时间短；长作业优先级低，执行时间长。</strong></li></ol><!-- 如果执行低优先级的长作业时候有短作业进入，则会先去执行短作业。 --><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><ol><li>管道</li><li>消息队列</li><li>共享内存</li><li>信号量</li><li>socket编程</li></ol><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>两个资源对应两把锁，两个线程各持有一把锁，都在等对方释放锁。</li><li>四个条件</li></ul><ol><li>互斥：资源不能被多个线程共享。</li><li>持有并等待：线程拥有该资源后不会主动释放。</li><li>不可剥夺：线程拥有的资源不会被其他线程抢走。</li><li>环形链路：各个线程对资源的请求构造了一个环。</li></ol><ul><li>避免死锁：资源有序分配。</li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ol><li>互斥锁：</li><li>自旋锁：</li><li>读写锁：读锁是为了提供资源利用率</li><li>乐观锁：</li><li>悲观锁：</li></ol><h3 id="浏览器组成-1"><a href="#浏览器组成-1" class="headerlink" title="浏览器组成"></a>浏览器组成</h3><h3 id="浏览器限制最大请求数原因"><a href="#浏览器限制最大请求数原因" class="headerlink" title="浏览器限制最大请求数原因"></a>浏览器限制最大请求数原因</h3><ol><li>防止服务端端口耗尽。</li><li>防止客户端请求并发量过高超出服务端并发控制。</li><li>客户端良性竞争机制</li><li>防止网络带宽压力过大</li></ol><h3 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h3><ol><li>浏览器主进程</li><li>渲染进程</li><li>插件进程</li><li>GPU进程：</li></ol><h1 id="2-22"><a href="#2-22" class="headerlink" title="2.22"></a>2.22</h1><h2 id="算法-8"><a href="#算法-8" class="headerlink" title="算法"></a>算法</h2><h3 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h3><h3 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h3><h3 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h3><h3 id="复习-6"><a href="#复习-6" class="headerlink" title="复习"></a>复习</h3><ul><li>整个贪心过了一遍。</li></ul><h2 id="八股-7"><a href="#八股-7" class="headerlink" title="八股"></a>八股</h2><ul><li>过一遍操作系统。看webpackvite。改好简历。</li></ul><h3 id="如何解决浏览器请求次数限制？"><a href="#如何解决浏览器请求次数限制？" class="headerlink" title="如何解决浏览器请求次数限制？"></a>如何解决浏览器请求次数限制？</h3><ol><li>http2.0，http3.0 解决队头阻塞，并发请求。</li><li>使用缓存，减少请求量。</li><li>合并请求，减少请求次数。</li><li>按需加载。</li><li>域名分散</li></ol><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><h3 id="TLB、段页式分页"><a href="#TLB、段页式分页" class="headerlink" title="TLB、段页式分页"></a>TLB、段页式分页</h3><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ol><li>进程</li><li>线程</li><li>进程和线程区别</li><li>进程调度算法</li><li>进程通信方式</li><li>死锁</li><li>锁的分类</li><li>浏览器进程</li><li>浏览器为什么有请求次数限制</li><li>如何解决浏览器请求限制</li><li>虚拟内存</li><li>内存分段</li><li>TLB、段页式存储</li></ol><h3 id="cache-control字段"><a href="#cache-control字段" class="headerlink" title="cache-control字段"></a>cache-control字段</h3><ol><li>max-age：缓存多少s。如果为0，既不协商缓存也不强制缓存。</li><li>no-cache：使用协商缓存，强制缓存不适用。</li><li>no-store：既不使用强制缓存也不使用协商缓存。</li></ol><h3 id="缓存在内存还是磁盘中"><a href="#缓存在内存还是磁盘中" class="headerlink" title="缓存在内存还是磁盘中"></a>缓存在内存还是磁盘中</h3><ul><li>内存有时间限制，小，速度快；磁盘时间限制更宽，大，速度慢。</li><li>如果是关闭标签页，再打开：都是从磁盘中拿出来。</li><li>如果是刷新：js等其他资源通常在内存中，css文件较大，更新频率低通常存在磁盘中。</li></ul><h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><h3 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h3><h3 id="如何编写loader"><a href="#如何编写loader" class="headerlink" title="如何编写loader"></a>如何编写loader</h3><h3 id="如何编写plugin"><a href="#如何编写plugin" class="headerlink" title="如何编写plugin"></a>如何编写plugin</h3><ul><li>对象，apply属性，传入compiler。</li><li>complier对象有很多生命周期钩子，</li><li>complication对象，每次编译相关的信息，可以生成文件、遍历模块操作。</li></ul><h1 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h1><h2 id="算法-9"><a href="#算法-9" class="headerlink" title="算法"></a>算法</h2><h3 id="复习-7"><a href="#复习-7" class="headerlink" title="复习"></a>复习</h3><ol><li>组合：终止条件是path.length &#x3D;&#x3D; k</li><li>组合总和：终止条件有两个，等于时候收集结果，大于时候不要再遍历了。</li><li>组合总和II：used数组去重，前面值和当前值相等时候，前面用过，那我也可以用。前面没用，那我也不要再用了，因为前面的值把所有情况都填写一遍了。</li><li>组合总和III：没什么特别的,注意细节。</li><li>总结回溯：回溯终止条件；for循环遍历，递归；放入，弹出。</li></ol><h2 id="八股-8"><a href="#八股-8" class="headerlink" title="八股"></a>八股</h2><h3 id="webpack构建流程"><a href="#webpack构建流程" class="headerlink" title="webpack构建流程"></a>webpack构建流程</h3><ul><li>shell语句和配置文件初始化参数，用参数初始化compiler对象，这个对象相当于整个编译过程的总指挥，上面有很多生命周期钩子，同时也初始化加载plugin插件，然后开始编译。</li><li>从入口文件entry开始，循环递归解析模块之间的依赖关系，解析入口文件，然后解析入口文件依赖的模块文件。有需要也会借助loader进行解析。</li><li>生成一个或多个chunk，每个chunk对应生成一个文件。</li><li>在整个构建流程中，webpack会暴露事件钩子，plugin会监听这些事件然后执行改变输出结果。</li></ul><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="改好简历了，并开始投递。"><a href="#改好简历了，并开始投递。" class="headerlink" title="改好简历了，并开始投递。"></a>改好简历了，并开始投递。</h3><h1 id="2-24"><a href="#2-24" class="headerlink" title="2.24"></a>2.24</h1><h2 id="算法-10"><a href="#算法-10" class="headerlink" title="算法"></a>算法</h2><h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h3><h3 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h3><h3 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h3><ul><li>两天搞完回溯，进入链表</li></ul><h2 id="八股-9"><a href="#八股-9" class="headerlink" title="八股"></a>八股</h2><h3 id="如何提高webpack构建速度"><a href="#如何提高webpack构建速度" class="headerlink" title="如何提高webpack构建速度"></a>如何提高webpack构建速度</h3><ol><li>cache-loader：性能大的loader运算的结果进行缓存，当再次遇到该loader处理的文件时候会先给cache-loader处理，运算hash值，如果有缓存直接复用；没有的话记录该hash值和loader运算后的结果。</li><li>thread-loader：有的loader比如babel-loader支持并行处理，利用多核cpu多线程处理。</li><li>excludes、includes：指定loader的作用域范围，比如node-modules就不需要loader处理。</li><li>dllplugin：常见的第三方库比如vue、react等等这些不会经常变换的，可以提前打包，后面webpack构建遇到这些模块动态引入即可。</li><li>模块拆分：多个入口文件，或者是import引入组件时候申明webpackChunkName，单独打包成一个chunk，避免请求时候请求一个过大的包，请求一个小包比如路由组件时候可以提高加载速度。</li><li>externals优化：将一些库通过script标签引入，不放在打包结果中。</li></ol><h3 id="如何减少webpack打包体积"><a href="#如何减少webpack打包体积" class="headerlink" title="如何减少webpack打包体积"></a>如何减少webpack打包体积</h3><ol><li>tree-shaking，删除未使用的模块依赖。</li><li>开发环境使用的依赖下载到开发环境，不要下载到生产环境。</li><li>使用组件库时候局部引入，不要全局引入打包；也可以下载插件自动按需引入。</li><li>图片压缩：image-webpack-loader</li><li>js压缩：terser-plugin，对注释、空格、未使用的代码、变量整合等等压缩。</li><li>css压缩：css-minier-webpack-plugin，压缩css</li></ol><h3 id="webpack热模块更新原理"><a href="#webpack热模块更新原理" class="headerlink" title="webpack热模块更新原理"></a>webpack热模块更新原理</h3><h1 id="2-25"><a href="#2-25" class="headerlink" title="2.25"></a>2.25</h1><h2 id="算法-11"><a href="#算法-11" class="headerlink" title="算法"></a>算法</h2><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><h3 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h3><h3 id="非递减子序列"><a href="#非递减子序列" class="headerlink" title="非递减子序列"></a>非递减子序列</h3><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><h2 id="八股-10"><a href="#八股-10" class="headerlink" title="八股"></a>八股</h2><h3 id="vite和webpack区别"><a href="#vite和webpack区别" class="headerlink" title="vite和webpack区别"></a>vite和webpack区别</h3><ol><li>快速冷启动</li><li>构建方式</li><li>http2.0</li><li>模块热更新</li></ol><h3 id="vite的构建原理"><a href="#vite的构建原理" class="headerlink" title="vite的构建原理"></a>vite的构建原理</h3><ul><li>直接启动开发服务器，不会对整个项目进行模块依赖分析。利用浏览器对esm的支持，就是浏览器现在支持运行一些模块化语句比如import，遇到import语句再去发送http请求加载对应的模块，然后vite开发服务器再对模块进行编译。比如vue文件解析为浏览器可以识别的html、css、js文件。</li></ul><h3 id="vite开发使用esbuild、打包使用rollup。"><a href="#vite开发使用esbuild、打包使用rollup。" class="headerlink" title="vite开发使用esbuild、打包使用rollup。"></a>vite开发使用esbuild、打包使用rollup。</h3><h3 id="wepack、vite总结"><a href="#wepack、vite总结" class="headerlink" title="wepack、vite总结"></a>wepack、vite总结</h3><ol><li>loader</li><li>plugin</li><li>如何编写loader、plugin</li><li>webpack构建流程</li><li>如何加快webpack构建速度</li><li>如何减少webpack打包体积</li><li>webpack热模块更新</li><li>webpack和vite的区别</li><li>vite的构建原理</li><li>vite开始使用esbuild，打包使用rollup原因</li></ol><h3 id="pushstate、popstate、replacestate"><a href="#pushstate、popstate、replacestate" class="headerlink" title="pushstate、popstate、replacestate"></a>pushstate、popstate、replacestate</h3><ul><li>只有postate是事件，其他两个只是方法不能被监听。</li></ul><ol><li>pushstate：向浏览器历史记录栈添加新的条目，<strong>当前地址栏变成指定url</strong>，但不会刷新页面加载资源， 需要手动更新 &#x3D;》前端js实现路由切换</li><li>replacestate：浏览器<strong>地址栏更新为指定 URL</strong>，但不加载页面，仅替换当前历史记录。</li><li>popstate：<strong>只有</strong>浏览器的前进和后退会触发popstate（replace改变记录不会触发）</li></ol><h3 id="single-spa源码"><a href="#single-spa源码" class="headerlink" title="single-spa源码"></a>single-spa源码</h3><h3 id="微前端解决的问题"><a href="#微前端解决的问题" class="headerlink" title="微前端解决的问题"></a>微前端解决的问题</h3><ol><li>可维护性</li><li>团队独立性</li><li>技术灵活性</li><li>增量升级</li></ol><h3 id="带来的新问题"><a href="#带来的新问题" class="headerlink" title="带来的新问题"></a>带来的新问题</h3><ol><li>项目拆分困难，要根据业务逻辑拆分，确保后续开发的可执行性。</li><li>学习成本，要改变子应用的入口文件接入微前端。</li></ol><h2 id="qiankun相比single-spa多了什么"><a href="#qiankun相比single-spa多了什么" class="headerlink" title="qiankun相比single-spa多了什么"></a>qiankun相比single-spa多了什么</h2><ul><li>预加载、js沙箱、css样式隔离、应用间通信（qiankun后续会删除）、生命周期增强（比如beforeMount，提供更多控制点）</li></ul><h1 id="2-26"><a href="#2-26" class="headerlink" title="2.26"></a>2.26</h1><ul><li>简历投3-5家。美团、京东给它投了。</li></ul><h2 id="算法-12"><a href="#算法-12" class="headerlink" title="算法"></a>算法</h2><h3 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h3><h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><!-- 回溯问题都是自己直接写出来了！ --><h2 id="八股-11"><a href="#八股-11" class="headerlink" title="八股"></a>八股</h2><h3 id="复习webpack、vite。"><a href="#复习webpack、vite。" class="headerlink" title="复习webpack、vite。"></a>复习webpack、vite。</h3><h3 id="减少回流和重绘操作-1"><a href="#减少回流和重绘操作-1" class="headerlink" title="减少回流和重绘操作"></a>减少回流和重绘操作</h3><ol><li>操作低层次的DOM.</li><li>脱离文档流,减少对其他元素影响.</li><li>将DOM读写操作分别放到一起,浏览器的渲染队列机制.</li><li>一些css属性形成新的合成层: transform,opacity等等.浏览器把这些变化交给GPU处理(不是所有合成层都给GPU,只有动画视觉效果时候交给GPU),GPU直接在显存中更改元素显示位置,无需CPU进行布局绘制的计算.</li><li>不要使用table布局，一个小的改动可能导致整个table重新布局。</li><li><strong>documentFragment</strong>：避免频繁操作DOM，可以创建一个文档片段documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中</li></ol><h3 id="requestAnimationframe-10024"><a href="#requestAnimationframe-10024" class="headerlink" title="requestAnimationframe &#10024;"></a>requestAnimationframe &#10024;</h3><ol><li>接受一个回调函数，该函数会在下次回流前调用</li><li>回流是根据浏览器刷新频率触发，60hz就是一秒刷新60次，一秒60次回流，也就调用该函数六十次。</li><li>优点：<br>动画更流畅，不会掉帧、卡顿。<br>cpu节能，页面隐藏时候setTimeout会继续执行，requestAnimation会暂停动画。</li></ol><h3 id="DocumentFragments-10024-1"><a href="#DocumentFragments-10024-1" class="headerlink" title="DocumentFragments &#10024;"></a>DocumentFragments &#10024;</h3><ul><li>轻量级、批量操作DOM元素，临时存储的容器。</li><li>DocumentFragments存在于内存中，不是主 DOM 树的一部分，将子元素插入到文档片段时不会引起页面回流。通常的用例是创建文档片段，元素附加到文档片段，然后将文档片段附加到 DOM 树。</li></ul><h2 id="浏览器一帧做什么？"><a href="#浏览器一帧做什么？" class="headerlink" title="浏览器一帧做什么？"></a>浏览器一帧做什么？</h2><ol><li>处理用户交互</li><li>requestAnimationFrame</li><li>回流重绘</li><li>还有空闲时间：requestIdCallback</li></ol><h2 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h2><ul><li>requestIdleCallback 是捡浏览器空闲来执行任务。假如浏览器一直处于非常忙碌的状态，requestIdleCallback 注册的任务有可能永远不会执行</li></ul><h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><ol><li>加载当前匹配的应用，加载完之后会派发一个事件。</li><li>预加载函数里会监听这个事件，如果触发了就会加载其他应用。</li><li>通过requestIdCallback，在浏览器渲染一帧有空闲时间时候加载。</li></ol><h2 id="import-html-entry"><a href="#import-html-entry" class="headerlink" title="import-html-entry"></a>import-html-entry</h2><ul><li>去加载入口文件。</li></ul><ol><li>fetch拉取html，注释掉所有外联js、页面内js、外联css。保留起来。</li><li>fetch拉取外联的css，通过style标签引入到html模板中。</li><li>fetch拉取外联js、和页面内js直接返回，包裹在一个函数里面。通过沙箱机制隔离。</li><li>返回html模板和包装js的函数。</li><li>qiankun把html模板放到容器中，挂载完毕后执行包装js的函数。</li></ol><h2 id="子应用如何接入微前端？-10024"><a href="#子应用如何接入微前端？-10024" class="headerlink" title="子应用如何接入微前端？&#10024;"></a>子应用如何接入微前端？&#10024;</h2><ul><li>重中之重，面试官上来问亮点要介绍的内容。</li></ul><ol><li>父应用里面注册子应用相关信息。包括name、挂载的容器、激活子应用的路径（qiankun会去监听popstate、hashchange事件去加载对应的子应用）、加载子应用的路径。</li><li>子应用对外暴露接口协议：import-html-entry加载、js沙箱、<br>css样式隔离。</li><li>pubilc-path</li><li>container容器</li><li>webpack打包为umd格式</li><li>全局变量</li></ol><h2 id="start时候，qiankun干了什么事情？"><a href="#start时候，qiankun干了什么事情？" class="headerlink" title="start时候，qiankun干了什么事情？"></a>start时候，qiankun干了什么事情？</h2><ul><li>single-spa的源码</li></ul><h2 id="父子应用通信"><a href="#父子应用通信" class="headerlink" title="父子应用通信"></a>父子应用通信</h2><!-- ## 微前端 --><h1 id="2-27"><a href="#2-27" class="headerlink" title="2.27"></a>2.27</h1><h2 id="算法-13"><a href="#算法-13" class="headerlink" title="算法"></a>算法</h2><h3 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h3><h3 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h3><h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><h3 id="删除链表倒数第N个元素"><a href="#删除链表倒数第N个元素" class="headerlink" title="删除链表倒数第N个元素"></a>删除链表倒数第N个元素</h3><h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><h2 id="八股-12"><a href="#八股-12" class="headerlink" title="八股"></a>八股</h2><h3 id="js沙箱机制"><a href="#js沙箱机制" class="headerlink" title="js沙箱机制"></a>js沙箱机制</h3><h3 id="css样式隔离"><a href="#css样式隔离" class="headerlink" title="css样式隔离"></a>css样式隔离</h3><ul><li>最常用的还是BEM规范</li></ul><h3 id="BEM-CSS命名规范"><a href="#BEM-CSS命名规范" class="headerlink" title="BEM:CSS命名规范"></a>BEM:CSS命名规范</h3><ul><li>B块：代表一个功能模块，E模块的一个元素，M修饰符。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button button--primary&quot;</span>&gt;</span>Primary Button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button button--secondary&quot;</span>&gt;</span>Secondary Button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="父子路由"><a href="#父子路由" class="headerlink" title="父子路由"></a>父子路由</h3><ul><li>监听路由变化、方法重写 &#x3D;》父应用路由 &#x3D;》子应用挂载到容器，负责自己路由</li></ul><h3 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h3><ol><li>微前端解决了什么问题</li><li>微前端的缺点</li><li>qiankun和iframe区别</li><li>子应用如何接入qiankun框架？ &#10024;</li><li>start时候qiankun干了什么？</li><li>父子应用通信</li><li>js沙箱机制 &#10024;</li><li>css样式隔离</li><li>父子应用路由</li><li>qiankun和single-spa区别</li><li>预加载</li><li>import-html-entry</li></ol><h3 id="抽离公共组件"><a href="#抽离公共组件" class="headerlink" title="抽离公共组件"></a>抽离公共组件</h3><ul><li>git submodule</li></ul><h3 id="封装成员选择器"><a href="#封装成员选择器" class="headerlink" title="封装成员选择器"></a>封装成员选择器</h3><ol><li>定义props参数：搜索节流时间、要不要中文名、要不要英文名v-model绑定的值、是否可以多选等等。</li><li>组件里面：组件挂载时候请求member成员数据，成员数据根据传入的参数过滤，v-model绑定选择的值。</li></ol><h1 id="2-28"><a href="#2-28" class="headerlink" title="2.28"></a>2.28</h1><h2 id="算法-14"><a href="#算法-14" class="headerlink" title="算法"></a>算法</h2><h3 id="环形链表I、II"><a href="#环形链表I、II" class="headerlink" title="环形链表I、II"></a>环形链表I、II</h3><h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h3><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><ul><li>上午写了开会用的资料</li></ul><h2 id="八股-13"><a href="#八股-13" class="headerlink" title="八股"></a>八股</h2><h3 id="睡前知识点"><a href="#睡前知识点" class="headerlink" title="睡前知识点"></a>睡前知识点</h3><ol><li>url是Google.com，国内dns域名服务器无法找到对应的ip地址</li><li>promise.retry的实现，到达最大次数前都可以继续执行异步任务</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">retry</span>(<span class="hljs-params">promiseFn, retries, delay</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">attempt</span> = (<span class="hljs-params">remainingRetries</span>) =&gt; &#123;<br>      <span class="hljs-title function_">promiseFn</span>()<br>        .<span class="hljs-title function_">then</span>(resolve)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (remainingRetries === <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-title function_">reject</span>(error);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">attempt</span>(remainingRetries - <span class="hljs-number">1</span>), delay);<br>          &#125;<br>        &#125;);<br>    &#125;;<br><br>    <span class="hljs-title function_">attempt</span>(retries);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="微前端-1"><a href="#微前端-1" class="headerlink" title="微前端"></a>微前端</h3><ul><li>非常牢固</li></ul><h1 id="2-29"><a href="#2-29" class="headerlink" title="2.29"></a>2.29</h1><h2 id="算法-15"><a href="#算法-15" class="headerlink" title="算法"></a>算法</h2><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><h3 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a>旋转链表</h3><h3 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h3><h3 id="上午投了网易、科大讯飞"><a href="#上午投了网易、科大讯飞" class="headerlink" title="上午投了网易、科大讯飞"></a>上午投了网易、科大讯飞</h3><h2 id="八股-14"><a href="#八股-14" class="headerlink" title="八股"></a>八股</h2><h3 id="睡前知识点-1"><a href="#睡前知识点-1" class="headerlink" title="睡前知识点"></a>睡前知识点</h3><ol><li>给定一个used数组[[1，20]，[23，40]…] ,一个checknum数组[-20，80],输出不被used所包含的元素<br>写了n*n复杂度的，让优化到n，说思路。遍历第一个数组，把里面值全部存到set里面。</li><li>promise.all：返回promise，数组记录正确结果，放到对应位置。count记录成功个数。catch直接返回</li></ol><h3 id="auth登录"><a href="#auth登录" class="headerlink" title="auth登录"></a>auth登录</h3><h3 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h3><h3 id="双token、续期token解决无感刷新"><a href="#双token、续期token解决无感刷新" class="headerlink" title="双token、续期token解决无感刷新"></a>双token、续期token解决无感刷新</h3><h3 id="前端直传文件"><a href="#前端直传文件" class="headerlink" title="前端直传文件"></a>前端直传文件</h3><h3 id="后端存储的是密码吗？"><a href="#后端存储的是密码吗？" class="headerlink" title="后端存储的是密码吗？"></a>后端存储的是密码吗？</h3><ul><li>不是的。后端只有请求过来时候看得到密码。实际存储在数据库里的是加盐然后用加密算法加密后的暗文。所以找回密码是找不到之前的密码的。</li></ul><h3 id="token解析不就会暴露信息吗？"><a href="#token解析不就会暴露信息吗？" class="headerlink" title="token解析不就会暴露信息吗？"></a>token解析不就会暴露信息吗？</h3><ul><li>token组成是三个部分，第三个部分是对前两个部分的加密，前两个可以解析，第三个不能解析。</li></ul><h1 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h1><h2 id="算法-16"><a href="#算法-16" class="headerlink" title="算法"></a>算法</h2><h3 id="k个一组翻转链表"><a href="#k个一组翻转链表" class="headerlink" title="k个一组翻转链表"></a>k个一组翻转链表</h3><ul><li>自己写出来了！hard</li></ul><h3 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a>随机链表的复制</h3><h3 id="双指针-删除有序数组重复项II"><a href="#双指针-删除有序数组重复项II" class="headerlink" title="(双指针)删除有序数组重复项II"></a>(双指针)删除有序数组重复项II</h3><h2 id="八股-15"><a href="#八股-15" class="headerlink" title="八股"></a>八股</h2><ul><li>按钮级别权限控制、webworker</li><li>响应式布局、虚拟列表、树形数据</li></ul><h3 id="vite的构建流程"><a href="#vite的构建流程" class="headerlink" title="vite的构建流程"></a>vite的构建流程</h3><ul><li>vite直接启动开发服务器，不会对整个项目进行编译打包。</li><li>会进行预处理把文件都转换为esm模块，利用浏览器对esm模块化的支持。浏览器现在支持运行一些模块语法比如import语句。遇到import语句再向开发服务器请求对应的模块，vite再对模块进行编译。比如vue文件转换为浏览器可识别的文件。</li></ul><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><p>Promise.any() 静态方法将一个 Promise 可迭代对象作为输入，并返回一个 Promise。当输入的任何一个 Promise 兑现时，这个返回的 Promise 将会兑现，并返回第一个兑现的值。当所有输入 Promise 都被拒绝（包括传递了空的可迭代对象）时，它会以一个包含拒绝原因数组的 AggregateError 拒绝。</p><h3 id="Promise-allSettled-iterable"><a href="#Promise-allSettled-iterable" class="headerlink" title="Promise.allSettled(iterable)"></a>Promise.allSettled(iterable)</h3><ul><li>Promise.allSettled:当所有的promise状态都落定后才会返回结果，如果希望有拒绝promise立即返回拒绝promise的话就用promise.all.</li></ul><h3 id="实现自定义角色权限，支持路由级别和按钮级别的权限控制，并结合单点登录（SSO）统一认证，满足不同管理角色的需求"><a href="#实现自定义角色权限，支持路由级别和按钮级别的权限控制，并结合单点登录（SSO）统一认证，满足不同管理角色的需求" class="headerlink" title="实现自定义角色权限，支持路由级别和按钮级别的权限控制，并结合单点登录（SSO）统一认证，满足不同管理角色的需求"></a>实现自定义角色权限，支持路由级别和按钮级别的权限控制，并结合单点登录（SSO）统一认证，满足不同管理角色的需求</h3><ul><li>为什么要按钮级别和路由级别的权限控制？ 处置配置人员和定性配置人员是两类人员，操作不同的页面；有时又需要查看权限。</li></ul><ol><li>在子模块仓库封装了一个获取当前页面的权限节点函数。首先有一个配置中心，配置中心里有权限节点和权限id的映射。比如：新增策略对应id1，删除策略对应id2.请求配置中心获取对应的映射、还有一些白名单等信息。然后有一个权限中心，用户可以在权限中心申请对应的权限id，请求权限中心获取当前用户的权限id。这些请求会在主应用的入口文件main.ts获取，放到全局状态上，可以共享给子应用。获取到权限id和映射后获取用户对应的权限节点。然后在页面按钮通过v-if判断是否有当前按钮的权限。</li><li>还封装了一个路由注入信息的函数。每个路由会配置对应的权限节点，然后也是根据用户权限id到权限节点映射查看是否有对应的权限，有的话会在路由元信息注入hasauth字段，有这个字段才可以跳转页面。当然如果是白名单的话也会注入对应的信息。</li></ol><h3 id="webwoker"><a href="#webwoker" class="headerlink" title="webwoker"></a>webwoker</h3><ul><li>js是单线程，避免共同操作DOM导致渲染错误。worker可以单独开一个线程执行一些复杂的操作，不影响主线程的UI渲染和用户交互。</li></ul><ol><li>主线程创建worker线程，postmessage传递表头数据和表格每一行数据给worker线程。</li><li>worker线程监听message事件收到数据后对数据进行拼接，组成csv文件。用逗号隔开每一个数据，每一行换行隔开数据。拼接完成后postmessage传递字符串给主线程。</li><li>主线程onmessage接受数据后，创建a标签，模拟点击a标签完成下载操作。</li></ol><h3 id="sharedWorker"><a href="#sharedWorker" class="headerlink" title="sharedWorker"></a>sharedWorker</h3><ul><li>同源页面共同访问同一个线程。每个页面有个port对象接入到sharedworker线程，sharedworker线程有连接池（也就是一个数组）统一管理所有的port对象。</li></ul><ol><li>聊天状态同步，sharedworker把消息推送到各个页面中；退出登录，各个页面同步退出状态。</li></ol><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><ul><li><a href="https://blog.csdn.net/leman314/article/details/111936863">https://blog.csdn.net/leman314/article/details/111936863</a></li></ul><ol><li>布局视口：文档对象的逻辑尺寸，pc端和浏览器窗口大小差不多。移动端远大于手机尺寸。</li><li>理想视口：是布局视口的理想尺寸，和设备宽度相同。</li><li>视觉视口：用户在网页看到的区域。理想视口尺寸&#x2F;缩放比例。</li></ol><h1 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h1><h2 id="算法-17"><a href="#算法-17" class="headerlink" title="算法"></a>算法</h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h3><ul><li>手写出来了，20分钟左右。</li></ul><h2 id="八股-16"><a href="#八股-16" class="headerlink" title="八股"></a>八股</h2><ul><li>下午就把项目复习完。</li><li>开始vue和ts，下周搞完。</li></ul><h3 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h3><h3 id="渲染过程的两个生命周期钩子"><a href="#渲染过程的两个生命周期钩子" class="headerlink" title="渲染过程的两个生命周期钩子:"></a>渲染过程的两个生命周期钩子:</h3><p>domcontentloaded：html加载完后执行，<br>loaded：所有资源加载解析完后执行</p><h3 id="防抖、节流"><a href="#防抖、节流" class="headerlink" title="防抖、节流"></a>防抖、节流</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn,delay</span>)&#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)&#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">if</span>(timer)&#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      timer = <span class="hljs-literal">null</span>;<br>    &#125;<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>      fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;,delay);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn,delay</span>)&#123;<br>  <span class="hljs-keyword">let</span> preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)&#123;<br>    <span class="hljs-keyword">let</span> curTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">if</span>(curTime - preTime &gt;= delay)&#123;<br>      fn.<span class="hljs-title function_">apply</span>(context, args);<br>      preTime = curTime;<br>    &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输入url后会发生什么"><a href="#输入url后会发生什么" class="headerlink" title="输入url后会发生什么?"></a>输入url后会发生什么?</h3><ol><li><em><strong>解析URL</strong></em>:生成对应的HTTP请求</li><li><em><strong>缓存</strong></em>:浏览器本地是否有缓存</li><li><em><strong>DNS解析</strong></em>:查询域名对应的ip地址,先从本地域名服务器查看是否有缓存,无缓存本地域名服务器向根域名服务器请求,根域名服务器给出顶级域名服务器(.com)的ip,本地域名服务器向顶级域名服务器请求,顶级域名服务器给出权威域名服务器ip,本地域名服务器向权威域名服务器请求,获取对应的ip.</li><li><em><strong>TCP三次握手</strong></em></li><li><em><strong>TLS四次握手(HTTPS)</strong></em></li><li><em><strong>路由器转发</strong></em>：ip头部：包括ip地址。</li><li><em><strong>交换机转发</strong></em>：mac头部</li><li><em><strong>数据返回到浏览器,浏览器渲染过程</strong></em></li></ol><h3 id="meta元标签"><a href="#meta元标签" class="headerlink" title="meta元标签"></a>meta元标签</h3><ul><li>元数据，提供网页相关的内容。</li></ul><ol><li>charset：当前文档解析的编码格式。</li><li>content：页面描述</li><li>csp（内容策略）：内容策略常用来指定允许的服务器源和脚本端点。</li></ol><h3 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h3><ol><li>meta信息配置：width &#x3D; device-width；</li><li>@media sreen and min-width &#x3D; xxx and max-width &#x3D; xxx。</li><li>单位使用rem、em、%响应式单位。</li><li>flex布局。</li><li>组件库 vant。</li><li>设计稿。</li></ol><h3 id="如何计算font-size"><a href="#如何计算font-size" class="headerlink" title="如何计算font-size"></a>如何计算font-size</h3><ul><li>方法一是不用媒体查询！</li></ul><ol><li>基于屏幕宽度的动态计算：100vw &#x2F; 7.5。<br>在 750px 宽度的设备上，100vw &#x3D; 750px，因此 1rem &#x3D; 100px。<br>在 375px 宽度的设备上，100vw &#x3D; 375px，因此 1rem &#x3D; 50px。</li><li>媒体查询，不同屏幕不同font-size直接写大小就好了。</li></ol><h3 id="树形数据"><a href="#树形数据" class="headerlink" title="树形数据"></a>树形数据</h3><ul><li>ap出现在各个地方，数据层次不一样。比如教学区有一教、二教，宿舍区有一区二栋、一区三栋、二区，办公区有行政、教学。所以在数据表中是统一放到一张表里面。每行数据对应一个id，和一个parentid标明自己属于哪一分类下。</li><li>根据id建立数据的映射表。再遍历一遍数据，根据映射表、parentId找到自己的父类并把自己添加到父数据下。如果没有parentId就是根数据。这样就构建出树形结构。</li><li>叶子节点是没有孩子属性的，只有用户点击到级联最里层才会去请求对应的ap数据。</li></ul><h3 id="虚拟列表"><a href="#虚拟列表" class="headerlink" title="虚拟列表"></a>虚拟列表</h3><ul><li>项目</li><li>防抖</li><li>占位元素</li><li>缓存区优化</li><li>不定高</li></ul><h1 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h1><h2 id="算法-18"><a href="#算法-18" class="headerlink" title="算法"></a>算法</h2><h3 id="二叉树最长交错路径"><a href="#二叉树最长交错路径" class="headerlink" title="二叉树最长交错路径"></a>二叉树最长交错路径</h3><h2 id="八股-17"><a href="#八股-17" class="headerlink" title="八股"></a>八股</h2><h3 id="最大子数组和-1"><a href="#最大子数组和-1" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><ul><li>动态规划，单独起或者加上前面的元素。</li></ul><h3 id="文本加粗和下划线"><a href="#文本加粗和下划线" class="headerlink" title="文本加粗和下划线"></a>文本加粗和下划线</h3><ol><li>font-weight：blod</li><li>text-decoration：underline</li></ol><h3 id="如何实现选中文本"><a href="#如何实现选中文本" class="headerlink" title="如何实现选中文本"></a>如何实现选中文本</h3><ul><li>range，selection API实现。</li></ul><h3 id="小米测评"><a href="#小米测评" class="headerlink" title="小米测评"></a>小米测评</h3><h3 id="复习项目"><a href="#复习项目" class="headerlink" title="复习项目"></a>复习项目</h3><h3 id="进程是什么？"><a href="#进程是什么？" class="headerlink" title="进程是什么？"></a>进程是什么？</h3><ul><li>资源分配基本单位，运行中的程序，三部分组成。磁盘读写进程阻塞&#x3D;》进程管理和进程状态。</li></ul><h3 id="线程是什么？"><a href="#线程是什么？" class="headerlink" title="线程是什么？"></a>线程是什么？</h3><ul><li>CPU调度的基本单位，进程下的一个执行流程，可以共享并发的执行。</li></ul><h3 id="进程和线程区别？"><a href="#进程和线程区别？" class="headerlink" title="进程和线程区别？"></a>进程和线程区别？</h3><ol><li>一个进程包含一或多个线程</li><li>资源分配基本单位，cpu调度基本单位。</li><li>进程有独立的程序段、数据段，切换成本高；线程是轻量级线程，共享进程的数据和程序，并有自己独立的程序计数器和执行栈，创建速度快，销毁速度快，适合并发执行，切换成本低。</li></ol><h3 id="模板编译原理，AST语法树的生成"><a href="#模板编译原理，AST语法树的生成" class="headerlink" title="模板编译原理，AST语法树的生成"></a>模板编译原理，AST语法树的生成</h3><ol><li>获取模板字符串后从头到尾解析，获取开始标签包括其属性、标签名，结束标签，文本标签，直到字符串裁剪为空。</li><li>裁剪过程中，根据开始标签、结束标签、文本标签创建AST节点对象，注意根标签和父子标签的关系。通过全局变量和栈结构判断。如果全局变量为空，当前标签就是根节点，开始标签进栈，结束标签出栈，栈尾就是当前创建节点的父标签。</li><li>最后生成AST语法树，同时还会有一些优化，比如静态节点的标记，后续diff算法可以跳过对应部分。</li></ol><h3 id="纯文本内容修改vue能检测到变化吗？"><a href="#纯文本内容修改vue能检测到变化吗？" class="headerlink" title="纯文本内容修改vue能检测到变化吗？"></a>纯文本内容修改vue能检测到变化吗？</h3><h3 id="AST语法树代码拼接成字符串转换为渲染函数"><a href="#AST语法树代码拼接成字符串转换为渲染函数" class="headerlink" title="AST语法树代码拼接成字符串转换为渲染函数"></a>AST语法树代码拼接成字符串转换为渲染函数</h3><h3 id="ast语法树和虚拟DOM区别？"><a href="#ast语法树和虚拟DOM区别？" class="headerlink" title="ast语法树和虚拟DOM区别？"></a>ast语法树和虚拟DOM区别？</h3><h1 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h1><h2 id="算法-19"><a href="#算法-19" class="headerlink" title="算法"></a>算法</h2><h3 id="二叉树的最大路径和"><a href="#二叉树的最大路径和" class="headerlink" title="二叉树的最大路径和"></a>二叉树的最大路径和</h3><h3 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h3><h3 id="统计二叉树好节点个数"><a href="#统计二叉树好节点个数" class="headerlink" title="统计二叉树好节点个数"></a>统计二叉树好节点个数</h3><h3 id="三个数的最大乘积"><a href="#三个数的最大乘积" class="headerlink" title="三个数的最大乘积"></a>三个数的最大乘积</h3><ul><li>O（n）复杂度，就是五个值记录。</li></ul><h2 id="八股-18"><a href="#八股-18" class="headerlink" title="八股"></a>八股</h2><h3 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a>任务调度器</h3><h3 id="loadash-get"><a href="#loadash-get" class="headerlink" title="loadash.get"></a>loadash.get</h3><h3 id="浏览器为什么限制请求次数"><a href="#浏览器为什么限制请求次数" class="headerlink" title="浏览器为什么限制请求次数"></a>浏览器为什么限制请求次数</h3><h3 id="如何解决限制"><a href="#如何解决限制" class="headerlink" title="如何解决限制"></a>如何解决限制</h3><h3 id="webpack热模块更新"><a href="#webpack热模块更新" class="headerlink" title="webpack热模块更新"></a>webpack热模块更新</h3><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><h3 id="npm-run-build后发生什么？"><a href="#npm-run-build后发生什么？" class="headerlink" title="npm run build后发生什么？"></a>npm run build后发生什么？</h3><ol><li>去package.json文件找到scripts字段，解析build命令。</li><li>vue编译器将vue文件转换为浏览器可以识别的js、html、css。</li><li>webpack执行打包流程，vue文件会用vue-loader处理里面编译的js、html、css。</li><li>代码压缩，terserplugin、css压缩、treeshaking。</li><li>生成输出文件到dist目录下。</li></ol><h3 id="vue2-diff算法"><a href="#vue2-diff算法" class="headerlink" title="vue2 diff算法"></a>vue2 diff算法</h3><h3 id="vue3-diff算法"><a href="#vue3-diff算法" class="headerlink" title="vue3 diff算法"></a>vue3 diff算法</h3><h3 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h3><h3 id="数组响应式原理"><a href="#数组响应式原理" class="headerlink" title="数组响应式原理"></a>数组响应式原理</h3><h3 id="vue3响应式原理"><a href="#vue3响应式原理" class="headerlink" title="vue3响应式原理"></a>vue3响应式原理</h3><ul><li>讲define和proxy区别；set、map响应式。</li></ul><h3 id="Object-defineProperty、proxy区别"><a href="#Object-defineProperty、proxy区别" class="headerlink" title="Object.defineProperty、proxy区别"></a>Object.defineProperty、proxy区别</h3><ol><li>功能范围：defineProperty只能代理属性，get、set，不能监听删除新增； proxy代理整个对象，增删改查都可以监听。</li><li>性能：define需要遍历属性设置getter、setter；proxy只有访问对象时候才触发监听。</li><li>vue中：vue2是define，不能监听数组的变化和新增的属性（通过补丁函数vue.set、修改数组方法）；vue3是采用proxy支持数组变化和新增属性的监听。</li></ol><h3 id="响应式为什么要用-reflect-这种-API"><a href="#响应式为什么要用-reflect-这种-API" class="headerlink" title="响应式为什么要用 reflect 这种 API"></a>响应式为什么要用 reflect 这种 API</h3><ul><li>提供一种更一致和可靠的方式来执行底层的 JavaScript 操作（比如属性访问、赋值、删除等）,代码更简洁易读，13种proxy的捕获器和reflect静态方法一一对应。</li><li>this指向问题。</li></ul><h1 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h1><h2 id="算法-20"><a href="#算法-20" class="headerlink" title="算法"></a>算法</h2><h3 id="最大层内元素和"><a href="#最大层内元素和" class="headerlink" title="最大层内元素和"></a>最大层内元素和</h3><ul><li>层序遍历</li></ul><h3 id="删除链表中的重复元素II"><a href="#删除链表中的重复元素II" class="headerlink" title="删除链表中的重复元素II"></a>删除链表中的重复元素II</h3><ul><li>模拟操作，要删掉相同的元素（一个不留）</li></ul><h3 id="复习链表"><a href="#复习链表" class="headerlink" title="复习链表"></a>复习链表</h3><ol><li>删除链表中的节点（第一题）、删除链表中的重复元素II（第十七题）：虚拟头节点；一个前驱节点和一个当前节点，如果不用删除两个节点一起往后走。如果要删除，则找到删除后的下一个节点。</li><li>翻转链表：虚拟头节点；三个节点，保留后一个节点，每次将当前节点指向前一个前驱节点，所以还要保留前驱节点。</li><li>两两交换链表中的节点：虚拟头节点；保留后两个节点，然后交换即可。注意循环条件判断while(hair.next &amp;&amp; hair.next.next)</li><li>删除链表倒数第N个节点：虚拟头节点；快慢指针。</li><li>链表相交：一个节点遍历到末尾从另一个头节点开始跑。</li><li>环形链表II：快慢指针。</li><li>回文链表：快慢指针；翻转链表；<br>从第10到16</li></ol><h2 id="八股-19"><a href="#八股-19" class="headerlink" title="八股"></a>八股</h2><h3 id="安克测评"><a href="#安克测评" class="headerlink" title="安克测评"></a>安克测评</h3><h3 id="携程测评"><a href="#携程测评" class="headerlink" title="携程测评"></a>携程测评</h3><h1 id="3-7"><a href="#3-7" class="headerlink" title="3.7"></a>3.7</h1><h2 id="算法-21"><a href="#算法-21" class="headerlink" title="算法"></a>算法</h2><h3 id="叶子相似的节点"><a href="#叶子相似的节点" class="headerlink" title="叶子相似的节点"></a>叶子相似的节点</h3><ul><li>深度搜索即可，顺序都是先左再右，遍历到叶子节点就进行收集。</li></ul><h3 id="找到最高海拔"><a href="#找到最高海拔" class="headerlink" title="找到最高海拔"></a>找到最高海拔</h3><ul><li>前缀和</li></ul><h3 id="咒语和药水"><a href="#咒语和药水" class="headerlink" title="咒语和药水"></a>咒语和药水</h3><ul><li>二分法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-property">length</span>;<br><span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>  <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span>(nums[mid] &lt; value)&#123;<br>    left = mid + <span class="hljs-number">1</span>;<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; value)&#123;<br>    right = mid - <span class="hljs-number">1</span>;<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="八股-20"><a href="#八股-20" class="headerlink" title="八股"></a>八股</h2><h3 id="如何计算font-size-1"><a href="#如何计算font-size-1" class="headerlink" title="如何计算font-size"></a>如何计算font-size</h3><ul><li>方法一是不用媒体查询！</li></ul><ol><li>基于屏幕宽度的动态计算：100vw &#x2F; 7.5。<br>在 750px 宽度的设备上，100vw &#x3D; 750px，因此 1rem &#x3D; 100px。<br>在 375px 宽度的设备上，100vw &#x3D; 375px，因此 1rem &#x3D; 50px。</li><li>媒体查询，不同屏幕不同font-size直接写大小就好了。</li></ol><h3 id="如何解决跨域"><a href="#如何解决跨域" class="headerlink" title="如何解决跨域"></a>如何解决跨域</h3><ol><li>CORS</li><li>JSONP</li><li>postmessage</li><li>开发过程中，启动代理服务器</li></ol><h3 id="为什么要使用reflect-API"><a href="#为什么要使用reflect-API" class="headerlink" title="为什么要使用reflect API"></a>为什么要使用reflect API</h3><ol><li>更一致更可靠的方式实现js的底层操作（读取值，删除值，修改值），代码简洁易读，reflect 13种 api和proxy代理函数一一对应。</li><li>修改this指向，比如一个对象有a、b属性，还有c属性，c属性是get函数写的return this.a + this.b，这里this默认指向对象本身</li></ol><h3 id="watch原理"><a href="#watch原理" class="headerlink" title="watch原理"></a>watch原理</h3><h3 id="computed原理"><a href="#computed原理" class="headerlink" title="computed原理"></a>computed原理</h3><ol><li>数据代理</li><li>lazy</li><li>dirty</li><li>计算属性依赖的数据通知计算属性为脏数据</li></ol><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><ol><li>js事件循环的应用</li><li>队列缓冲事件循环的更新任务</li><li>优雅降级</li></ol><h3 id="为什么data是一个函数"><a href="#为什么data是一个函数" class="headerlink" title="为什么data是一个函数"></a>为什么data是一个函数</h3><h3 id="组件加载流程"><a href="#组件加载流程" class="headerlink" title="组件加载流程"></a>组件加载流程</h3><ul><li>子构造函数放到子组件的虚拟节点上</li></ul><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><ul><li><strong>动态引入</strong>：用import，返回的是一个promise。如果不需要使用组件，只是加载，比如路由配置时候，我们就不用defineAsyncComponent；<br><strong>defineAsyncComponent</strong>：如果页面需要使用这个组件但我们又要异步加载，就要用defineAsyncComponent定义一个异步组件，它相当于让我们先用组件；<br><strong>suspense</strong>：suspense是个组件，提供插槽展示异步组件，还提供备用插槽可以让我们展示组件加载完之前的画面。</li></ul><ol><li><p>defineAsyncComponent:<br>用于定义异步组件。<br>它接受一个返回 Promise 的函数（通常是动态导入 import()）。<br>当组件加载完成后，Vue 会自动渲染它。</p></li><li><p><code>&lt;Suspense&gt;:</code><br>用于包裹异步组件。<br>提供 #default 插槽（放置异步组件）和 #fallback 插槽（加载中的备用内容）。</p></li><li><p>动态导入 (import()):<br>动态导入是 JavaScript 的标准语法，用于按需加载模块。<br>它会返回一个 Promise，当模块加载完成后，Promise 会被解析。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">AsyncComponent</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComponent</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./AsyncComponent.vue&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">AsyncComponent</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="v-if和v-for优先级"><a href="#v-if和v-for优先级" class="headerlink" title="v-if和v-for优先级"></a>v-if和v-for优先级</h3><h3 id="v-if、v-show区别"><a href="#v-if、v-show区别" class="headerlink" title="v-if、v-show区别"></a>v-if、v-show区别</h3><h3 id="组件props的原理"><a href="#组件props的原理" class="headerlink" title="组件props的原理"></a>组件props的原理</h3><ol><li>创建子组件虚拟节点时候，会获取子组件声明的prop数据，把prop数据从属性中删除，单独放到虚拟节点的componentOptions上。</li><li>创建子组件实例时候，把componentOptions转移到组件实例上。</li><li>把prop数据定义为响应式数据放到组件实例上。</li></ol><h3 id="组件事件的原理"><a href="#组件事件的原理" class="headerlink" title="组件事件的原理"></a>组件事件的原理</h3><ol><li>也是把事件放到虚拟节点的componentOptions上。</li><li>转移到子组件实例上。</li><li>$on把事件添加到实例的_event属性上，$emit从_event上取函数执行。</li></ol><h1 id="3-8"><a href="#3-8" class="headerlink" title="3.8"></a>3.8</h1><h2 id="算法-22"><a href="#算法-22" class="headerlink" title="算法"></a>算法</h2><h3 id="奇偶链表"><a href="#奇偶链表" class="headerlink" title="奇偶链表"></a>奇偶链表</h3><h3 id="删除链表的中间节点"><a href="#删除链表的中间节点" class="headerlink" title="删除链表的中间节点"></a>删除链表的中间节点</h3><ul><li>快慢指针</li></ul><h3 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h3><ul><li>二分法，往上坡走</li></ul><h2 id="八股-21"><a href="#八股-21" class="headerlink" title="八股"></a>八股</h2><h3 id="set原理"><a href="#set原理" class="headerlink" title="set原理"></a>set原理</h3><h3 id="异步组件-1"><a href="#异步组件-1" class="headerlink" title="异步组件"></a>异步组件</h3><h3 id="props、事件原理"><a href="#props、事件原理" class="headerlink" title="props、事件原理"></a>props、事件原理</h3><h3 id="插槽原理"><a href="#插槽原理" class="headerlink" title="插槽原理"></a>插槽原理</h3><ol><li>具名插槽、默认插槽</li><li>作用域插槽</li></ol><h3 id="keep-alive组件"><a href="#keep-alive组件" class="headerlink" title="keep-alive组件"></a>keep-alive组件</h3><ul><li>也是插槽</li></ul><h3 id="provide、inject函数"><a href="#provide、inject函数" class="headerlink" title="provide、inject函数"></a>provide、inject函数</h3><h3 id="属性透传"><a href="#属性透传" class="headerlink" title="属性透传"></a>属性透传</h3><h3 id="v-if和v-for优先级-1"><a href="#v-if和v-for优先级-1" class="headerlink" title="v-if和v-for优先级"></a>v-if和v-for优先级</h3><h3 id="v-if和v-show区别"><a href="#v-if和v-show区别" class="headerlink" title="v-if和v-show区别"></a>v-if和v-show区别</h3><h1 id="3-9"><a href="#3-9" class="headerlink" title="3.9"></a>3.9</h1><h2 id="算法-23"><a href="#算法-23" class="headerlink" title="算法"></a>算法</h2><h3 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h3><h3 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h3><h3 id="重排链表-1"><a href="#重排链表-1" class="headerlink" title="重排链表"></a>重排链表</h3><h3 id="promise-any"><a href="#promise-any" class="headerlink" title="promise.any"></a>promise.any</h3><h3 id="最长公共子序列-1"><a href="#最长公共子序列-1" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><h3 id="复习-8"><a href="#复习-8" class="headerlink" title="复习"></a>复习</h3><ul><li>把链表总结完</li></ul><h2 id="八股-22"><a href="#八股-22" class="headerlink" title="八股"></a>八股</h2><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><ul><li>content、padding、border、margin。</li><li>ie盒子模型、标准盒子模型。</li><li>box-sizing：content-box默认标准，border-boxIE模型。</li></ul><h3 id="tcp、udp区别"><a href="#tcp、udp区别" class="headerlink" title="tcp、udp区别"></a>tcp、udp区别</h3><h3 id="loader和plugin的编写"><a href="#loader和plugin的编写" class="headerlink" title="loader和plugin的编写"></a>loader和plugin的编写</h3><h3 id="loader、plugin"><a href="#loader、plugin" class="headerlink" title="loader、plugin"></a>loader、plugin</h3><h3 id="内存分段、分页"><a href="#内存分段、分页" class="headerlink" title="内存分段、分页"></a>内存分段、分页</h3><h3 id="v-model的原理"><a href="#v-model的原理" class="headerlink" title="v-model的原理"></a>v-model的原理</h3><h3 id="组件通信的方式"><a href="#组件通信的方式" class="headerlink" title="组件通信的方式"></a>组件通信的方式</h3><ol><li>prop、emit</li><li>provide、inject</li><li>全局事件总线</li><li>全局状态管理</li><li>localStorage、sessionStorage</li><li>属性透传</li></ol><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol><li>beforeCreate:调用组件init方法时候调用,此时无法访问初始化数据,创建页面watcher,计算属性等等.</li><li>created:响应式数据,计算属性,监听器等初始化完成,但还未进入渲染阶段.</li><li>beforeMount:模板编译,将模板转换为AST语法树,代码拼接成渲染函数,执行渲染函数生成虚拟DOM,diff对比后生成真实DOM.但未挂载到容器上.</li><li>mounted:将生成的html挂载到容器上.</li><li>beforeUpdate:响应式数据更新时调用,此时数据进行了更新,但页面还未渲染.</li><li>updated:render函数重新执行,页面更新.</li><li>beforeUnmount:组件实例销毁前调用,此时还保留了组件所有功能.</li><li>unMounted: 组件卸载完后调用,清除定时器 DOM监听器等等.</li></ol><h3 id="keep-alive的生命周期"><a href="#keep-alive的生命周期" class="headerlink" title="keep-alive的生命周期"></a>keep-alive的生命周期</h3><ol><li>组件会缓存不会真正的销毁，所以不会触发beforeUnmount和unmounted。</li><li>组件被换掉是deactivated、组件切换来是activated。</li></ol><h3 id="后端路由和前端路由"><a href="#后端路由和前端路由" class="headerlink" title="后端路由和前端路由"></a>后端路由和前端路由</h3><ul><li>后端路由：前端请求携带url，后端根据不同的url返回不同的页面。优点是seo优化好，是传统的多页面应用。缺点就是后端性能要求。</li><li>前端路由：spa单页面应用不会因为用户的操作刷新页面，而是js动态的切换内容。但spa存在了问题，用户无法感知当前页面进展到哪，无法前进后退，无法保留当前页面状态。前端路由就基于spa产生了，每个url对应一个资源，监听url的变化，js动态加载不同的页面内容。</li></ul><h3 id="hash和history"><a href="#hash和history" class="headerlink" title="hash和history"></a>hash和history</h3><ol><li>hash：#，刷新不会携带hash值给后端，监听hashchange事件加载不同的路由，浏览器前进后退可以记录。</li><li>history：没有#，监听popstate事件。404问题</li></ol><h3 id="在vue-router里面，用pushState、replaceState而不是vue的push能触发页面路由切换吗"><a href="#在vue-router里面，用pushState、replaceState而不是vue的push能触发页面路由切换吗" class="headerlink" title="在vue-router里面，用pushState、replaceState而不是vue的push能触发页面路由切换吗"></a>在vue-router里面，用pushState、replaceState而不是vue的push能触发页面路由切换吗</h3><ul><li>不能，vue的router.push(‘&#x2F;new-url’);router.replace(‘&#x2F;new-url’)方法会触发导航守卫、渲染组件，再调用pushstate、replacestate更改url，<strong>router.push方法相当于在pushstate做了一层封装</strong>，直接使用replace、push没有js切换页面的逻辑。</li></ul><h3 id="replacestate、popState、pushState"><a href="#replacestate、popState、pushState" class="headerlink" title="replacestate、popState、pushState"></a>replacestate、popState、pushState</h3><ul><li>vue中、qiankun中的处理。</li></ul><h1 id="3-10"><a href="#3-10" class="headerlink" title="3.10"></a>3.10</h1><h2 id="算法-24"><a href="#算法-24" class="headerlink" title="算法"></a>算法</h2><h3 id="种花问题"><a href="#种花问题" class="headerlink" title="种花问题"></a>种花问题</h3><ul><li>前插入0，后插入0.</li></ul><h3 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h3><ul><li>排序的数组，时间复杂度为logn，二分法需求拉满了。</li></ul><h3 id="最长递增子序列-1"><a href="#最长递增子序列-1" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><h3 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a>最长连续递增序列</h3><h3 id="最长重复子数组-1"><a href="#最长重复子数组-1" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h3><ul><li>开始复习动态规划。</li></ul><h2 id="八股-23"><a href="#八股-23" class="headerlink" title="八股"></a>八股</h2><h3 id="TCL测评"><a href="#TCL测评" class="headerlink" title="TCL测评"></a>TCL测评</h3><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><ul><li>每次返回收集参数的函数，参数个数够了返回执行函数，不够继续返回收集参数的函数。this绑定。</li></ul><h3 id="vuex和localStorage区别"><a href="#vuex和localStorage区别" class="headerlink" title="vuex和localStorage区别"></a>vuex和localStorage区别</h3><ol><li>vuex存在内存中，localStorage在本地磁盘里面。</li><li>vuex数据是响应式的，localStorage只是字符串。</li><li>vuex刷新数据会丢失，localStorage不会。</li></ol><h3 id="为什么vuex需要action，pinia不需要？"><a href="#为什么vuex需要action，pinia不需要？" class="headerlink" title="为什么vuex需要action，pinia不需要？"></a>为什么vuex需要action，pinia不需要？</h3><ol><li>vuex是在action里处理异步操作、封装复杂的逻辑复用。mutations修改会被vue开发插件记录，方便调试。</li><li>pinia是对其简化，更贴合组合式api的灵活和组合。</li></ol><h3 id="vuex和pinia区别？"><a href="#vuex和pinia区别？" class="headerlink" title="vuex和pinia区别？"></a>vuex和pinia区别？</h3><ol><li>去除了mutations，保留actions、data、getters。</li><li>pinia是ts编写，类型提示更友好。</li><li>pinia支持组合式api和选项式api。</li><li>vuex是单例模式，定义的是树结构，读取数据困难；在底层会把树扁平，命名冲突会出现覆盖情况；pinia是定义了多个store，扁平化结构，不会出现冲突。</li></ol><h3 id="vue3响应式原理-1"><a href="#vue3响应式原理-1" class="headerlink" title="vue3响应式原理"></a>vue3响应式原理</h3><ol><li>proxy</li><li>支持对set、map的响应式</li></ol><h3 id="attrs-组件上所有的属性-和-listeners-组件上所有的事件"><a href="#attrs-组件上所有的属性-和-listeners-组件上所有的事件" class="headerlink" title="$attrs(组件上所有的属性)和$listeners(组件上所有的事件)"></a><code>$attrs</code>(组件上所有的属性)和<code>$listeners</code>(组件上所有的事件)</h3><ul><li>透传属性是传递给一个组件，并且没有被组件prop、事件声明的属性。最常见的是style、class、id。</li><li>如果组件只有一个根元素，会直接放到根元素上，如果子组件也有class、style则会进行合并，事件也会合并；多个根元素的话会抛提醒，不会直接渲染，要手动。</li><li>defineOptions宏定义禁止透传，一般用于attribute 需要应用在根节点以外的其他元素上。</li></ul><h3 id="vue复习"><a href="#vue复习" class="headerlink" title="vue复习"></a>vue复习</h3><ol><li>AST语法树的生成过程</li><li>AST语法树代码拼接成渲染函数</li><li>AST语法树和虚拟DOM区别</li><li>npm run build后发生什么</li><li>vue2 和 vue3 diff算法</li><li>Object.defineProperty 和 proxy的区别</li><li>响应式原理</li><li>数组响应式原理</li><li>vue2响应式原理缺点</li><li>vue3响应式原理优化</li><li>响应式为什么用reflectAPI</li><li>watch原理</li><li>computed原理</li><li>nextTick原理</li><li>为什么data是函数</li><li>组件渲染过程</li><li>Vue.set原理</li><li>异步组件</li><li>props原理</li><li>emit原理</li><li>插槽原理</li><li>keep-alive原理</li><li>provide和inject原理</li><li>属性透传</li><li>v-if和v-for优先级哪个更高</li><li>v-if和v-show区别</li><li>v-model原理</li><li>前端路由和后端路由</li><li>hash模式和history模式</li><li>vuex和localStorage区别</li><li>vuex为什么有mutations而pinia没有</li><li>vuex和pinia区别</li></ol><h1 id="3-11"><a href="#3-11" class="headerlink" title="3.11"></a>3.11</h1><h2 id="算法-25"><a href="#算法-25" class="headerlink" title="算法"></a>算法</h2><h3 id="爱吃香蕉的珂珂"><a href="#爱吃香蕉的珂珂" class="headerlink" title="爱吃香蕉的珂珂"></a>爱吃香蕉的珂珂</h3><ul><li>二分法</li></ul><h3 id="排序数组中查找第一次出现和最后一次出现"><a href="#排序数组中查找第一次出现和最后一次出现" class="headerlink" title="排序数组中查找第一次出现和最后一次出现"></a>排序数组中查找第一次出现和最后一次出现</h3><ul><li>找到后，继续向左或向右收缩。</li></ul><h3 id="最长公公子序列"><a href="#最长公公子序列" class="headerlink" title="最长公公子序列"></a>最长公公子序列</h3><h3 id="不相交的线-1"><a href="#不相交的线-1" class="headerlink" title="不相交的线"></a>不相交的线</h3><ul><li>纯纯的最长公共子序列</li></ul><h3 id="寻找重复的子树"><a href="#寻找重复的子树" class="headerlink" title="寻找重复的子树"></a>寻找重复的子树</h3><h2 id="八股-24"><a href="#八股-24" class="headerlink" title="八股"></a>八股</h2><h3 id="并发promise"><a href="#并发promise" class="headerlink" title="并发promise"></a>并发promise</h3><ol><li>for循环开启最大次数的请求，多个滚轮循环滚动。</li><li>记录当前运行到的下标，记录完成的下标。</li></ol><h3 id="ts是什么，和js区别？"><a href="#ts是什么，和js区别？" class="headerlink" title="ts是什么，和js区别？"></a>ts是什么，和js区别？</h3><ol><li>后缀是ts，后缀是js，js执行速度更快，ts需要编译成js再执行，是js的超集。</li><li>ts可以在编译时发现错误，js只能在运行时发现错误。</li><li>ts是强类型语言，有类型推断、类型断言。</li><li>支持模块、接口、枚举</li></ol><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ol><li>对数值常量赋予友好的名称；策略状态 空跑 0，上线 1，下线 1.</li><li>原理：对象空跑属性赋值为1，属性1赋值为空跑。</li><li>提高代码可读性。</li></ol><h3 id="接口、类"><a href="#接口、类" class="headerlink" title="接口、类"></a>接口、类</h3><ul><li>接口是对对象方法和属性的抽象，是对属性和方法的描述，但不提供创建对象的方法。</li><li>类：具体实现创建对象的方法。</li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li>具体实现对象的方法</li><li>字段、构造函数、方法</li><li>继承、修饰符、静态属性</li></ul><h3 id="interface和type区别"><a href="#interface和type区别" class="headerlink" title="interface和type区别"></a>interface和type区别</h3><ol><li>interface一般用来定义对象、函数、类；type除了可以定义接口类型外，还可以定义常量类型、联合类型、交叉类型以及任何可以手写的类型。</li><li>interface通过extends扩展接口，type通过联合类型 &amp; 扩展。</li><li>interface：支持声明合并。如果多次定义同名接口，TypeScript 会自动合并它们。type：不支持声明合并。如果多次定义同名类型，会报错。</li></ol><h1 id="3-12"><a href="#3-12" class="headerlink" title="3.12"></a>3.12</h1><h2 id="算法-26"><a href="#算法-26" class="headerlink" title="算法"></a>算法</h2><h3 id="除自身以外的乘积"><a href="#除自身以外的乘积" class="headerlink" title="除自身以外的乘积"></a>除自身以外的乘积</h3><ul><li>前缀乘，后缀乘积；优化空间复杂度。</li></ul><h3 id="最大子数组和-2"><a href="#最大子数组和-2" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><h3 id="判断子序列-1"><a href="#判断子序列-1" class="headerlink" title="判断子序列"></a>判断子序列</h3><ul><li>最长公共子序列、双指针。</li></ul><h2 id="八股-25"><a href="#八股-25" class="headerlink" title="八股"></a>八股</h2><h3 id="实现非负大整数相加"><a href="#实现非负大整数相加" class="headerlink" title="实现非负大整数相加"></a>实现非负大整数相加</h3><h3 id="DOM0、IE（DOM1）、DOM2事件"><a href="#DOM0、IE（DOM1）、DOM2事件" class="headerlink" title="DOM0、IE（DOM1）、DOM2事件"></a>DOM0、IE（DOM1）、DOM2事件</h3><ul><li>0只有事件触发</li><li>1是事件触发，事件冒泡</li><li>2是事件捕获，触发，冒泡</li></ul><h3 id="手写构造函数继承"><a href="#手写构造函数继承" class="headerlink" title="手写构造函数继承"></a>手写构造函数继承</h3><h3 id="ts函数的理解"><a href="#ts函数的理解" class="headerlink" title="ts函数的理解"></a>ts函数的理解</h3><ul><li>参数、返回值的个数类型是确定的</li><li>可选值</li><li>函数重载：允许重复声明函数名相同但是参数或者返回值个数、类型不同的函数，具体的函数实现还是一个要用 联合类型或可选值判断。</li></ul><h3 id="ts泛型的理解"><a href="#ts泛型的理解" class="headerlink" title="ts泛型的理解"></a>ts泛型的理解</h3><ol><li>类型的变量，可以使用未来才能确定的类型。</li><li>复用效果，比如一个函数入参是string，返回值是string；入参是数字，返回值是数字，就可以使用泛型。</li><li>泛型的约束是extends。</li></ol><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><ol><li>交叉类型，多个类型合并成一个类型。 &amp;</li><li>联合类型，多个类型中的一个类型。 |</li><li>类型别名：type定义一个类型变量，除了可以定义接口、函数、类类型外，还可以定义联合类型、交叉类型、常量类型以及所有可以手写的类型。</li><li>类型索引：keyof，获取接口类型的属性的常量联合类型。</li><li>类型约束：extends。function add&lt;T, U extends keyof T&gt;(object : T, key : U)</li><li>条件类型：K extends T ? X : Y</li></ol><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><ol><li>作用于定义好的变量的类型。</li><li>配合ReturnType 和 Paramters</li><li>typeof colors[keyof typeof obj]</li></ol><h3 id="returnType-parameters"><a href="#returnType-parameters" class="headerlink" title="returnType parameters"></a>returnType parameters</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> returnType&lt;T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt; = <br>T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; infer K ? K : <span class="hljs-built_in">never</span>;<br><br><span class="hljs-keyword">type</span> parameters&lt;T <span class="hljs-title function_">extends</span> (...args : <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt; = <br>T <span class="hljs-title function_">extends</span> (...args : infer K) =&gt; <span class="hljs-built_in">any</span> ? K : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><h3 id="patical、required、readonly"><a href="#patical、required、readonly" class="headerlink" title="patical、required、readonly"></a>patical、required、readonly</h3><h3 id="小米笔试"><a href="#小米笔试" class="headerlink" title="小米笔试"></a>小米笔试</h3><h3 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h3><ol><li>ts和js区别</li><li>枚举类型</li><li>接口和类区别</li><li>ts函数的理解</li><li>泛型理解</li><li>interface和type区别</li><li>any和unkown区别</li><li>高级类型：交叉类型、联合类型、类型别名、类型索引、typeof、infer</li><li>returnType、parameters</li><li>patical、required、readonly。</li></ol><h1 id="3-13"><a href="#3-13" class="headerlink" title="3.13"></a>3.13</h1><h2 id="算法-27"><a href="#算法-27" class="headerlink" title="算法"></a>算法</h2><h3 id="路径总和III"><a href="#路径总和III" class="headerlink" title="路径总和III"></a>路径总和III</h3><h3 id="找出两数组的不同"><a href="#找出两数组的不同" class="headerlink" title="找出两数组的不同"></a>找出两数组的不同</h3><h3 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h3><h3 id="交替合并字符串"><a href="#交替合并字符串" class="headerlink" title="交替合并字符串"></a>交替合并字符串</h3><h2 id="八股-26"><a href="#八股-26" class="headerlink" title="八股"></a>八股</h2><h3 id="手写发布订阅模式"><a href="#手写发布订阅模式" class="headerlink" title="手写发布订阅模式"></a>手写发布订阅模式</h3><h3 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h3><ul><li>亮点：微前端的接入和路由级别按钮别的权限控制、包括接入单点登录。先说第一个微前端的接入。微前端其实是将一个巨石应用拆分成多个独立松耦合的应用，qiankun是有一个基座应用也叫父应用，其他子应用来回切换在父应用挂载展示。具体的改造流程我总结以下几点：</li></ul><ol><li>在父应用注册子应用的信息，包括子应用的应用名、子应用挂载的容器、子应用激活的路径：qiankun会去监听url的变化，匹配到对应的路径时候会去加载对应的子应用、子应用加载的路径：路径匹配到后，qiankun会通过import-html-entry通过子应用路径加载对应的子应用。</li><li>子应用对外暴露接口协议，qiankun通过import-html-entry加载子应用，具体加载流程是：xxxxxx，返回html模板和包括js代码的函数。加载完子应用后也会获取子应用对外暴露的协议，bootstrap、mount、unmount，分别在启动、挂载、卸载时候调用。挂载时候会把html模板放到容器上。</li><li>public-path</li><li>容器位置</li><li>全局变量</li></ol><ul><li>第二个是路由级别、按钮级别的权限控制，以及接入单点登录。策略运营平台分为定性策略和处置策略，定性策略是对数据性质判断，比如它是恶意数据还是非恶意数据，处置策略是对定性的数据进行处置，比如恶意的数据进行机审、人审、放过等等。配置定性和配置处置是两拨人，不同的配置页面是不同人操作，所以有路由权限控制的需求；同时定性的可能也可以查看处置策略，但不能增删改，所以有按钮级别权限的需求。<br>按钮级别的权限控制：请求配置中心，配置中心有权限节点和权限id的映射，当然还有其他白名单用户等等信息，映射比如id 1 对应新增，id 2对应删除等等；然后还有权限中心，是用户申请权限的位置，请求对应的后台获取当前用户的权限节点，比如 1 2 3 4，然后根据映射获取用户所拥有的权限节点。一个用户可能有新增策略、删除策略等等权限，在页面的新增按钮，v-if 权限节点包括新增节点，则可以操作，否则不能操作。<br>路由权限控制：在路由配置时候元信息配置进入当前路由需要的权限节点，如果用户有这个权限节点会在元信息注入一个hasAuth字段，如果有这个字段则可以跳转页面，否则不能跳转，当然白名单也可以跳转。</li></ul><h3 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h3><ul><li><a href="https://juejin.cn/post/6984188410659340324?searchId=2025031315545535021E8FF05054738485#heading-2">https://juejin.cn/post/6984188410659340324?searchId=2025031315545535021E8FF05054738485#heading-2</a></li></ul><ol><li>不恰当的闭包</li><li>全局变量</li><li>DOM引用：父元素删除了，但对子元素还有引用。</li><li>未关闭的定时器</li><li>事件监听：组件卸载要关闭。监听者模式：全局总线，组件绑定事件，组件卸载要解绑事件。</li><li>未清理的console.log，如果log是打印对象，也不会垃圾回收。</li><li>map、set：这两个是强引用，如果对象被这两个存储了，即使删除了对象，对象也还在。</li></ol><h3 id="如何查看是否有内存泄露"><a href="#如何查看是否有内存泄露" class="headerlink" title="如何查看是否有内存泄露"></a>如何查看是否有内存泄露</h3><ol><li>性能performance面板，开始记录，开始时候清空一次垃圾。</li><li>然后进行操作，操作到一半再清空一次垃圾（能回收就没有泄漏）。</li><li>操作完，结束记录。如果查看中间清空的时候 js堆内存没有减少，就是有内存泄漏。</li></ol><h3 id="如何定位到泄露的位置"><a href="#如何定位到泄露的位置" class="headerlink" title="如何定位到泄露的位置"></a>如何定位到泄露的位置</h3><ol><li>内存面板，可以生成堆快照。</li><li>进行一次GC，操作，生成快照。</li><li>进行一次GC，操作，生成快照。</li><li>对比前后堆快照的区别，它会标明是代码执行到哪一行新增了堆，新增的就是泄露的内存。</li></ol><h1 id="3-14"><a href="#3-14" class="headerlink" title="3.14"></a>3.14</h1><h2 id="算法-28"><a href="#算法-28" class="headerlink" title="算法"></a>算法</h2><h3 id="压缩字符串"><a href="#压缩字符串" class="headerlink" title="压缩字符串"></a>压缩字符串</h3><h3 id="两个字符串的删除操作-1"><a href="#两个字符串的删除操作-1" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h3><h3 id="编辑距离-1"><a href="#编辑距离-1" class="headerlink" title="编辑距离"></a>编辑距离</h3><h2 id="八股-27"><a href="#八股-27" class="headerlink" title="八股"></a>八股</h2><h3 id="从A页面跳转到B页面的优化"><a href="#从A页面跳转到B页面的优化" class="headerlink" title="从A页面跳转到B页面的优化"></a>从A页面跳转到B页面的优化</h3><ol><li>A页面内：link标签，rel属性，pre-load、pre-fetch、dns-pre；B页面内 async、defer。</li><li>http2.0主动推送</li><li>webpack拆分模块，请求速度更快。</li><li>单页面应用：全局状态管理，集中管理共享依赖。</li><li>webworker</li><li>浏览器缓存</li></ol><h3 id="如果接手一个项目，如何处理？"><a href="#如果接手一个项目，如何处理？" class="headerlink" title="如果接手一个项目，如何处理？"></a>如果接手一个项目，如何处理？</h3><ul><li>需求分析、阅读文档、查看代码、环境配置、开发部署、团队沟通。</li></ul><ol><li>需求分析：确认项目是干什么的，最好按操作流程走一遍。</li><li>阅读文档：使用文档、开发文档。</li><li>阅读代码结构：技术栈、组件、公共方法、公共样式类等等，确定到开发部分。</li><li>环境配置：开发环境下开发，不要影响线上。</li><li>开发发布：git提交规范；开发完后运行流水线，部署到对应的服务上；代码备份，了解回滚操作。</li><li>团队沟通：需求排期；项目组长及时沟通实现方案；后端沟通具体实现；用户沟通需求；</li></ol><h3 id="BEM-CSS命名规范-1"><a href="#BEM-CSS命名规范-1" class="headerlink" title="BEM:CSS命名规范"></a>BEM:CSS命名规范</h3><ul><li>B块：代表一个功能模块，E模块的一个元素，M修饰符。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button button--primary&quot;</span>&gt;</span>Primary Button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button button--secondary&quot;</span>&gt;</span>Secondary Button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="类的写法"><a href="#类的写法" class="headerlink" title="类的写法"></a>类的写法</h3><ol><li>类可以定义实例的变量，直接赋值。</li><li>类的构造函数可以接受参数赋值。</li><li>原型对象上的方法直接写。</li><li>静态方法、静态属性加static。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Modal</span>&#123;<br>  a = <span class="hljs-number">10</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">b,c</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> = b;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">c</span> = c;<br>  &#125;;<br>  <span class="hljs-title function_">result</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">c</span>;<br>  &#125;;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">funInModal</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Modal.funInModal来调用我`</span>);<br>  &#125;;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title class_">ModalValue</span> = <span class="hljs-number">100</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="TCP、IP四层模型"><a href="#TCP、IP四层模型" class="headerlink" title="TCP、IP四层模型"></a>TCP、IP四层模型</h3><ol><li>应用层：定义通信的规则和数据格式（HTTP、http数据格式），身份认证（HTTPS），错误处理（HTTP状态码）。</li><li>传输层：TCP、UDP协议，TCP可靠传输：滑动窗口、拥塞控制、流量控制、先建立连接、一对一；UDP不可靠传输：发送数据，不用建立连接。</li><li>网络层：IP协议，根据IP地址，通过路由器转发到对应的网络。</li><li>数据链路层：在网络内，通过交换机将数据交付给对应的主机。</li></ol><h3 id="浏览器渲染过程中的两个生命周期钩子"><a href="#浏览器渲染过程中的两个生命周期钩子" class="headerlink" title="浏览器渲染过程中的两个生命周期钩子"></a>浏览器渲染过程中的两个生命周期钩子</h3><p>DOMContentLoaded事件<br>当HTML文档完全解析并构建完DOM树时，会触发DOMContentLoaded事件。</p><p>此时，JS可以通过监听该事件来执行与DOM相关的操作。</p><ol start="5"><li>load事件<br>当页面中的所有资源（如图片、样式表、JS文件等）都加载完成后，会触发load事件。</li></ol><p>此时，JS可以通过监听该事件来执行与页面完全加载相关的操作。</p><h3 id="讲讲在浏览器渲染过程中JS是在什么时候执行的"><a href="#讲讲在浏览器渲染过程中JS是在什么时候执行的" class="headerlink" title="讲讲在浏览器渲染过程中JS是在什么时候执行的"></a>讲讲在浏览器渲染过程中JS是在什么时候执行的</h3><ul><li>遇到script标签执行。因为js线程和渲染线程冲突只能有一个执行，遇到script标签就会停止解析html模板去加载执行js。如果是async、defer不一样。</li></ul><h1 id="3-15"><a href="#3-15" class="headerlink" title="3.15"></a>3.15</h1><h2 id="算法-29"><a href="#算法-29" class="headerlink" title="算法"></a>算法</h2><h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><h3 id="颜色交替的路径"><a href="#颜色交替的路径" class="headerlink" title="颜色交替的路径"></a>颜色交替的路径</h3><h2 id="八股-28"><a href="#八股-28" class="headerlink" title="八股"></a>八股</h2><h3 id="压缩css"><a href="#压缩css" class="headerlink" title="压缩css"></a>压缩css</h3><ul><li>闭包思想，提取思想（先写一个版本，再提取）。</li></ul><h3 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h3><h3 id="Promise-retry-promise-count-time"><a href="#Promise-retry-promise-count-time" class="headerlink" title="Promise.retry(promise, count, time)"></a>Promise.retry(promise, count, time)</h3><ul><li>请求失败后,每隔多少秒重新请求一次,直到上限</li></ul><h3 id="Promise-any-1"><a href="#Promise-any-1" class="headerlink" title="Promise.any"></a>Promise.any</h3><ul><li>和Promise.all相反,有一个成功就返回,所有失败返回所有失败的数组.</li></ul><h3 id="Promise数组顺序执行"><a href="#Promise数组顺序执行" class="headerlink" title="Promise数组顺序执行"></a>Promise数组顺序执行</h3><h3 id="编写复杂的深拷贝"><a href="#编写复杂的深拷贝" class="headerlink" title="编写复杂的深拷贝"></a>编写复杂的深拷贝</h3><h3 id="数组扁平化五种方法"><a href="#数组扁平化五种方法" class="headerlink" title="数组扁平化五种方法"></a>数组扁平化五种方法</h3><h3 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h3><h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><ol><li>！important</li><li>内联样式：style&#x3D; “color: red”</li><li>id选择器：#</li><li>类、伪类、属性选择器</li><li>元素（标签）、伪元素选择器。</li><li>通配符、子代后代选择器</li></ol><ul><li>额外点：</li></ul><ol><li>优先级高的生效，优先级相同时候，后定义的生效。</li><li>内联样式 》 内部样式 》 外部样式 》 浏览器默认样式</li></ol><h3 id="可-不可继承属性"><a href="#可-不可继承属性" class="headerlink" title="可&#x2F;不可继承属性"></a>可&#x2F;不可继承属性</h3><ol><li>可：font-size、font-weight、font-family、文本color、visibility</li><li>不可：盒子模型、display、background、定位。</li></ol><h3 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h3><ol><li>none</li><li>block：独占一行，可以设置宽高，宽默认为整个父元素高度由子元素撑开。</li><li>inline：不独占一行，不可以设置宽高，都由子元素撑开。</li><li>inherit</li></ol><h3 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h3><h1 id="3-16"><a href="#3-16" class="headerlink" title="3.16"></a>3.16</h1><h2 id="算法-30"><a href="#算法-30" class="headerlink" title="算法"></a>算法</h2><h3 id="回文子串-1"><a href="#回文子串-1" class="headerlink" title="回文子串"></a>回文子串</h3><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><h2 id="八股-29"><a href="#八股-29" class="headerlink" title="八股"></a>八股</h2><h3 id="umd格式"><a href="#umd格式" class="headerlink" title="umd格式"></a>umd格式</h3><ul><li>umd格式是一个通用的模块格式，兼容不同的模块系统，让ns可以运行在多个环境中。比如 浏览器 nodejs。</li><li>写法是一个立即执行函数，把js代码包裹在函数中。</li></ul><h3 id="为什么qiankun要用umd格式"><a href="#为什么qiankun要用umd格式" class="headerlink" title="为什么qiankun要用umd格式"></a>为什么qiankun要用umd格式</h3><ol><li>核心：通过闭包隔离模块代码，避免子应用变量与全局或者其他子应用冲突。<br>2.（<br>动态加载，script标签<br>qiankun需要子应用对外暴露生命周期钩子，umd格式可以方便对外暴露</li></ol><p>依赖共享）</p><h3 id="写lodash-get"><a href="#写lodash-get" class="headerlink" title="写lodash.get"></a>写lodash.get</h3><h3 id="手写promise-all"><a href="#手写promise-all" class="headerlink" title="手写promise.all"></a>手写promise.all</h3><h3 id="transition、animation"><a href="#transition、animation" class="headerlink" title="transition、animation"></a>transition、animation</h3><ol><li>transtion是过度，需要触发条件，只有一个开始帧和结束帧。</li><li>animation功能更强大，不需要触发条件，多少秒后执行，有多个关键帧。</li></ol><h3 id="link和-import区别"><a href="#link和-import区别" class="headerlink" title="link和@import区别"></a>link和@import区别</h3><ol><li>link单独开启线程去加载css资源，@import会阻塞GUI线程，让GUI线程去加载资源。</li></ol><h3 id="伪元素和伪类区别"><a href="#伪元素和伪类区别" class="headerlink" title="伪元素和伪类区别"></a>伪元素和伪类区别</h3><ul><li>伪元素：元素的特定一部分，<strong>这部分不是元素，不存在</strong>，比如：某一个元素的前面后面插入内容、第一行。</li><li>伪类：作用于特定状态的<strong>元素</strong>，比如：鼠标悬停、结构状态第一个孩子。</li></ul><h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h3><ol><li>接受一个回调函数，该函数会在下次回流前调用</li><li>回流是根据浏览器刷新频率触发，60hz就是一秒刷新60次，一秒60次回流，也就调用该函数六十次。</li><li>优点：<br>动画更流畅，不会掉帧、卡顿。<br>cpu节能，页面隐藏时候setTimeout会继续执行，requestAnimation会暂停动画。</li></ol><h3 id="为什么用transition改变元素位置"><a href="#为什么用transition改变元素位置" class="headerlink" title="为什么用transition改变元素位置"></a>为什么用transition改变元素位置</h3><ul><li>不会触发回流重绘，只会触发<strong>复合</strong>。可以单独抽离出合成层，利用GPU加速渲染。</li></ul><h2 id="css3新特性-9997"><a href="#css3新特性-9997" class="headerlink" title="css3新特性 &#9997;"></a>css3新特性 &#9997;</h2><ol><li>属性选择器、伪类选择器、伪元素选择器</li><li>flex弹性布局</li><li>transition、animation</li><li>媒体查询、em、rem</li><li>border-radius圆角边框、box-shadow、</li></ol><h3 id="less预处理"><a href="#less预处理" class="headerlink" title="less预处理"></a>less预处理</h3><ul><li>css上封装了一层</li><li>函数运算、变量、嵌套、模块</li></ul><h3 id="单行文本溢出、多行文本溢出"><a href="#单行文本溢出、多行文本溢出" class="headerlink" title="单行文本溢出、多行文本溢出"></a>单行文本溢出、多行文本溢出</h3><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><ul><li>display：flow-root；</li></ul><h3 id="clearfix"><a href="#clearfix" class="headerlink" title="clearfix"></a>clearfix</h3><p>.clearfix::after,<br>.clearfix::before{<br>  content:””,<br>  display:table,<br>  clear:both,<br>}</p><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><h3 id="层叠顺序、层叠上下文"><a href="#层叠顺序、层叠上下文" class="headerlink" title="层叠顺序、层叠上下文"></a>层叠顺序、层叠上下文</h3><h3 id="判断元素在上还是在下"><a href="#判断元素在上还是在下" class="headerlink" title="判断元素在上还是在下"></a>判断元素在上还是在下</h3><h3 id="css单位"><a href="#css单位" class="headerlink" title="css单位"></a>css单位</h3><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><ol><li>选择器优先级</li><li>可继承和不可继承的属性</li><li>display属性</li><li>隐藏元素的方法，三者区别</li><li>link和@import区别</li><li>transition和animation区别</li><li>伪元素和伪类的区别</li><li>requestAnimationFrame的理解</li><li>对盒模型的理解（IE、标准盒子模型，如何设置）</li><li>为什么用transition改变元素位置</li><li>CSS3的新特性</li><li>css处理器</li><li>单行多行文本溢出</li><li>媒体查询</li><li>z-index什么时候失效</li><li>浮动元素的特点和缺点</li><li>BFC</li><li>clearfix</li><li>定位</li><li>元素层叠顺序</li><li>层叠上下文</li><li>比较两个元素谁在上、谁在下</li><li>css单位</li><li>两栏布局</li><li>三栏布局</li><li>垂直居中</li><li>flex布局</li></ol><h1 id="3-17"><a href="#3-17" class="headerlink" title="3.17"></a>3.17</h1><h2 id="算法-手写"><a href="#算法-手写" class="headerlink" title="算法 + 手写"></a>算法 + 手写</h2><h3 id="每隔五秒打印一个数字，可以控制中断"><a href="#每隔五秒打印一个数字，可以控制中断" class="headerlink" title="每隔五秒打印一个数字，可以控制中断"></a>每隔五秒打印一个数字，可以控制中断</h3><h3 id="每隔一秒打印一个数字1234"><a href="#每隔一秒打印一个数字1234" class="headerlink" title="每隔一秒打印一个数字1234"></a>每隔一秒打印一个数字1234</h3><h3 id="循环打印红绿灯"><a href="#循环打印红绿灯" class="headerlink" title="循环打印红绿灯"></a>循环打印红绿灯</h3><h3 id="递增三元组"><a href="#递增三元组" class="headerlink" title="递增三元组"></a>递增三元组</h3><h3 id="列表转换为树"><a href="#列表转换为树" class="headerlink" title="列表转换为树"></a>列表转换为树</h3><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><h2 id="八股-30"><a href="#八股-30" class="headerlink" title="八股"></a>八股</h2><h3 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h3><ul><li>display: flex;centercenter;</li><li>float:left,right; overflow:hidden</li><li>float,margin-left,margin-right.</li><li>position relative; absolute left right 0</li></ul><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ul><li>display:flex, justify-content align-items</li><li>position: relative absolute top bottom left right 0   margin auto</li><li>position: 50% 50% transform translate</li></ul><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><h3 id="git如何解决冲突"><a href="#git如何解决冲突" class="headerlink" title="git如何解决冲突"></a>git如何解决冲突</h3><h3 id="常见git指令"><a href="#常见git指令" class="headerlink" title="常见git指令"></a>常见git指令</h3><h3 id="git如何回滚"><a href="#git如何回滚" class="headerlink" title="git如何回滚"></a>git如何回滚</h3><h3 id="git-rebase和git-merge区别"><a href="#git-rebase和git-merge区别" class="headerlink" title="git rebase和git merge区别"></a>git rebase和git merge区别</h3><h3 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h3><ul><li>webpack的配置文件</li></ul><h3 id="微前端的接入"><a href="#微前端的接入" class="headerlink" title="微前端的接入"></a>微前端的接入</h3><h3 id="路由级别按钮级别的权限控制"><a href="#路由级别按钮级别的权限控制" class="headerlink" title="路由级别按钮级别的权限控制"></a>路由级别按钮级别的权限控制</h3><h3 id="复习项目亮点-微前端"><a href="#复习项目亮点-微前端" class="headerlink" title="复习项目亮点 + 微前端"></a>复习项目亮点 + 微前端</h3><h1 id="3-18"><a href="#3-18" class="headerlink" title="3.18"></a>3.18</h1><h2 id="算法-31"><a href="#算法-31" class="headerlink" title="算法"></a>算法</h2><h3 id="翻转字符串中的单词"><a href="#翻转字符串中的单词" class="headerlink" title="翻转字符串中的单词"></a>翻转字符串中的单词</h3><h3 id="字符串的最大公因子"><a href="#字符串的最大公因子" class="headerlink" title="字符串的最大公因子"></a>字符串的最大公因子</h3><ul><li>let gcd &#x3D; (a,b) &#x3D;&gt; b &#x3D;&#x3D; 0 ? b : gcd(b, a % b);</li></ul><h3 id="deepCopy"><a href="#deepCopy" class="headerlink" title="deepCopy"></a>deepCopy</h3><h3 id="lodash-get"><a href="#lodash-get" class="headerlink" title="lodash.get"></a>lodash.get</h3><h3 id="字符串模板引擎"><a href="#字符串模板引擎" class="headerlink" title="字符串模板引擎"></a>字符串模板引擎</h3><h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h3><h3 id="Lazyman"><a href="#Lazyman" class="headerlink" title="Lazyman"></a>Lazyman</h3><h3 id="请求五秒"><a href="#请求五秒" class="headerlink" title="请求五秒"></a>请求五秒</h3><h2 id="八股-31"><a href="#八股-31" class="headerlink" title="八股"></a>八股</h2><h3 id="subString和slice区别"><a href="#subString和slice区别" class="headerlink" title="subString和slice区别"></a>subString和slice区别</h3><p>1、slice：两个参数分别表示截取字符串的起始位置和结束位置，如果大于0，则从前面计数，如果小于0，则从后面计数，如果省略第二个参数，则会截取到字符串的尾部。<br>2. substring：两个参数分别表示字符串的起始位置和结束位置，所不同的是substring中如果结束位置在起始位置之前，则会自动将其调换后截取，当参数小于0 时按0处理，如果省略第二个参数，则会截取到字符串的尾部</p><h3 id="string的replace方法-10024"><a href="#string的replace方法-10024" class="headerlink" title="string的replace方法 &#10024;"></a>string的replace方法 &#10024;</h3><ul><li><a href="https://blog.csdn.net/qq_46658751/article/details/123390095">https://blog.csdn.net/qq_46658751/article/details/123390095</a></li></ul><ol><li>replace(字符串，字符串)，只能替换一次</li><li>replace（正则&#x2F;g，字符串）多次替换</li><li>replace（正则，函数）核心用法，函数第一个参数是匹配到的子串，第二个是起始索引，第三个是字符串本身。如果有捕获器的值则插入在第二个参数，起始索引变第三个参数，字符串本身变第四个参数。</li></ol><h3 id="微前端-项目准备滴滴二面"><a href="#微前端-项目准备滴滴二面" class="headerlink" title="微前端 项目准备滴滴二面"></a>微前端 项目准备滴滴二面</h3><h3 id="滴滴二面"><a href="#滴滴二面" class="headerlink" title="滴滴二面"></a>滴滴二面</h3><h1 id="3-19"><a href="#3-19" class="headerlink" title="3.19"></a>3.19</h1><h2 id="算法-32"><a href="#算法-32" class="headerlink" title="算法"></a>算法</h2><h3 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h3><h3 id="随机链表的复制-1"><a href="#随机链表的复制-1" class="headerlink" title="随机链表的复制"></a>随机链表的复制</h3><h3 id="第N个泰波那契"><a href="#第N个泰波那契" class="headerlink" title="第N个泰波那契"></a>第N个泰波那契</h3><h3 id="K和数对的最大数目"><a href="#K和数对的最大数目" class="headerlink" title="K和数对的最大数目"></a>K和数对的最大数目</h3><h3 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h3><h2 id="八股-32"><a href="#八股-32" class="headerlink" title="八股"></a>八股</h2><h3 id="回调函数改写成aysnc-await"><a href="#回调函数改写成aysnc-await" class="headerlink" title="回调函数改写成aysnc await"></a>回调函数改写成aysnc await</h3><h3 id="vue3的weakmap"><a href="#vue3的weakmap" class="headerlink" title="vue3的weakmap"></a>vue3的weakmap</h3><h3 id="从A页面到B页面的优化"><a href="#从A页面到B页面的优化" class="headerlink" title="从A页面到B页面的优化"></a>从A页面到B页面的优化</h3><ol><li>link标签，preload预加载资源，当页面使用该资源时候可以更快响应，也避免了资源加载和解析html冲突；prefetch未来可能用到的资源，网络线程空闲时候可以加载；dns-prefetch，提前解析域名(一是B页面写，二三是A页面写)。B页面 script标签的async defer</li><li>B页面http2.0，服务端主动推送</li><li>浏览器缓存</li><li>单页面应用，全局状态管理共享数据。</li><li>webpack代码分割</li><li>web worker 处理复杂操作</li></ol><h3 id="封装组件和正常写组件区别"><a href="#封装组件和正常写组件区别" class="headerlink" title="封装组件和正常写组件区别"></a>封装组件和正常写组件区别</h3><ol><li>复用性</li></ol><ul><li>props、事件、插槽实现复用，适合多个场景。</li></ul><ol start="2"><li>可维护性</li></ol><ul><li>集中处理逻辑修改</li></ul><ol start="3"><li>抽象性</li></ol><ul><li>封装的组件隐藏内部的细节，对外只提供接口功能。</li></ul><h3 id="如何封装一个组件"><a href="#如何封装一个组件" class="headerlink" title="如何封装一个组件"></a>如何封装一个组件</h3><ul><li>以成员选择器为例子。</li></ul><ol><li>确定组件的职责，展示的内容、交互的功能。</li><li>组件的输入：定义props文件有哪些数据，插槽（插入图标），事件的绑定与父组件通信。</li><li>提供默认值。</li><li>组件内部，请求成员数据，根据传入的参数。如何输出：输出到页面的内容+样式+交互输出的数据。</li><li>组件挂载是否要关闭定时器、关闭监听等等。</li></ol><h3 id="如何设计一个微前端框架"><a href="#如何设计一个微前端框架" class="headerlink" title="如何设计一个微前端框架"></a>如何设计一个微前端框架</h3><ul><li>（qiankun源码思路）微前端面对的两个共性问题，应用的加载和切换，应用的通信和隔离。</li></ul><ol><li>每个子应用有的挂载、卸载，首先可以定义他们的状态；</li><li>收集子应用注册的信息，加载的位置，以及触发加载的条件。</li><li>监听用户的操作、路由的变化每次去计算各个应用的状态，哪些要加载、哪些挂载、哪些卸载。</li><li>通信：全局事件总线、全局状态库、借助localStorage、indexDB等等。</li><li>隔离：js三种沙箱、css隔离。</li></ol><h3 id="滴滴三面"><a href="#滴滴三面" class="headerlink" title="滴滴三面"></a>滴滴三面</h3><h3 id="传音测评"><a href="#传音测评" class="headerlink" title="传音测评"></a>传音测评</h3><h1 id="3-20"><a href="#3-20" class="headerlink" title="3.20"></a>3.20</h1><h2 id="算法-33"><a href="#算法-33" class="headerlink" title="算法"></a>算法</h2><h3 id="拥有最多糖果的孩子"><a href="#拥有最多糖果的孩子" class="headerlink" title="拥有最多糖果的孩子"></a>拥有最多糖果的孩子</h3><h3 id="翻转元音字母"><a href="#翻转元音字母" class="headerlink" title="翻转元音字母"></a>翻转元音字母</h3><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><h3 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h3><h3 id="两数相加II"><a href="#两数相加II" class="headerlink" title="两数相加II"></a>两数相加II</h3><h3 id="链表翻转"><a href="#链表翻转" class="headerlink" title="链表翻转"></a>链表翻转</h3><h3 id="promisify"><a href="#promisify" class="headerlink" title="promisify"></a>promisify</h3><h2 id="八股-33"><a href="#八股-33" class="headerlink" title="八股"></a>八股</h2><h3 id="水滴笔试"><a href="#水滴笔试" class="headerlink" title="水滴笔试"></a>水滴笔试</h3><h1 id="3-21"><a href="#3-21" class="headerlink" title="3.21"></a>3.21</h1><h2 id="算法-34"><a href="#算法-34" class="headerlink" title="算法"></a>算法</h2><h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><h3 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h3><h3 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h3><h3 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h3><h3 id="重排链表-2"><a href="#重排链表-2" class="headerlink" title="重排链表"></a>重排链表</h3><ul><li>快慢指针，翻转链表，模拟。</li></ul><h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h3><h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h3><h3 id="a请求到后立马赋值，b请求到要等a赋值后再赋值。"><a href="#a请求到后立马赋值，b请求到要等a赋值后再赋值。" class="headerlink" title="a请求到后立马赋值，b请求到要等a赋值后再赋值。"></a>a请求到后立马赋值，b请求到要等a赋值后再赋值。</h3><h2 id="八股-34"><a href="#八股-34" class="headerlink" title="八股"></a>八股</h2><h3 id="git常见指令"><a href="#git常见指令" class="headerlink" title="git常见指令"></a>git常见指令</h3><h3 id="git如何解决冲突-1"><a href="#git如何解决冲突-1" class="headerlink" title="git如何解决冲突"></a>git如何解决冲突</h3><h3 id="git如何回滚-1"><a href="#git如何回滚-1" class="headerlink" title="git如何回滚"></a>git如何回滚</h3><h3 id="git-merge、git-rebase区别"><a href="#git-merge、git-rebase区别" class="headerlink" title="git merge、git rebase区别"></a>git merge、git rebase区别</h3><h3 id="xss、csrf攻击"><a href="#xss、csrf攻击" class="headerlink" title="xss、csrf攻击"></a>xss、csrf攻击</h3><ul><li>xss攻击：避免使用innerHTML。</li></ul><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><ul><li>缓存位置有内存和磁盘。页面刷新可以从内存和磁盘中获取，页面关闭再打开都从磁盘取。</li><li>css文件一般不会变，会存到内存中。</li></ul><h3 id="cache-control缓存字段"><a href="#cache-control缓存字段" class="headerlink" title="cache-control缓存字段"></a>cache-control缓存字段</h3><h3 id="浏览器组成-2"><a href="#浏览器组成-2" class="headerlink" title="浏览器组成"></a>浏览器组成</h3><ol><li>用户界面、浏览器主引擎、渲染引擎、js引擎、网络、数据存储。</li></ol><h3 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h3><ol><li>渲染树只包括要展示的节点，像<code>&lt;head&gt;、&lt;script&gt;</code>不会在渲染树中。</li></ol><h1 id="3-22"><a href="#3-22" class="headerlink" title="3.22"></a>3.22</h1><h2 id="算法-35"><a href="#算法-35" class="headerlink" title="算法"></a>算法</h2><h3 id="LRU缓存-1"><a href="#LRU缓存-1" class="headerlink" title="LRU缓存"></a>LRU缓存</h3><h3 id="从前序遍历和中序遍历构建二叉树"><a href="#从前序遍历和中序遍历构建二叉树" class="headerlink" title="从前序遍历和中序遍历构建二叉树"></a>从前序遍历和中序遍历构建二叉树</h3><h3 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h3><h3 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h3><h3 id="删除字符串中的相邻重复项"><a href="#删除字符串中的相邻重复项" class="headerlink" title="删除字符串中的相邻重复项"></a>删除字符串中的相邻重复项</h3><h3 id="每隔千分位小数点"><a href="#每隔千分位小数点" class="headerlink" title="每隔千分位小数点"></a>每隔千分位小数点</h3><h3 id="删除一个元素后全为1的最长子数组"><a href="#删除一个元素后全为1的最长子数组" class="headerlink" title="删除一个元素后全为1的最长子数组"></a>删除一个元素后全为1的最长子数组</h3><h2 id="八股-35"><a href="#八股-35" class="headerlink" title="八股"></a>八股</h2><p>&#x2F;&#x2F; 复习，并把问题扔给deepseek看能不能学新东西，要活跃脑子。</p><ul><li>浏览器原理</li><li>计算机网络、操作系统</li><li>Ts</li></ul><h3 id="如何优化浏览器渲染过程"><a href="#如何优化浏览器渲染过程" class="headerlink" title="如何优化浏览器渲染过程"></a>如何优化浏览器渲染过程</h3><ol><li>js: script标签写在body后面. 用async和defer.</li><li>css:用link引入,开启一个线程去加载,不阻塞GUI渲染线程. @import:GUI线程会停止渲染去加载资源. css少的话就写在style标签中直接GUI渲染.</li><li>vue，虚拟DOM，diff算法，减少对真实DOM的操作次数。</li><li>事件委托：减少事件处理器的数量。</li><li>网络：http2.0并发请求、主动推送、缓存。</li><li>webpack：模块拆分、压缩代码。</li><li>虚拟列表、按需加载。</li></ol><!-- 3. html:减少嵌套层次,减少回流重绘操作 --><h3 id="如何减少回流重绘"><a href="#如何减少回流重绘" class="headerlink" title="如何减少回流重绘"></a>如何减少回流重绘</h3><ol><li>操作低层次的DOM.</li><li>脱离文档流,减少对其他元素影响.</li><li>将DOM读写操作分别放到一起,浏览器的渲染队列机制.</li><li>一些css属性形成新的合成层: transform,opacity等等.浏览器把这些变化交给GPU处理(不是所有合成层都给GPU,只有动画视觉效果时候交给GPU),GPU直接在显存中更改元素显示位置,无需CPU进行布局绘制的计算.</li><li>不要使用table布局，一个小的改动可能导致整个table重新布局。</li><li><strong>documentFragment</strong>：避免频繁操作DOM，可以创建一个文档片段documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中</li></ol><h3 id="DocumentFragments-10024-2"><a href="#DocumentFragments-10024-2" class="headerlink" title="DocumentFragments &#10024;"></a>DocumentFragments &#10024;</h3><ul><li>轻量级、批量操作DOM元素，临时存储的容器。</li><li>DocumentFragments存在于内存中，不是主 DOM 树的一部分，将子元素插入到文档片段时不会引起页面回流。通常的用例是创建文档片段，元素附加到文档片段，然后将文档片段附加到 DOM 树。</li></ul><h3 id="为什么有宏任务队列和微任务队列两个？"><a href="#为什么有宏任务队列和微任务队列两个？" class="headerlink" title="为什么有宏任务队列和微任务队列两个？"></a>为什么有宏任务队列和微任务队列两个？</h3><ul><li>控制任务的优先级，微任务优先级别更高。</li></ul><h3 id="301、302状态码浏览器处理"><a href="#301、302状态码浏览器处理" class="headerlink" title="301、302状态码浏览器处理"></a>301、302状态码浏览器处理</h3><ul><li>301永久重定向，浏览器会缓存重定向的url，后续请求直接请求新的url。</li><li>302临时重定向，浏览器不会缓存结果，每次还是先请求原始URL，根据结果处理。</li></ul><h3 id="BFC-1"><a href="#BFC-1" class="headerlink" title="BFC"></a>BFC</h3><ul><li>display：flow-root；</li></ul><h3 id="复习浏览器原理"><a href="#复习浏览器原理" class="headerlink" title="复习浏览器原理"></a>复习浏览器原理</h3><h3 id="复习Ts"><a href="#复习Ts" class="headerlink" title="复习Ts"></a>复习Ts</h3><h1 id="3-23"><a href="#3-23" class="headerlink" title="3.23"></a>3.23</h1><h2 id="算法-36"><a href="#算法-36" class="headerlink" title="算法"></a>算法</h2><h3 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h3><h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h3><h3 id="子数组最大平均数I"><a href="#子数组最大平均数I" class="headerlink" title="子数组最大平均数I"></a>子数组最大平均数I</h3><h3 id="定长子串元音的最大数目"><a href="#定长子串元音的最大数目" class="headerlink" title="定长子串元音的最大数目"></a>定长子串元音的最大数目</h3><h3 id="合并两个有序链表-1"><a href="#合并两个有序链表-1" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><h3 id="有序数组转换为二叉搜索树"><a href="#有序数组转换为二叉搜索树" class="headerlink" title="有序数组转换为二叉搜索树"></a>有序数组转换为二叉搜索树</h3><h3 id="数组扁平化五种"><a href="#数组扁平化五种" class="headerlink" title="数组扁平化五种"></a>数组扁平化五种</h3><h3 id="js手写全选"><a href="#js手写全选" class="headerlink" title="js手写全选"></a>js手写全选</h3><h3 id="js手写todos"><a href="#js手写todos" class="headerlink" title="js手写todos"></a>js手写todos</h3><h2 id="八股-36"><a href="#八股-36" class="headerlink" title="八股"></a>八股</h2><h3 id="http1-0和1-1区别"><a href="#http1-0和1-1区别" class="headerlink" title="http1.0和1.1区别"></a>http1.0和1.1区别</h3><ul><li>更多状态码，可以处理更多错误</li></ul><h3 id="http1-1的优化"><a href="#http1-1的优化" class="headerlink" title="http1.1的优化"></a>http1.1的优化</h3><ol><li>浏览器缓存</li><li>按需请求</li><li>请求压缩</li></ol><h3 id="https优化-1"><a href="#https优化-1" class="headerlink" title="https优化"></a>https优化</h3><ol><li>tls1.2 &#x3D;》1.3，第三次握手后就可以通信，升级到ECDHE算法：支持前向保密。</li><li>验证证书有效性：不要让客户端去轮询问CA有效性，由服务端请求证书有效性并且用CA加密，让服务端无法篡改，再发送给客户端。</li><li>会话复用：类似sesstion、token的机制。</li></ol><h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><ul><li>攻击者只能得到公钥（包括大整数和另一个随机数），无法得到欧拉函数，而计算私钥需要欧拉函数和公钥，我们很难将大整数拆成两个随机数去计算欧拉函数。</li></ul><h3 id="ECDHE算法"><a href="#ECDHE算法" class="headerlink" title="ECDHE算法"></a>ECDHE算法</h3><ul><li>椭圆曲线可以是x轴对称，找到切线切点p，与椭圆曲线还有个交点（一般是三个交点，切线就两个交点）的x轴对称位置就是2p。</li><li>我们很容易用p推出6p，但很难用6p推出p（相当于房间的皮球踢出去后很难复原他的轨迹路线）。</li></ul><h3 id="quic协议如何确保可靠性"><a href="#quic协议如何确保可靠性" class="headerlink" title="quic协议如何确保可靠性"></a>quic协议如何确保可靠性</h3><ol><li><strong>递增、乱序确认</strong>：每个请求报文的id都是递增的，即使是重传的也是递增的（和之前的不一样），服务端可以<strong>乱序确认</strong>，滑动窗口后移，解决了队头阻塞。</li><li><strong>streamID + 偏移量</strong>：确保数据的有序性，每个数据虽然重传后id不一样，但偏移量是不变的。</li></ol><h3 id="赛马问题"><a href="#赛马问题" class="headerlink" title="赛马问题"></a>赛马问题</h3><h3 id="8L水杯、6L水杯如何倒出4L水杯"><a href="#8L水杯、6L水杯如何倒出4L水杯" class="headerlink" title="8L水杯、6L水杯如何倒出4L水杯"></a>8L水杯、6L水杯如何倒出4L水杯</h3><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><h1 id="3-24"><a href="#3-24" class="headerlink" title="3.24"></a>3.24</h1><h2 id="算法-37"><a href="#算法-37" class="headerlink" title="算法"></a>算法</h2><h3 id="最大连续1的个数"><a href="#最大连续1的个数" class="headerlink" title="最大连续1的个数"></a>最大连续1的个数</h3><h3 id="删除一个元素后全为1的最长子数组-1"><a href="#删除一个元素后全为1的最长子数组-1" class="headerlink" title="删除一个元素后全为1的最长子数组"></a>删除一个元素后全为1的最长子数组</h3><h3 id="二叉搜索树中第K大的数"><a href="#二叉搜索树中第K大的数" class="headerlink" title="二叉搜索树中第K大的数"></a>二叉搜索树中第K大的数</h3><h3 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h3><h3 id="01背包四个问题"><a href="#01背包四个问题" class="headerlink" title="01背包四个问题"></a>01背包四个问题</h3><h3 id="虚拟DOM转换为真实DOM"><a href="#虚拟DOM转换为真实DOM" class="headerlink" title="虚拟DOM转换为真实DOM"></a>虚拟DOM转换为真实DOM</h3><h2 id="八股-37"><a href="#八股-37" class="headerlink" title="八股"></a>八股</h2><ul><li>webpack、vite，项目亮点，面经。</li></ul><h3 id="盒子模型-1"><a href="#盒子模型-1" class="headerlink" title="盒子模型"></a>盒子模型</h3><ul><li>IE盒子模型的width、<strong>height</strong>都会包含三个。</li></ul><h3 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h3><ul><li>必须设置偏移量才有效</li></ul><h3 id="虚拟内存-1"><a href="#虚拟内存-1" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h3 id="讲讲ts是怎么转化为js的？使用什么工具"><a href="#讲讲ts是怎么转化为js的？使用什么工具" class="headerlink" title="讲讲ts是怎么转化为js的？使用什么工具"></a>讲讲ts是怎么转化为js的？使用什么工具</h3><ol><li>ts-loader：调用的tsc工具（TypeScript 编译器），完整编译流程，包括类型检查和语法转换。</li><li>babel：Babel 仅移除类型注解并转换语法，不会进行类型检查。</li></ol><h3 id="babel原理是什么"><a href="#babel原理是什么" class="headerlink" title="babel原理是什么"></a>babel原理是什么</h3><ul><li>babel原理：解析生成AST语法树，语法树进行转换，生成js的语法树，生成js代码。类型注释，接口，类型别名移出掉，枚举转换为立即执行函数生成的对象。<br>（ts类型检测是静态的，只在开发阶段有效，编译后的js不再有类型检测）</li></ul><h3 id="bundle、chunk"><a href="#bundle、chunk" class="headerlink" title="bundle、chunk"></a>bundle、chunk</h3><h3 id="css复习"><a href="#css复习" class="headerlink" title="css复习"></a>css复习</h3><h3 id="webpack、vite复习"><a href="#webpack、vite复习" class="headerlink" title="webpack、vite复习"></a>webpack、vite复习</h3><h3 id="如何封装一个组件-1"><a href="#如何封装一个组件-1" class="headerlink" title="如何封装一个组件"></a>如何封装一个组件</h3><h3 id="如何设计一个微前端"><a href="#如何设计一个微前端" class="headerlink" title="如何设计一个微前端"></a>如何设计一个微前端</h3><ul><li>就说single-spa的源码</li></ul><h3 id="js字符占多少字节"><a href="#js字符占多少字节" class="headerlink" title="js字符占多少字节"></a>js字符占多少字节</h3><ul><li>utf16编码，大部分是两个字节，小部分是四个字节。</li><li>1B（字节）&#x3D; 8b（位）</li><li>1KB &#x3D; 2的10次方B</li></ul><h3 id="如何快速判断几十个数中存在某个数"><a href="#如何快速判断几十个数中存在某个数" class="headerlink" title="如何快速判断几十个数中存在某个数"></a>如何快速判断几十个数中存在某个数</h3><p><a href="https://www.bilibili.com/video/BV1yvBKYoEnt/?spm_id_from=333.1007.tianma.1-2-2.click&vd_source=9b9c9c2844427b792423aada902b836b">https://www.bilibili.com/video/BV1yvBKYoEnt/?spm_id_from=333.1007.tianma.1-2-2.click&amp;vd_source=9b9c9c2844427b792423aada902b836b</a></p><h1 id="3-25"><a href="#3-25" class="headerlink" title="3.25"></a>3.25</h1><h2 id="算法-38"><a href="#算法-38" class="headerlink" title="算法"></a>算法</h2><h3 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a>零钱兑换II</h3><ul><li>求几种方法，dp[j] +&#x3D; dp[j - nums[i]]</li></ul><h3 id="组合总和IV"><a href="#组合总和IV" class="headerlink" title="组合总和IV"></a>组合总和IV</h3><ul><li>求几种排列，dp[j] +&#x3D; dp[j - nums[i]]</li><li>物品在里面遍历是排列数，在外面是组合数。</li></ul><h3 id="零钱兑换-1"><a href="#零钱兑换-1" class="headerlink" title="零钱兑换"></a>零钱兑换</h3><ul><li>求几个钱，dp[j] &#x3D; Math.min(dp[j - nums[i]] + 1, dp[j]);</li></ul><h3 id="完全平方数-1"><a href="#完全平方数-1" class="headerlink" title="完全平方数"></a>完全平方数</h3><ul><li>求几个数 dp[j] &#x3D; Math.min(dp[j], dp[j - i * i] + 1);</li></ul><h3 id="单词拆分-1"><a href="#单词拆分-1" class="headerlink" title="单词拆分"></a>单词拆分</h3><ul><li>完全背包</li></ul><h2 id="八股-38"><a href="#八股-38" class="headerlink" title="八股"></a>八股</h2><h3 id="JWT鉴权机制，JWT和传统token有什么区别"><a href="#JWT鉴权机制，JWT和传统token有什么区别" class="headerlink" title="JWT鉴权机制，JWT和传统token有什么区别"></a>JWT鉴权机制，JWT和传统token有什么区别</h3><ul><li>jwt三部分组成，第三部分会用密钥加密签名，因为签名不可破解，服务端不用存储额外用户信息而是存到jwt中，将用户信息存到客户端。服务端只需用密钥解密认证即可。</li><li>传统token（就是session）是随机字符串，不能存放信息，用户信息存到服务端</li></ul><h3 id="传统token和session区别"><a href="#传统token和session区别" class="headerlink" title="传统token和session区别"></a>传统token和session区别</h3><ul><li>sessionid对应一个用户信息</li><li>传统token只是在后端有一个白名单列表（是轻量级session）</li></ul><h3 id="es新特性代替hasOwnProperty"><a href="#es新特性代替hasOwnProperty" class="headerlink" title="es新特性代替hasOwnProperty"></a>es新特性代替hasOwnProperty</h3><ul><li>Object.hasOwn，防止hasOwnProperty被替代。</li></ul><h3 id="如果让你实现一个打包工具怎么实现"><a href="#如果让你实现一个打包工具怎么实现" class="headerlink" title="如果让你实现一个打包工具怎么实现"></a>如果让你实现一个打包工具怎么实现</h3><ul><li>打包工具是什么？打包工具是把多个模块整合成一个或多个优化后的文件，解决模块化和浏览器兼容的问题。</li></ul><ol><li>找到入口文件，生成AST语法树，识别模块导入语句。</li><li>将模块转换，AST语法树转换成浏览器可以识别的文件。</li><li>最后输出：做tree-shaking，代码压缩等优化。</li></ol><h3 id="i18n如何实现的国际化有了解吗？"><a href="#i18n如何实现的国际化有了解吗？" class="headerlink" title="i18n如何实现的国际化有了解吗？"></a>i18n如何实现的国际化有了解吗？</h3><ul><li>根据入参：当前是哪个地区，有键值对映射关系转换。</li><li>高级转换：复数、时间转换</li></ul><h3 id="JSON实现深拷贝的缺点，如何解决"><a href="#JSON实现深拷贝的缺点，如何解决" class="headerlink" title="JSON实现深拷贝的缺点，如何解决"></a>JSON实现深拷贝的缺点，如何解决</h3><ul><li>循环引用、原型链不会转换</li><li>函数、symbol、undefined、不可遍历属性不会转换，NaN转换为null。</li><li>解决：自己实现，特判。</li></ul><h1 id="3-26"><a href="#3-26" class="headerlink" title="3.26"></a>3.26</h1><h2 id="算法-39"><a href="#算法-39" class="headerlink" title="算法"></a>算法</h2><h2 id="八股-39"><a href="#八股-39" class="headerlink" title="八股"></a>八股</h2><h3 id="属性选择器、元素选择器"><a href="#属性选择器、元素选择器" class="headerlink" title="属性选择器、元素选择器"></a>属性选择器、元素选择器</h3><ol><li>[data-qiankun &#x3D; “xxx”]、<code>[data](所有有data属性都会被选)</code></li><li>div（直接写元素名）</li></ol><h3 id="display-flex后发生什么"><a href="#display-flex后发生什么" class="headerlink" title="display:flex后发生什么"></a>display:flex后发生什么</h3><ul><li>justify-content默认值是flex-start，align-items默认值是stretch。</li></ul><ol><li>水平排列</li><li>默认不换行</li><li>默认高度会拉伸</li></ol><h3 id="Promise并发请求"><a href="#Promise并发请求" class="headerlink" title="Promise并发请求"></a>Promise并发请求</h3><ul><li>Promise.all（要全成功）、Promise.any（有一个成功就返回）、Promise.allSettled（要全落定）</li></ul><h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><ol><li>props、emits</li><li>provide、inject</li><li>全局事件总线</li><li>全局状态管理</li><li>Storage、cookie</li><li>ref</li></ol><h3 id="commonjs和esm模块化循环依赖如何处理"><a href="#commonjs和esm模块化循环依赖如何处理" class="headerlink" title="commonjs和esm模块化循环依赖如何处理"></a>commonjs和esm模块化循环依赖如何处理</h3><ol><li>commonjs是同步加载，模块加载后会缓存，遇到循环依赖时候 会返回已经执行部分的模块导出，未执行的就是undefined或初始值。</li><li>esm模块化有编译时分析，提前给所有导出的变量创建空位，导入是动态绑定的，后续加载完后再补充之前的值。</li></ol><h3 id="vue优点"><a href="#vue优点" class="headerlink" title="vue优点"></a>vue优点</h3><ol><li><em><strong>声明式框架</strong></em>：响应式原理</li><li><em><strong>虚拟DOM</strong></em>：第一：diff算法。第二：支持跨平台，服务端渲染、浏览器渲染，将虚拟DOM转换为真实HTML元素。</li><li><em><strong>区分编译时和运行时</strong></em>：<br>编译时：将<strong>模板</strong>变成js语法渲染函数生成的<strong>虚拟DOM</strong>；<br>运行时：上线时只走运行时。</li><li><em><strong>拥抱Ts</strong></em></li></ol><h3 id="网易一面"><a href="#网易一面" class="headerlink" title="网易一面"></a>网易一面</h3><h3 id="滴滴oc"><a href="#滴滴oc" class="headerlink" title="滴滴oc"></a>滴滴oc</h3><h1 id="3-27"><a href="#3-27" class="headerlink" title="3.27"></a>3.27</h1><h2 id="算法-40"><a href="#算法-40" class="headerlink" title="算法"></a>算法</h2><h3 id="手写单例模式"><a href="#手写单例模式" class="headerlink" title="手写单例模式"></a>手写单例模式</h3><h3 id="寻找数组的中心下标"><a href="#寻找数组的中心下标" class="headerlink" title="寻找数组的中心下标"></a>寻找数组的中心下标</h3><h3 id="独一无二的出现次数"><a href="#独一无二的出现次数" class="headerlink" title="独一无二的出现次数"></a>独一无二的出现次数</h3><h2 id="八股-40"><a href="#八股-40" class="headerlink" title="八股"></a>八股</h2><h3 id="vuex-和pinia区别"><a href="#vuex-和pinia区别" class="headerlink" title="vuex 和pinia区别?"></a>vuex 和pinia区别?</h3><ol><li>pinia是采用ts编写,类型提示友好.体积小,使用简单.</li><li>去除mutations. state,getters,actions(包括同步和异步)</li><li>pinia支持compositionApi,也支持optionsAPI</li><li>核心: 一: vuex定义的模块为树结构,如果读取里层模块数据则操作不便.<br>二: 并且在底层会将所有模块定义到根模块,可能出现模块状态覆盖根状态.<br>三: 只能定义一个vuex,单例模式,pinia定义多个store.store之间可以调用,扁平化结构,不用担心命名冲突问题.</li></ol><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h3 id="监听者模式"><a href="#监听者模式" class="headerlink" title="监听者模式"></a>监听者模式</h3><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><h1 id="3-28"><a href="#3-28" class="headerlink" title="3.28"></a>3.28</h1><h2 id="算法-41"><a href="#算法-41" class="headerlink" title="算法"></a>算法</h2><h3 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h3><h3 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h3><h3 id="美团二面"><a href="#美团二面" class="headerlink" title="美团二面"></a>美团二面</h3><h2 id="八股-41"><a href="#八股-41" class="headerlink" title="八股"></a>八股</h2><h1 id="3-29"><a href="#3-29" class="headerlink" title="3.29"></a>3.29</h1><h2 id="算法确定两个字符串是否接近"><a href="#算法确定两个字符串是否接近" class="headerlink" title="算法确定两个字符串是否接近"></a>算法确定两个字符串是否接近</h2><ul><li>hash</li></ul><h1 id="3-30"><a href="#3-30" class="headerlink" title="3.30"></a>3.30</h1><h2 id="算法-42"><a href="#算法-42" class="headerlink" title="算法"></a>算法</h2><h3 id="相等行列对"><a href="#相等行列对" class="headerlink" title="相等行列对"></a>相等行列对</h3><h3 id="从字符串中删除星号"><a href="#从字符串中删除星号" class="headerlink" title="从字符串中删除星号"></a>从字符串中删除星号</h3><ul><li>栈：后进先出的特点。</li></ul><h3 id="小行星碰撞"><a href="#小行星碰撞" class="headerlink" title="小行星碰撞"></a>小行星碰撞</h3><ul><li>栈：要思考特性。</li></ul><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><h1 id="3-31"><a href="#3-31" class="headerlink" title="3.31"></a>3.31</h1><h2 id="算法-43"><a href="#算法-43" class="headerlink" title="算法"></a>算法</h2><h3 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h3><h3 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h3><ul><li>switch语法</li><li>Math.trunc， | 0，去掉小数不分。</li></ul><!--20万人同时直播间打赏前端有什么优化点（只说了两个）### 计时器，倒计时组件  如何快速判断几十亿个数中存在某个数https://www.bilibili.com/video/BV1yvBKYoEnt/?spm_id_from=333.1007.tianma.1-2-2.click&vd_source=9b9c9c2844427b792423aada902b836b// intersectionobserverhttps://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.htmlrequestIdCallback使用MDN例子https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_APIdocument.querySelector的时间复杂度Vue diff算法使用key的时间复杂度deepseek搜，问过了。延时队列、交互队列、微队列。宏任务拆分成了延时队列和交互队列。 -->]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大四寒假学习记录</title>
    <link href="/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2.%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2.%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="寒假目标"><a href="#寒假目标" class="headerlink" title="寒假目标"></a>寒假目标</h1><ol><li>算法：leetcode刷到200+,代码随想录刷完二叉树、贪心。&#9989;<br>加任务：leetcode刷到220+，代码随想录刷完二叉树贪心后刷回溯和动态规划。&#9989;<br>调整任务：后面每天复习三十分钟-50分钟、刷四五道题目。&#9989;<br>加任务：开学前刷完动态规划和回溯。<br>回溯刷完了，动态规划到完全背包问题。</li><li>css、js、vue、webpackvite。 &#10060;</li></ol><ul><li>总结：算法提升了很多，八股遗忘了。问题不大，开学后补八股，保持算法，加油。</li></ul><hr><p>css  &#9989;</p><p>js：基础、代码输出题、手写题。</p><p>vue：源码、八股。</p><p>ts：八股、手写。</p><p>webpack、vite：八股。</p><p>git：八股。</p><p>计算机网络</p><p>操作系统</p><p>算法 + 手写 &#9989;</p><p>浏览器原理</p><p>微前端：准备看源码 &#9989;</p><hr><h1 id="2025-1-9"><a href="#2025-1-9" class="headerlink" title="2025.1.9"></a>2025.1.9</h1><h2 id="01背包问题基础"><a href="#01背包问题基础" class="headerlink" title="01背包问题基础"></a>01背包问题基础</h2><ol><li>二维：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + weight[i]);<br></code></pre></td></tr></table></figure><ol start="2"><li>一维：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dp[j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[j],dp[j - weight[i]] + weight[i]);<br></code></pre></td></tr></table></figure><h2 id="数组翻译成字符串"><a href="#数组翻译成字符串" class="headerlink" title="数组翻译成字符串"></a>数组翻译成字符串</h2><h2 id="礼物得最大价值"><a href="#礼物得最大价值" class="headerlink" title="礼物得最大价值"></a>礼物得最大价值</h2><h2 id="丑数1"><a href="#丑数1" class="headerlink" title="丑数1"></a>丑数1</h2><h1 id="2025-1-10"><a href="#2025-1-10" class="headerlink" title="2025.1.10"></a>2025.1.10</h1><h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><h2 id="第一次只出现一次的数字"><a href="#第一次只出现一次的数字" class="headerlink" title="第一次只出现一次的数字"></a>第一次只出现一次的数字</h2><ul><li>lastIndexOf、 indexOf</li></ul><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="两个链表的公共节点"><a href="#两个链表的公共节点" class="headerlink" title="两个链表的公共节点"></a>两个链表的公共节点</h2><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h2 id="single-spa进行了总结"><a href="#single-spa进行了总结" class="headerlink" title="single-spa进行了总结"></a>single-spa进行了总结</h2><h2 id="qiankun使用"><a href="#qiankun使用" class="headerlink" title="qiankun使用"></a>qiankun使用</h2><ol><li>主应用注册子应用</li><li>子应用暴露接口协议</li><li>public-path.js：改变静态资源路径为子应用ip地址，默认会是父应用ip地址导致静态资源无法加载。</li><li>挂载位置：子应用挂载到app，根应用也是app的div，这时候需要限制查找范围。props参数有个container属性是dom元素。主应用的html下面有一个container div，container div上挂载子应用的html，子应用html有app。</li><li>webpack打包格式为umd格式</li><li>除了微前端启动，还有正常启动，qiankun会在window放个全局属性powerbyqiankun没有的话直接调render函数就好。</li></ol><h2 id="js沙箱"><a href="#js沙箱" class="headerlink" title="js沙箱"></a>js沙箱</h2><ol><li>快照沙箱</li><li>单实例</li><li>多实例沙箱</li></ol><h2 id="css样式隔离"><a href="#css样式隔离" class="headerlink" title="css样式隔离"></a>css样式隔离</h2><h1 id="1-11"><a href="#1-11" class="headerlink" title="1.11"></a>1.11</h1><h2 id="异或两道题"><a href="#异或两道题" class="headerlink" title="异或两道题"></a>异或两道题</h2><h2 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h2><h2 id="和为s的连续数字"><a href="#和为s的连续数字" class="headerlink" title="和为s的连续数字"></a>和为s的连续数字</h2><h2 id="双指针总结"><a href="#双指针总结" class="headerlink" title="双指针总结"></a>双指针总结</h2><ul><li>双指针有两种类型，一种是left &#x3D; 0;right &#x3D; arr.length; while(left &lt; right)</li><li>另一种是： left &#x3D; 0, right &#x3D; 1; while(right &lt; arr.length)</li></ul><h2 id="字符串trim方法"><a href="#字符串trim方法" class="headerlink" title="字符串trim方法"></a>字符串trim方法</h2><ul><li>去除前后的空格</li></ul><h1 id="1-12"><a href="#1-12" class="headerlink" title="1.12"></a>1.12</h1><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><h2 id="翻转字符串"><a href="#翻转字符串" class="headerlink" title="翻转字符串"></a>翻转字符串</h2><h2 id="在排序数组中查找数字I"><a href="#在排序数组中查找数字I" class="headerlink" title="在排序数组中查找数字I"></a>在排序数组中查找数字I</h2><h2 id="0-n-1-中缺失的数字"><a href="#0-n-1-中缺失的数字" class="headerlink" title="0 - (n-1) 中缺失的数字"></a>0 - (n-1) 中缺失的数字</h2><h2 id="二分法-9997"><a href="#二分法-9997" class="headerlink" title="二分法 &#9997;"></a>二分法 &#9997;</h2><ul><li>二分法前提：有序的数组，将时间复杂度从n降到logn。</li><li>左闭右闭：right初始化为length - 1，left &lt;&#x3D; right（因为<code>[1,1]</code>是合法的），right &#x3D; mid - 1，right是循环在内的，不应该再考虑。</li><li>左闭右开：right初始化为length，left &lt; right（因为<code>[1,1)</code>是不合法的），right &#x3D; mid，right是循环不在内的。</li></ul><h2 id="import-html-entry"><a href="#import-html-entry" class="headerlink" title="import-html-entry"></a>import-html-entry</h2><ul><li><a href="https://blog.csdn.net/qq_41800366/article/details/122093720">https://blog.csdn.net/qq_41800366/article/details/122093720</a></li></ul><ol><li><strong>fetch拉取html文件</strong>：通过fetch获取url对应的html内容。</li><li><strong>html正则处理</strong>： html里面js（外联、页内）都被注释掉并保存起来；css页面内的style不动，外联css注释掉保存起来；</li><li><strong>拉取css，style插入</strong>：fetch获取外联css，通过style标签加入到html中。</li><li><strong>拉取js并在沙箱执行</strong>：拉取外联js、页面js直接返回，jscode包裹在一个函数中，做沙箱隔离。并且执行。</li><li><strong>返回html和js</strong>：返回 <em>template：html模板</em> 和 <em>execScripts：执行所有js的函数</em></li></ol><h2 id="qiankun源码"><a href="#qiankun源码" class="headerlink" title="qiankun源码"></a>qiankun源码</h2><ol><li>预加载，single-spa第一个应用加载完后派发事件；监听事件通过import-html-entry在浏览器每一帧的空闲时间执行。</li><li>沙箱：真正加载时候，处理css模板，处理js沙箱。</li></ol><h1 id="1-13-1-14-休息"><a href="#1-13-1-14-休息" class="headerlink" title="1.13 1.14 休息"></a>1.13 1.14 休息</h1><h1 id="1-15"><a href="#1-15" class="headerlink" title="1.15"></a>1.15</h1><h2 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a>队列的最大值</h2><ul><li>维护一个单调递减的队列</li><li>前面小的值不用留着了</li></ul><h2 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a>n个骰子的点数</h2><ul><li>回溯超时</li><li>动态规划，二维dp，第一个下标表示第几个骰子，第二个下标表示<code>当前骰子</code>的点数</li></ul><h2 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h2><h2 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a>圆圈中最后剩下的数字</h2><h2 id="整理所有微前端"><a href="#整理所有微前端" class="headerlink" title="整理所有微前端"></a>整理所有微前端</h2><h3 id="single-spa源码"><a href="#single-spa源码" class="headerlink" title="single-spa源码"></a>single-spa源码</h3><h3 id="qiankun实战六点"><a href="#qiankun实战六点" class="headerlink" title="qiankun实战六点"></a>qiankun实战六点</h3><h3 id="qiankun源码：预加载、html-entry"><a href="#qiankun源码：预加载、html-entry" class="headerlink" title="qiankun源码：预加载、html-entry"></a>qiankun源码：预加载、html-entry</h3><h3 id="css样式隔离、js沙箱"><a href="#css样式隔离、js沙箱" class="headerlink" title="css样式隔离、js沙箱"></a>css样式隔离、js沙箱</h3><h2 id="找数组中的值find、findIndex、indexOf"><a href="#找数组中的值find、findIndex、indexOf" class="headerlink" title="找数组中的值find、findIndex、indexOf"></a>找数组中的值find、findIndex、indexOf</h2><ul><li>前两个是要函数，后一个是元素</li></ul><ol><li>find：arr.find((value)&#x3D;&gt; value &gt; 10) 返回第一个大于10的数</li><li>findIndex，同find用法，但返回的是下标</li><li><strong>indexOf</strong>：arr.indexOf(‘cc’)，数组中第一个出现给定元素的下标。</li><li><strong>lastIndexOf</strong>:</li></ol><h2 id="贪心算法基础"><a href="#贪心算法基础" class="headerlink" title="贪心算法基础"></a>贪心算法基础</h2><ul><li>局部最优可以推出全局最优</li></ul><h2 id="买卖股票最佳时机1、2"><a href="#买卖股票最佳时机1、2" class="headerlink" title="买卖股票最佳时机1、2"></a>买卖股票最佳时机1、2</h2><h1 id="1-16"><a href="#1-16" class="headerlink" title="1.16"></a>1.16</h1><h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><h2 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h2><h2 id="短路运算"><a href="#短路运算" class="headerlink" title="短路运算"></a>短路运算</h2><h2 id="二分法-四道题"><a href="#二分法-四道题" class="headerlink" title="二分法 四道题"></a>二分法 四道题</h2><h2 id="移动元素"><a href="#移动元素" class="headerlink" title="移动元素"></a>移动元素</h2><h1 id="1-17"><a href="#1-17" class="headerlink" title="1.17"></a>1.17</h1><h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><h2 id="删除有序数组的重复项"><a href="#删除有序数组的重复项" class="headerlink" title="删除有序数组的重复项"></a>删除有序数组的重复项</h2><h2 id="选择器优先级-10024"><a href="#选择器优先级-10024" class="headerlink" title="选择器优先级 &#10024;"></a>选择器优先级 &#10024;</h2><ol><li>！important</li><li>内联样式：style&#x3D; “color: red”</li><li>id选择器：#</li><li>类、伪类、属性选择器</li><li>元素（标签）、伪元素选择器。</li><li>通配符、子代后代选择器</li></ol><ul><li>额外点：</li></ul><ol><li>优先级相同时候，后定义的生效。</li><li>内联样式 》 内部样式 》 外部样式 》 浏览器默认样式</li><li>优先级高的生效。</li></ol><h2 id="可-不可继承属性"><a href="#可-不可继承属性" class="headerlink" title="可&#x2F;不可继承属性"></a>可&#x2F;不可继承属性</h2><ol><li>可：font-size、font-weight、font-family、文本color、visibility</li><li>不可：盒子模型、display、background、定位。</li></ol><h2 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h2><ol><li>none、block、inline、inline-block、inherit.</li></ol><h2 id="block、inline、inline-block区别"><a href="#block、inline、inline-block区别" class="headerlink" title="block、inline、inline-block区别"></a>block、inline、inline-block区别</h2><ul><li>是否独占一行、是否可以设置宽高、宽度是否会充满父元素。</li></ul><h2 id="display、visibility、opacity区别"><a href="#display、visibility、opacity区别" class="headerlink" title="display、visibility、opacity区别"></a>display、visibility、opacity区别</h2><ol><li>display：none：不会出现在渲染树中，不会触发事件，触发回流重绘。</li><li>visibility：hidden：在页面中，不触发事件，重绘。</li><li>opacity：0：透明度，在页面中，触发事件，单独抽离出合成层，利用GPU加速渲染。</li></ol><h2 id="link和-import区别"><a href="#link和-import区别" class="headerlink" title="link和@import区别"></a>link和@import区别</h2><ul><li>用link引入,开启一个线程去加载,不阻塞GUI渲染线程. @import:GUI线程会停止渲染去加载资源. css少的话就写在style标签中直接GUI渲染.</li></ul><h1 id="1-18"><a href="#1-18" class="headerlink" title="1.18"></a>1.18</h1><h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h2><h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><h2 id="水果成篮"><a href="#水果成篮" class="headerlink" title="水果成篮"></a>水果成篮</h2><h2 id="螺旋矩阵2"><a href="#螺旋矩阵2" class="headerlink" title="螺旋矩阵2"></a>螺旋矩阵2</h2><ul><li>为什么还要if？<br>如果是正方形，不需要；正方形上下左右收缩时候会重合到相当，然后从左到右，从上到下会超过边界。<br>如果是长方形，只有短的那边会超过，长的那边会重复遍历。</li></ul><h2 id="transition和animation区别"><a href="#transition和animation区别" class="headerlink" title="transition和animation区别"></a>transition和animation区别</h2><ul><li>transition：过度动画，需要事件触发，只有开始帧和结束帧；property、during、timing-function、delay。</li><li>animation：复杂动画，设定时间后触发不需要事件，多个帧。timing-function、delay、during、name、播放次数、方向等等。@keyframe去设置中间帧比如50%。</li></ul><h2 id="伪元素和伪类的区别"><a href="#伪元素和伪类的区别" class="headerlink" title="伪元素和伪类的区别"></a>伪元素和伪类的区别</h2><ul><li>伪元素：元素的特定一部分，<strong>这部分不是元素，不存在</strong>，比如：某一个元素的前面后面插入内容、第一行。</li><li>伪类：作用于特定状态的<strong>元素</strong>，比如：鼠标悬停、结构状态第一个孩子。</li></ul><h2 id="requestAnimationframe"><a href="#requestAnimationframe" class="headerlink" title="requestAnimationframe"></a>requestAnimationframe</h2><ol><li>接受一个回调函数，该函数会在下次回流前调用</li><li>回流是根据浏览器刷新频率触发，60hz就是一秒刷新60次，一秒60次回流，也就调用该函数六十次。</li><li>优点：<br>动画更流畅，不会掉帧、卡顿。<br>cpu节能，页面隐藏时候setTimeout会继续执行，requestAnimation会暂停动画。</li></ol><h2 id="浏览器一帧做什么？"><a href="#浏览器一帧做什么？" class="headerlink" title="浏览器一帧做什么？"></a>浏览器一帧做什么？</h2><ol><li>处理用户交互</li><li>requestAnimationFrame</li><li>回流重绘</li><li>还有空闲时间：requestIdleCallback</li></ol><h2 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h2><ol><li>requestIdleCallback 是捡浏览器空闲来执行任务。假如浏览器一直处于非常忙碌的状态，requestIdleCallback 注册的任务有可能永远不会执行</li></ol><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><ol><li>content、padding、border、margin</li><li>标准盒子模型：width只包括content，ie盒子模型width包括content、padding、border。</li><li>box-sizing设置不同盒子模型。</li></ol><h2 id="为什么用transform更改位置"><a href="#为什么用transform更改位置" class="headerlink" title="为什么用transform更改位置"></a>为什么用transform更改位置</h2><ul><li>transform、opacity不会触发回流、重绘，只会触发复合。</li></ul><h2 id="css3新特性-9997"><a href="#css3新特性-9997" class="headerlink" title="css3新特性 &#9997;"></a>css3新特性 &#9997;</h2><ol><li>属性选择器、伪类选择器、伪元素选择器</li><li>flex弹性布局</li><li>transition、animation</li><li>媒体查询、em、rem</li><li>border-radius圆角边框、box-shadow、</li></ol><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><ol><li>预处理器是css基础上抽象的一层，最终会转换为css。</li><li>变量：定义颜色、字体常用值，实现复用。</li><li>嵌套：更直观，方便维护。</li><li>运算：加减乘除，函数。</li><li>mixin、继承：复用选择器片段。</li></ol><h2 id="双冒号，单冒号"><a href="#双冒号，单冒号" class="headerlink" title="双冒号，单冒号"></a>双冒号，单冒号</h2><ul><li>双：伪元素；单：伪类。</li></ul><h1 id="1-19"><a href="#1-19" class="headerlink" title="1.19"></a>1.19</h1><h2 id="数组总结"><a href="#数组总结" class="headerlink" title="数组总结"></a>数组总结</h2><h3 id="二分法（有序时候就可以考虑）"><a href="#二分法（有序时候就可以考虑）" class="headerlink" title="二分法（有序时候就可以考虑）"></a>二分法（有序时候就可以考虑）</h3><ol><li>数组是有序的，时间复杂度降到logn；</li><li></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>    <span class="hljs-keyword">let</span> mid = ((left + right) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>        right = mid - <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>        left = mid + <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双指针（移除元素时候考虑：移除重复元素、移除零）"><a href="#双指针（移除元素时候考虑：移除重复元素、移除零）" class="headerlink" title="双指针（移除元素时候考虑：移除重复元素、移除零）"></a>双指针（移除元素时候考虑：移除重复元素、移除零）</h3><ol><li>一个负责找新的元素，一个负责已经维护好的数组。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(right &lt; nums.<span class="hljs-property">length</span>)&#123;<br>    <span class="hljs-keyword">if</span>(nums[right] !== xxx)&#123;<br>        [nums[left], nums[right]] = <br>        [nums[right], nums[left]];<br>    &#125;<br>    right++;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>双向二分，根据实际情况，左右指针都可能动。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="滑动窗口（长度最长、最短的子数组、子串）"><a href="#滑动窗口（长度最长、最短的子数组、子串）" class="headerlink" title="滑动窗口（长度最长、最短的子数组、子串）"></a>滑动窗口（长度最长、最短的子数组、子串）</h3><h3 id="模拟行为"><a href="#模拟行为" class="headerlink" title="模拟行为"></a>模拟行为</h3><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h2 id="和为K的子数组"><a href="#和为K的子数组" class="headerlink" title="和为K的子数组"></a>和为K的子数组</h2><h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><h2 id="两两交换链表的元素"><a href="#两两交换链表的元素" class="headerlink" title="两两交换链表的元素"></a>两两交换链表的元素</h2><h2 id="删除链表倒数第N个节点"><a href="#删除链表倒数第N个节点" class="headerlink" title="删除链表倒数第N个节点"></a>删除链表倒数第N个节点</h2><h2 id="文本溢出"><a href="#文本溢出" class="headerlink" title="文本溢出"></a>文本溢出</h2><ol><li>单行文本</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>:hidden; // 溢出部门隐藏<br><span class="hljs-attribute">text-overflow</span>:ellipsis; // 省略号<br><span class="hljs-attribute">white-space</span>:no-wrap; //文本不换行<br></code></pre></td></tr></table></figure><ol start="2"><li>多行文本</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>:hidden;<br><span class="hljs-attribute">text-overflow</span>:ellipsis;<br><span class="hljs-attribute">display</span>:-webkit-box;<br>-webkit-<span class="hljs-selector-tag">line</span>-clamp:<span class="hljs-number">2</span>; // 设置展现为两行，这个属性必须webkit-box支持<br>-webkit-<span class="hljs-attribute">box-orient</span>:vertical;<br></code></pre></td></tr></table></figure><h2 id="webkit-box-9997"><a href="#webkit-box-9997" class="headerlink" title="webkit-box &#9997;"></a>webkit-box &#9997;</h2><ul><li>早期没有flexbox的弹性盒子模型，为了兼容旧版本浏览器和实现特定功能(多行文本溢出隐藏)而保留了下来。</li></ul><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><ul><li>根据不同的媒体类型使用不同的样式，适用于响应式设计的页面。包含多个表达式，表达式都为true就应用该样式。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>:<span class="hljs-number">768px</span>) <br><span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>:<span class="hljs-number">968px</span>)&#123;<br>    <span class="hljs-selector-tag">body</span>:&#123;<br>    <span class="hljs-attribute">font-size</span>:<span class="hljs-number">18px</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><h2 id="浮动缺点"><a href="#浮动缺点" class="headerlink" title="浮动缺点"></a>浮动缺点</h2><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><h2 id="伪元素-clearfix"><a href="#伪元素-clearfix" class="headerlink" title="伪元素 + clearfix"></a>伪元素 + clearfix</h2><h2 id="脱离文档流后元素特点"><a href="#脱离文档流后元素特点" class="headerlink" title="脱离文档流后元素特点"></a>脱离文档流后元素特点</h2><ol><li>不再占据位置，不影响其他元素布局。</li><li>行内元素变块元素，块元素宽高都由子元素撑开。</li></ol><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h1 id="1-20"><a href="#1-20" class="headerlink" title="1.20"></a>1.20</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h3><h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><h3 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h3><h3 id="找到字符串的所有异位词"><a href="#找到字符串的所有异位词" class="headerlink" title="找到字符串的所有异位词"></a>找到字符串的所有异位词</h3><ul><li>用数组作为hash表</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">arrP[nums[i].<span class="hljs-title function_">charCodeAt</span>() - <span class="hljs-string">&quot;a&quot;</span>.<span class="hljs-title function_">charCodeAt</span>()]++; <br></code></pre></td></tr></table></figure><h3 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h3><h3 id="两个数组的交集II"><a href="#两个数组的交集II" class="headerlink" title="两个数组的交集II"></a>两个数组的交集II</h3><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><h3 id="css基础"><a href="#css基础" class="headerlink" title="css基础"></a>css基础</h3><h3 id="浮动、定位复习"><a href="#浮动、定位复习" class="headerlink" title="浮动、定位复习"></a>浮动、定位复习</h3><h3 id="外边距重叠"><a href="#外边距重叠" class="headerlink" title="外边距重叠"></a>外边距重叠</h3><ol><li><strong>兄弟之间</strong>：都为正或都为负时候，取绝对值较大的值。一正一负时候用正减去负的绝对值。</li><li>父子之间：子的外边距影响到父元素。</li></ol><h3 id="元素的层叠顺序"><a href="#元素的层叠顺序" class="headerlink" title="元素的层叠顺序"></a>元素的层叠顺序</h3><ul><li>background、z-index负数、块级、浮动元素、inline、z-index为0、z-index为正。</li></ul><h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h3><ol><li>根层叠上下文（html）</li><li>定位属性的元素，设置了z-index可以设置层叠上下文</li><li>css3新属性设置层叠上下文</li></ol><h3 id="比较两个元素谁在上谁在下？"><a href="#比较两个元素谁在上谁在下？" class="headerlink" title="比较两个元素谁在上谁在下？"></a>比较两个元素谁在上谁在下？</h3><ol><li>先比较层叠上下文，层叠上下文高的在上。</li><li>如果在同一个层叠上下文，才考虑元素的层叠顺序规则。</li><li>都相等的情况下，后面的元素层叠更高。</li></ol><!-- 如果不在同一个层叠上下文，一个z-index为9999也不一定有另一个元素层叠级别高 --><h3 id="z-index什么时候失效"><a href="#z-index什么时候失效" class="headerlink" title="z-index什么时候失效"></a>z-index什么时候失效</h3><ol><li>父元素定位是relative</li><li>当前元素定位是static</li><li>当前元素开启了浮动</li></ol><h1 id="1-21"><a href="#1-21" class="headerlink" title="1.21"></a>1.21</h1><h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><h3 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h3><h3 id="四数相加II"><a href="#四数相加II" class="headerlink" title="四数相加II"></a>四数相加II</h3><h3 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h3><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><h1 id="1-22"><a href="#1-22" class="headerlink" title="1.22"></a>1.22</h1><h2 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h2><h3 id="css单位"><a href="#css单位" class="headerlink" title="css单位"></a>css单位</h3><ol><li>px</li><li>em：相对于父元素的font-size；<br>rem：相对于根元素html的font-size;</li></ol><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><ul><li>父元素有什么属性，子元素有什么属性（flex、flex-grow、flex-shrink、flex-basis、order）。</li></ul><h3 id="flex-1"><a href="#flex-1" class="headerlink" title="flex:1"></a>flex:1</h3><ul><li>默认是 0 1 auto</li><li>flex：1是 1 1 auto，增加了grow属性。</li></ul><h3 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h3><ul><li>flex</li><li>float、BFC</li><li>float、margin-left</li><li>position、margin-left</li><li>position、left</li></ul><h3 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h3><ul><li>flex，flex:1</li><li>float:left,float:right,overflow:hidden;</li><li>float:left.float:right.margin-left margin-right.</li><li>position:absolute, position:absolute, margin-left right.</li></ul><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ul><li>方法一三什么情况都能用，方法二只能在盒子有宽高情况下用，不然多余空间不会给margin。</li></ul><ol><li>flex,justify-content,align-items。</li><li>position:absolute,left、right、top、bottom,margin:auto.</li><li>position:absolute;left:50%, top:50%,transform:translate(-50%,-50%).</li></ol><h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><ol><li>布局视口：文档对象的逻辑尺寸，pc端和浏览器窗口大小差不多。移动端远大于手机尺寸。</li><li>理想视口：是布局视口的理想尺寸，和设备宽度相同。</li><li>视觉视口：用户在网页看到的区域。理想视口尺寸&#x2F;缩放比例。</li></ol><h3 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h3><ol><li>布局视口等于设备视口，设备视口等于理想视口。</li><li>媒体查询</li><li>em、rem</li><li>vant组件库</li><li>flex布局</li><li>设计稿大小</li></ol><h1 id="1-23"><a href="#1-23" class="headerlink" title="1.23"></a>1.23</h1><h2 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h2><h3 id="四树之和"><a href="#四树之和" class="headerlink" title="四树之和"></a>四树之和</h3><h3 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h3><h3 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h3><h3 id="最大子序列和"><a href="#最大子序列和" class="headerlink" title="最大子序列和"></a>最大子序列和</h3><h3 id="买卖股票最佳时机2"><a href="#买卖股票最佳时机2" class="headerlink" title="买卖股票最佳时机2"></a>买卖股票最佳时机2</h3><h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h3><h3 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h3><h2 id="八股-1"><a href="#八股-1" class="headerlink" title="八股"></a>八股</h2><h3 id="flex布局-1"><a href="#flex布局-1" class="headerlink" title="flex布局"></a>flex布局</h3><h3 id="两栏布局-1"><a href="#两栏布局-1" class="headerlink" title="两栏布局"></a>两栏布局</h3><h3 id="三栏布局-1"><a href="#三栏布局-1" class="headerlink" title="三栏布局"></a>三栏布局</h3><h3 id="垂直居中-1"><a href="#垂直居中-1" class="headerlink" title="垂直居中"></a>垂直居中</h3><h3 id="视口-1"><a href="#视口-1" class="headerlink" title="视口"></a>视口</h3><h3 id="移动端适配-1"><a href="#移动端适配-1" class="headerlink" title="移动端适配"></a>移动端适配</h3><h1 id="1-24"><a href="#1-24" class="headerlink" title="1.24"></a>1.24</h1><h2 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h2><h3 id="k次取反后的最大数组"><a href="#k次取反后的最大数组" class="headerlink" title="k次取反后的最大数组"></a>k次取反后的最大数组</h3><h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h3><h3 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h3><h3 id="二叉树层序遍历1、2"><a href="#二叉树层序遍历1、2" class="headerlink" title="二叉树层序遍历1、2"></a>二叉树层序遍历1、2</h3><h2 id="八股-2"><a href="#八股-2" class="headerlink" title="八股"></a>八股</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>string、symbol、null、undefined、number、boolean、bigInt、object</li></ul><h3 id="栈堆内存"><a href="#栈堆内存" class="headerlink" title="栈堆内存"></a>栈堆内存</h3><ul><li>栈：大小固定，内存小，基本数据类型</li><li>堆：大小不固定，内存大，栈中存储堆起始位置</li></ul><h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><ul><li>typeof：null返回object，函数返回function</li><li>instanceof</li><li>prototype</li><li>constructor</li><li>Object.prototype.toString.call()</li></ul><h3 id="数组判断"><a href="#数组判断" class="headerlink" title="数组判断"></a>数组判断</h3><ol><li>Array.isArray</li><li>prototype</li><li>constructor</li><li>Object.prototype.toString.call()</li></ol><h3 id="原型对象、原型链"><a href="#原型对象、原型链" class="headerlink" title="原型对象、原型链"></a>原型对象、原型链</h3><ol><li><strong>prototype、constructor</strong>：构造函数有一个prototype属性指向原型对象，在原型对象上可以放公有属性和方法。constructor指回构造函数。</li><li><strong>proto</strong>：创建的实例有proto属性指向原型对象。</li><li>原型对象是Object构造函数创建出来的实例，他的proto指向Object的原型对象。</li><li>Object的原型对象指向null，是原型链的尽头。</li><li>构造函数也是由Function构造函数创建来的，构造函数的proto指向Function.proto。</li><li>原型链搜索：先查看对象本身，没有就去proto中查找，直到为空返回报错。（如果中途搜到null也会返回值）。</li></ol><h3 id="鸡蛋问题"><a href="#鸡蛋问题" class="headerlink" title="鸡蛋问题"></a>鸡蛋问题</h3><ul><li>Function.prototype &#x3D;&#x3D; Function.proto</li><li>先创建Object的原型对象，Function.proto继承其创建出来，然后各个构造函数的proto指向Function.proto。</li></ul><h3 id="原型上的方法this指向-10024"><a href="#原型上的方法this指向-10024" class="headerlink" title="原型上的方法this指向 &#10024;"></a>原型上的方法this指向 &#10024;</h3><ul><li>指向实例对象，不是原型对象！</li></ul><h3 id="null、undefined区别"><a href="#null、undefined区别" class="headerlink" title="null、undefined区别"></a>null、undefined区别</h3><ul><li>空对象，初始化。</li><li>未定义，未赋值时候的值。</li></ul><h3 id="typeof-null为object原因"><a href="#typeof-null为object原因" class="headerlink" title="typeof null为object原因"></a>typeof null为object原因</h3><ul><li>js存储数据时候有三个二进制位表示类型。object是000，null是所有二进制位都为0，正好也是object。</li></ul><h3 id="instanceof实现原理"><a href="#instanceof实现原理" class="headerlink" title="instanceof实现原理"></a>instanceof实现原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceOf</span>(<span class="hljs-params">left,right</span>)&#123;<br>    <span class="hljs-keyword">let</span> prototype = left.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    <span class="hljs-keyword">let</span> proto = right.<span class="hljs-property">__proto__</span>;<br>    <span class="hljs-keyword">while</span>(proto)&#123;<br>        <span class="hljs-keyword">if</span>(proto == prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        proto = proto.<span class="hljs-property">__proto__</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="为什么0-1-0-2-！-0-3"><a href="#为什么0-1-0-2-！-0-3" class="headerlink" title="为什么0.1 + 0.2 ！&#x3D;&#x3D; 0.3"></a>为什么0.1 + 0.2 ！&#x3D;&#x3D; 0.3</h3><h3 id="转换为布尔值"><a href="#转换为布尔值" class="headerlink" title="转换为布尔值"></a>转换为布尔值</h3><ul><li>null、undefined、0、””。</li></ul><h3 id="和"><a href="#和" class="headerlink" title="||和&amp;&amp;"></a>||和&amp;&amp;</h3><ul><li>短路运算。</li></ul><h3 id="Object-is和’-’区别"><a href="#Object-is和’-’区别" class="headerlink" title="Object.is和’&#x3D;&#x3D;&#x3D;’区别"></a>Object.is和’&#x3D;&#x3D;&#x3D;’区别</h3><ul><li>NaN是相等的，0 和 +0相等。</li></ul><h3 id="包装类型、隐式转换"><a href="#包装类型、隐式转换" class="headerlink" title="包装类型、隐式转换"></a>包装类型、隐式转换</h3><h3 id="Object-assgin、扩展运算符"><a href="#Object-assgin、扩展运算符" class="headerlink" title="Object.assgin、扩展运算符"></a>Object.assgin、扩展运算符</h3><ul><li>都是浅拷贝</li></ul><h3 id="let、const、var区别"><a href="#let、const、var区别" class="headerlink" title="let、const、var区别"></a>let、const、var区别</h3><ul><li>const必须赋初始值</li><li>var申明的变量会出现在window上。</li></ul><h3 id="new-操作符干什么？"><a href="#new-操作符干什么？" class="headerlink" title="new 操作符干什么？"></a>new 操作符干什么？</h3><ul><li>创建一个空对象</li><li>空对象原型指向构造函数的原型</li><li>this指向空对象，执行函数</li><li>返回空对象，或者函数原本返回一个对象</li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ol><li>写法更简洁</li><li>没有原型对象</li><li>没有arguments</li><li>没有this，this指向不会改变。</li><li>不能作为构造函数</li></ol><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><ol><li>可以用${}</li><li>换行空格都会保留</li></ol><h3 id="es6字符串新操作"><a href="#es6字符串新操作" class="headerlink" title="es6字符串新操作"></a>es6字符串新操作</h3><ul><li>indexOf &#x3D;》 includes返回true或者false。</li><li>repeat(3)</li></ul><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>- </p><h3 id><a href="#" class="headerlink" title></a></h3><h1 id="1-25"><a href="#1-25" class="headerlink" title="1.25"></a>1.25</h1><h2 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h2><h3 id="二叉树前中后非递归遍历"><a href="#二叉树前中后非递归遍历" class="headerlink" title="二叉树前中后非递归遍历"></a>二叉树前中后非递归遍历</h3><h3 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h3><h3 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a>二叉树的层平均值</h3><h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><h3 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h3><h3 id="N叉树的最大深度"><a href="#N叉树的最大深度" class="headerlink" title="N叉树的最大深度"></a>N叉树的最大深度</h3><h3 id="平衡二叉树-1"><a href="#平衡二叉树-1" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><h3 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h3><h3 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h3><h2 id="八股-3"><a href="#八股-3" class="headerlink" title="八股"></a>八股</h2><ul><li>js基础、执行上下文作用域闭包</li></ul><h3 id="手写new操作符"><a href="#手写new操作符" class="headerlink" title="手写new操作符"></a>手写new操作符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>];<br>    <span class="hljs-keyword">let</span> constructor = args.<span class="hljs-title function_">shift</span>();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> constructor !== <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>    &#125;<br>    <span class="hljs-keyword">let</span> newObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>    <span class="hljs-keyword">let</span> result = constructor.<span class="hljs-title function_">apply</span>(newObj, args);<br>    <span class="hljs-keyword">if</span>(result &amp;&amp; <span class="hljs-keyword">typeof</span> result == <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> result;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> newObj;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="map和object区别"><a href="#map和object区别" class="headerlink" title="map和object区别"></a>map和object区别</h3><ul><li>map无多余属性、按顺序放、完整的键值对、size、有迭代器可以遍历</li></ul><h3 id="weakmap和map区别"><a href="#weakmap和map区别" class="headerlink" title="weakmap和map区别"></a>weakmap和map区别</h3><ul><li>weakmap的键名只能是对象或者symbol值，垃圾回收机制不会考虑weakmap的引用，当内存中其他变量没有引用对象时候，垃圾回收机制会自动释放该对象内存。</li></ul><h3 id="json-stringify、json-parse"><a href="#json-stringify、json-parse" class="headerlink" title="json.stringify、json.parse"></a>json.stringify、json.parse</h3><ol><li>function,symbol,undefined,不可枚举属性会消失,NaN&#x3D;&#x3D;&gt;null</li><li>原型链 循环引用不会转换</li></ol><h3 id="js延迟加载"><a href="#js延迟加载" class="headerlink" title="js延迟加载"></a>js延迟加载</h3><ol><li>async</li><li>defer</li><li>script标签写到文档后面</li><li>动态创建script标签去加载</li></ol><h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><ul><li>有length属性、若干索引属性。常见的DOM数组、arguments。和数组相似但没有数组方法。</li><li>Array.from、[…arguments]。</li></ul><h3 id="常见的位运算符"><a href="#常见的位运算符" class="headerlink" title="常见的位运算符"></a>常见的位运算符</h3><ul><li>&amp;  |  ^ &gt;&gt; &lt;&lt;</li></ul><h3 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h3><ul><li>原码就是二进制的数。 反码是原码每一位取反。补码：正数就是本身，负数是反码+1.</li><li>计算机内部存储都是补码，补码可以在做减法时候直接相加即可。</li></ul><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dns">计算 <span class="hljs-number">5</span>−<span class="hljs-number">3</span>=<span class="hljs-number">5</span>+(−<span class="hljs-number">3</span>)：<br><br>+<span class="hljs-number">5</span> 的补码：<span class="hljs-number">00000101</span><br>−<span class="hljs-number">3</span> 的补码：<span class="hljs-number">11111101</span><br>加法结果：<span class="hljs-number">00000101</span> + <span class="hljs-number">11111101</span> = <span class="hljs-number">00000010</span>（忽略最高位进位）<br>结果是 <br>+<span class="hljs-number">2</span>，与实际结果一致。<br><br></code></pre></td></tr></table></figure><h3 id="为什么会有类数组"><a href="#为什么会有类数组" class="headerlink" title="为什么会有类数组"></a>为什么会有类数组</h3><ol><li>提供轻量数据结构，没有数组方法和原型，占据内存少。</li><li>性能更好，创建速度更快，有的</li></ol><h1 id="1-26"><a href="#1-26" class="headerlink" title="1.26"></a>1.26</h1><h2 id="算法-5"><a href="#算法-5" class="headerlink" title="算法"></a>算法</h2><h3 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h3><h3 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h3><h3 id="另一颗树的子树"><a href="#另一颗树的子树" class="headerlink" title="另一颗树的子树"></a>另一颗树的子树</h3><h3 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h3><h3 id="找左下角的值"><a href="#找左下角的值" class="headerlink" title="找左下角的值"></a>找左下角的值</h3><h3 id="路径总和1"><a href="#路径总和1" class="headerlink" title="路径总和1"></a>路径总和1</h3><h3 id="路径总和2"><a href="#路径总和2" class="headerlink" title="路径总和2"></a>路径总和2</h3><h2 id="八股-4"><a href="#八股-4" class="headerlink" title="八股"></a>八股</h2><h3 id="类数组-1"><a href="#类数组-1" class="headerlink" title="类数组"></a>类数组</h3><ul><li>本身是什么？有length属性、若干索引属性。常见的DOM数组、arguments。和数组相似但没有数组方法。</li><li>优势是什么？提供轻量数据结构，没有数组方法和原型，占据内存少；性能更好，创建速度更快，有的</li><li>如何进行转换？Array.from、[…arguments].</li></ul><h1 id="1-27"><a href="#1-27" class="headerlink" title="1.27"></a>1.27</h1><h2 id="算法-6"><a href="#算法-6" class="headerlink" title="算法"></a>算法</h2><h3 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h3><ul><li>去尝试，要么按这个排序，要么按另一个排序，然后插入嘛。</li></ul><h1 id="1-28"><a href="#1-28" class="headerlink" title="1.28"></a>1.28</h1><h2 id="算法-7"><a href="#算法-7" class="headerlink" title="算法"></a>算法</h2><h3 id="从后序中序遍历构建二叉树"><a href="#从后序中序遍历构建二叉树" class="headerlink" title="从后序中序遍历构建二叉树"></a>从后序中序遍历构建二叉树</h3><h3 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h3><h1 id="1-29"><a href="#1-29" class="headerlink" title="1.29"></a>1.29</h1><h2 id="算法-8"><a href="#算法-8" class="headerlink" title="算法"></a>算法</h2><h3 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h3><h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h3><h1 id="1-30"><a href="#1-30" class="headerlink" title="1.30"></a>1.30</h1><h2 id="算法-9"><a href="#算法-9" class="headerlink" title="算法"></a>算法</h2><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h3><h3 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h3><h1 id="1-31"><a href="#1-31" class="headerlink" title="1.31"></a>1.31</h1><h2 id="算法-10"><a href="#算法-10" class="headerlink" title="算法"></a>算法</h2><h3 id="二叉搜索树的众数"><a href="#二叉搜索树的众数" class="headerlink" title="二叉搜索树的众数"></a>二叉搜索树的众数</h3><h3 id="二叉树的最近公共祖先-1"><a href="#二叉树的最近公共祖先-1" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h3><h3 id="二叉搜索树的最近公共祖先-1"><a href="#二叉搜索树的最近公共祖先-1" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h3><h1 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h1><h2 id="算法-11"><a href="#算法-11" class="headerlink" title="算法"></a>算法</h2><h3 id="二叉搜索树的插入操作"><a href="#二叉搜索树的插入操作" class="headerlink" title="二叉搜索树的插入操作"></a>二叉搜索树的插入操作</h3><h3 id="删除二叉搜索树的节点"><a href="#删除二叉搜索树的节点" class="headerlink" title="删除二叉搜索树的节点"></a>删除二叉搜索树的节点</h3><h3 id="将有序数组转换为二叉平衡搜索树"><a href="#将有序数组转换为二叉平衡搜索树" class="headerlink" title="将有序数组转换为二叉平衡搜索树"></a>将有序数组转换为二叉平衡搜索树</h3><h3 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h3><h3 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h3><h3 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h3><ul><li>确定三部曲第一部的返回值很重要。</li></ul><ol><li>递归遍历：不用返回值，收集结果。单独写一个函数。</li><li>迭代遍历：前后序遍历是用栈结构处理，根左右，右先进栈压在里面。然后左出栈处理，只有左边处理完右才出栈。</li><li>层序遍历：队列，一层出队列后，遍历下一层。</li><li>翻转二叉树</li><li>对称二叉树：返回值是布尔值，递归参数是两个节点。</li><li>最大深度、最小深度：返回值都要接受。</li><li>完全二叉树节点个数：单独写一个函数，收集结果，不用返回值。</li><li>判断平衡二叉树：返回值既要布尔值，但又需要数字去判断，就单独写一个获取最大深度的函数。</li></ol><h2 id="八股-5"><a href="#八股-5" class="headerlink" title="八股"></a>八股</h2><h3 id="new操作符干了什么？"><a href="#new操作符干了什么？" class="headerlink" title="new操作符干了什么？"></a>new操作符干了什么？</h3><ol><li>创建一个空对象。</li><li>对象的原型指向构造函数的原型对象。</li><li>this指向这个空对象，带入构造函数执行。</li><li>返回这个对象，或者构造函数原来就返回的对象。</li></ol><h3 id="map-Object区别？"><a href="#map-Object区别？" class="headerlink" title="map Object区别？"></a>map Object区别？</h3><ul><li>没有额外的键值、有顺序、完整的键值对、size、可遍历。</li></ul><h3 id="map、weakmap区别"><a href="#map、weakmap区别" class="headerlink" title="map、weakmap区别"></a>map、weakmap区别</h3><ul><li>弱引用</li></ul><h3 id="json-stringfy"><a href="#json-stringfy" class="headerlink" title="json.stringfy"></a>json.stringfy</h3><ul><li>循环引用、原型链不会转换</li><li>函数、symbol、undefined、不可遍历属性不会转换，NaN转换为null。</li></ul><h3 id="js脚本延迟加载"><a href="#js脚本延迟加载" class="headerlink" title="js脚本延迟加载"></a>js脚本延迟加载</h3><ul><li>async、defer、后面插入script标签、script标签写后面。</li></ul><h3 id="类数组-2"><a href="#类数组-2" class="headerlink" title="类数组"></a>类数组</h3><ul><li>数字索引、length。</li><li>没有数组原型链上的属性和方法，性能更好，轻量占用内存少。</li><li>Array.from、[…arguments].</li></ul><h3 id="encodeURI、encodeURIComponent"><a href="#encodeURI、encodeURIComponent" class="headerlink" title="encodeURI、encodeURIComponent"></a>encodeURI、encodeURIComponent</h3><ul><li>encodeURI不会转义特殊字符，比如等于号、问号</li><li>encodeURIComponent可以</li><li>一般比如get请求，xx&#x3D;参数，如果参数里面有等于我们就用encodeURIComponent</li></ul><h1 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h1><h2 id="算法-12"><a href="#算法-12" class="headerlink" title="算法"></a>算法</h2><h3 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h3><h3 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h3><h3 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h3><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><h3 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h3><h3 id="复习-1"><a href="#复习-1" class="headerlink" title="复习"></a>复习</h3><ul><li>二叉树所有路径：单独写一个函数，不需要返回值。</li><li>相同的树：接受返回值。</li><li>另一颗树的子树：接受返回值，两个函数遍历。</li><li>左叶子之和：单独写一个函数，不需要返回值。</li><li>找树最左下角的值：层序遍历</li><li>路径总和1，2，3</li></ul><h1 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h1><h2 id="算法-13"><a href="#算法-13" class="headerlink" title="算法"></a>算法</h2><h3 id="路径总和3"><a href="#路径总和3" class="headerlink" title="路径总和3"></a>路径总和3</h3><h3 id="复习-2"><a href="#复习-2" class="headerlink" title="复习"></a>复习</h3><ul><li>路径总和1：单独写一个函数，收集结果。不需要返回值。</li><li>路径总和2：单独写一个函数，收集结果。不需要返回值。</li><li>路径总和3：接受返回值；每个节点调用。</li><li>理解接受返回值，返回值如何处理。累加</li></ul><h3 id="回溯算法理论"><a href="#回溯算法理论" class="headerlink" title="回溯算法理论"></a>回溯算法理论</h3><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><h3 id="组合总和3"><a href="#组合总和3" class="headerlink" title="组合总和3"></a>组合总和3</h3><h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h3><h3 id="递归、回溯思路"><a href="#递归、回溯思路" class="headerlink" title="递归、回溯思路"></a>递归、回溯思路</h3><ul><li>递归和回溯的模拟思想都是从终止条件往回走一步，再走一步。</li></ul><h2 id="八股-6"><a href="#八股-6" class="headerlink" title="八股"></a>八股</h2><h3 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h3><ul><li>new XMLHttpRequest,open,send,onreadystatechange,status,onerror,setRequestHeaders</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>;<br>    &#125;<br>&#125;<br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);<br>&#125;<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Accept&#x27;</span>,<span class="hljs-string">&#x27;application/json&#x27;</span>)<br><br>xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><h3 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h3><ul><li>执行上下文、执行上下文栈&#x3D;》结合闭包为什么不能弹出&#x3D;》为什么尾调用能弹出。</li></ul><ol><li>每一个函数对应一个执行下上文，执行上下文栈。</li><li>一般情况下，里层函数可以访问外层函数词法环境也就是变量，所以外层函数执行上下文不能弹出执行上下文栈。<br>但是如果没有用闭包，且是在外层函数的末尾调用的，则可以提前弹出外层函数的执行上下文，减少内存的占用。</li></ol><h3 id="es6模块和commonjs模块区别"><a href="#es6模块和commonjs模块区别" class="headerlink" title="es6模块和commonjs模块区别"></a>es6模块和commonjs模块区别</h3><ul><li>加载的语句、同步异步、编译运行、值的处理。</li></ul><h3 id="dom节点的操作"><a href="#dom节点的操作" class="headerlink" title="dom节点的操作"></a>dom节点的操作</h3><ul><li>getElementById、querySelector、createElement、removeChild、appendChild</li></ul><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><ol><li>禁止使用with</li><li>对象属性不能重复</li><li>this不再指向window，而是undefined<br>只读不可赋值、等等。</li></ol><h3 id="强、弱语言类型"><a href="#强、弱语言类型" class="headerlink" title="强、弱语言类型"></a>强、弱语言类型</h3><ul><li>强类型语言中每个变量会有个固定类型，变量类型确定后不做强制转换不能改变。</li></ul><h3 id="for-in-、-for-of"><a href="#for-in-、-for-of" class="headerlink" title="for in 、 for of"></a>for in 、 for of</h3><ol><li>for in是遍历对象属性，包括原型。</li><li>for of一般是遍历有迭代器的对象。map、set、类数组。</li><li>数组上：in是下标，of是值。</li></ol><h3 id="如何用for-of遍历对象"><a href="#如何用for-of遍历对象" class="headerlink" title="如何用for of遍历对象"></a>如何用for of遍历对象</h3><ul><li>给对象写个遍历器属性[symbol.interator]</li></ul><h3 id="解释性语言（py，js）和编译性语言（c）"><a href="#解释性语言（py，js）和编译性语言（c）" class="headerlink" title="解释性语言（py，js）和编译性语言（c）"></a>解释性语言（py，js）和编译性语言（c）</h3><ol><li>解释性是代码逐行解释执行，编译性语言是统一转换为机器码之后执行。</li><li>解释性执行速度慢，编译性执行机器码快。</li><li>解释性跨平台更好（解释器跨平台即可），编译性需要编译成不同的机器码。</li></ol><h3 id="axios比fetch、ajax的好处"><a href="#axios比fetch、ajax的好处" class="headerlink" title="axios比fetch、ajax的好处"></a>axios比fetch、ajax的好处</h3><ol><li>json格式化处理</li><li>兼容性：避免fetch不兼容</li><li>api简洁：基于promise封装，避免xhr的回调</li><li>超时配置、baseURL、拦截器功能</li></ol><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><ul><li>对代码执行环境的抽象概念</li><li>全局执行上下文：只有一个，代码执行时候创建，浏览器关闭时候销毁。<br>函数执行上下文：函数执行时候创建。<br>eval执行上下文</li><li>执行上下文栈：全局执行上下文栈压入栈中，函数被调用创建上下文压入栈，代码在栈顶的被执行，执行完毕后出栈。</li><li>生命周期：<br>确定this指向；<br>创建词法环境：登记let、const、类，初始化函数声明；处理重复登记的变量、确定对外部词法环境的引用也就是作用域链。<br>创建变量环境：词法环境特殊的一种，登记var声明的变量并初始化为undefined。</li></ul><h3 id="块级作用域原理？"><a href="#块级作用域原理？" class="headerlink" title="块级作用域原理？"></a>块级作用域原理？</h3><ul><li>当前块级的执行上下文中的词法环境会维护一个栈结构，块级变量会在栈顶部优先访问，块级执行完后弹出。</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li>变量和函数可以被访问的区域。</li><li>全局作用域、函数作用域、块级作用域</li><li>静态作用域：函数、变量的作用域在定义时候就确定了，但是值在执行创建执行上下文时候才能确定。</li></ul><h3 id="作用域和执行上下文区别？"><a href="#作用域和执行上下文区别？" class="headerlink" title="作用域和执行上下文区别？"></a>作用域和执行上下文区别？</h3><ul><li>作用域是变量、函数可以访问的区域；执行上下文是代码执行环境的一个抽象概念。</li><li>静态的，动态的。</li><li>执行上下文对外部环境的引用，一个变量作用域可能涉及多个执行上下文。</li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li>一个函数访问另一个函数中的变量，一个函数执行上下文词法环境与另一个函数执行上下文的词法环境进行了捆绑。</li><li>函数在定义时候就确定了他的作用域，会预创建作用域链，等函数被执行时候会创建执行上下文推到作用域链最前端。闭包原理就是作用域链可以访问其他执行上下文的词法环境。</li><li>延长变量生命周期、创建私有变量。响应式原理就用到闭包，set、get函数就是闭包，访问定义响应式函数中的dep类变量。</li></ul><h3 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h3><ul><li>new &gt; call、apply、bind &gt; 对象调用 &gt; 全局调用</li></ul><h1 id="2-4"><a href="#2-4" class="headerlink" title="2.4"></a>2.4</h1><h2 id="算法-14"><a href="#算法-14" class="headerlink" title="算法"></a>算法</h2><h3 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h3><h1 id="2-5"><a href="#2-5" class="headerlink" title="2.5"></a>2.5</h1><h2 id="算法-15"><a href="#算法-15" class="headerlink" title="算法"></a>算法</h2><h3 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h3><h3 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h3><h3 id="复原ip"><a href="#复原ip" class="headerlink" title="复原ip"></a>复原ip</h3><h3 id="复习-3"><a href="#复习-3" class="headerlink" title="复习"></a>复习</h3><ul><li>组合问题：都需要startIndex。</li><li>从中序后序构建二叉树：返回值为node，要接受。</li><li>最大二叉树：返回值为node，要接受。</li></ul><h2 id="八股-7"><a href="#八股-7" class="headerlink" title="八股"></a>八股</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul><li>两种特性；数据类型：configuable、enumerable、writeable、value；访问器属性：get、set、enumerable、configurable</li><li>修改特性：Object.defineProperty</li><li><strong>创建对象</strong>：工厂模式，构造函数模式，原型模式，构造函数＋原型模式。</li><li><strong>对象继承</strong>：原型链继承，盗用构造函数继承，组合继承，原型式继承，寄生式继承，寄生式组合继承。</li></ul><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><ul><li>promise是什么</li><li>Promise.resolve、Promise.reject、promise.then catch finally.</li></ul><h3 id="垃圾回收机制-10024"><a href="#垃圾回收机制-10024" class="headerlink" title="垃圾回收机制 &#10024;"></a>垃圾回收机制 &#10024;</h3><ul><li><a href="https://juejin.cn/post/7280787122016059426">https://juejin.cn/post/7280787122016059426</a></li></ul><ol><li><strong>是什么</strong>：js为对象、变量、函数<em><strong>分配内存</strong></em>，当不再使用这些值时候，垃圾回收机制：一个内存管理机制，会收回对应的内存。</li><li><strong>什么时候启用</strong>：<em><strong>全局变量、局部变量</strong></em>，全局变量要等页面卸载才会回收，局部变量等函数执行完毕退出执行栈时候回收；特殊情况：闭包下不会回收函数执行上下文的词法环境。</li><li><strong>引用计数</strong></li><li><strong>标记清除</strong>：用到的标记，没标记的清除。</li><li><strong>分代回收</strong>：根据生命周期分为新旧生代，旧生代就是上面所述的标记清除。新生代有from to两个空间，刚进来变量放在from里，from满之后进行标记清除，剩下的变量放到to中；然后to变成from，from变成to，重复上述过程。消除内存碎片、生命周期短的变量及时进行垃圾回收。</li><li>闲时收集：CPU空闲时候才进行垃圾回收。</li></ol><h1 id="2-6"><a href="#2-6" class="headerlink" title="2.6"></a>2.6</h1><h2 id="算法-16"><a href="#算法-16" class="headerlink" title="算法"></a>算法</h2><h3 id="子集1"><a href="#子集1" class="headerlink" title="子集1"></a>子集1</h3><h3 id="子集2"><a href="#子集2" class="headerlink" title="子集2"></a>子集2</h3><h3 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h3><h1 id="2-7"><a href="#2-7" class="headerlink" title="2.7"></a>2.7</h1><h2 id="算法-17"><a href="#算法-17" class="headerlink" title="算法"></a>算法</h2><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><h3 id="全排列2"><a href="#全排列2" class="headerlink" title="全排列2"></a>全排列2</h3><ul><li>用数组作为hash更稳妥，在有相同值时候</li></ul><h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h3><h3 id="复习-4"><a href="#复习-4" class="headerlink" title="复习"></a>复习</h3><ul><li>合并二叉树：参数&#x3D;&gt;返回值&#x3D;&gt;是否要接受&#x3D;&gt;单层逻辑，调用函数</li><li>另一颗树的子树：参数是两个节点，返回值是boolean，要接受返回值。</li><li>验证二叉搜索树：参数：最高值，最低值。</li></ul><h2 id="八股-8"><a href="#八股-8" class="headerlink" title="八股"></a>八股</h2><h3 id="js基础"><a href="#js基础" class="headerlink" title="js基础"></a>js基础</h3><h3 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h3><h1 id="2-8"><a href="#2-8" class="headerlink" title="2.8"></a>2.8</h1><h2 id="算法-18"><a href="#算法-18" class="headerlink" title="算法"></a>算法</h2><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><h3 id="斐波那契"><a href="#斐波那契" class="headerlink" title="斐波那契"></a>斐波那契</h3><h1 id="2-9"><a href="#2-9" class="headerlink" title="2.9"></a>2.9</h1><h1 id="2-10"><a href="#2-10" class="headerlink" title="2.10"></a>2.10</h1><h2 id="算法-19"><a href="#算法-19" class="headerlink" title="算法"></a>算法</h2><h3 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h3><h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h3><h3 id="01背包二维、一维理论"><a href="#01背包二维、一维理论" class="headerlink" title="01背包二维、一维理论"></a>01背包二维、一维理论</h3><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><ul><li>二维写法</li><li>一维写法</li></ul><h3 id="最后一块石头的重量"><a href="#最后一块石头的重量" class="headerlink" title="最后一块石头的重量"></a>最后一块石头的重量</h3><h3 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h3><h2 id="八股-9"><a href="#八股-9" class="headerlink" title="八股"></a>八股</h2><h3 id="执行上下文-1"><a href="#执行上下文-1" class="headerlink" title="执行上下文"></a>执行上下文</h3><h3 id="作用域，闭包"><a href="#作用域，闭包" class="headerlink" title="作用域，闭包"></a>作用域，闭包</h3><h3 id="垃圾回收机制-10024-1"><a href="#垃圾回收机制-10024-1" class="headerlink" title="垃圾回收机制 &#10024;"></a>垃圾回收机制 &#10024;</h3><ul><li><a href="https://juejin.cn/post/7280787122016059426">https://juejin.cn/post/7280787122016059426</a></li></ul><ol><li><strong>是什么</strong>：js为对象、变量、函数<em><strong>分配内存</strong></em>，当不再使用这些值时候，垃圾回收机制：一个内存管理机制，会收回对应的内存。</li><li><strong>什么时候启用</strong>：<em><strong>全局变量、局部变量</strong></em>，全局变量要等页面卸载才会回收，局部变量等函数执行完毕退出执行栈时候回收；特殊情况：闭包下不会回收函数执行上下文的词法环境。</li><li><strong>引用计数</strong></li><li><strong>标记清除</strong>：用到的标记，没标记的清除。</li><li><strong>分代回收</strong>：根据生命周期分为新旧生代，旧生代就是上面所述的标记清除。新生代有from to两个空间，刚进来变量放在from里，from满之后进行标记清除，剩下的变量放到to中；然后to变成from，from变成to，重复上述过程。消除内存碎片、生命周期短的变量及时进行垃圾回收。</li><li>闲时收集：CPU空闲时候才进行垃圾回收。</li></ol><h3 id="异步编程-1"><a href="#异步编程-1" class="headerlink" title="异步编程"></a>异步编程</h3><h1 id="2-11"><a href="#2-11" class="headerlink" title="2.11"></a>2.11</h1><h2 id="算法-20"><a href="#算法-20" class="headerlink" title="算法"></a>算法</h2><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h3><h3 id="完全背包理论基础"><a href="#完全背包理论基础" class="headerlink" title="完全背包理论基础"></a>完全背包理论基础</h3><h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h3><h3 id="组合总和IV（未解决）"><a href="#组合总和IV（未解决）" class="headerlink" title="组合总和IV（未解决）"></a>组合总和IV（未解决）</h3><h3 id="复习-5"><a href="#复习-5" class="headerlink" title="复习"></a>复习</h3><ul><li>二叉搜索树中的搜索：递归函数参数是节点＋val值，返回值是null或者节点。返回值要被接受。递归终止条件，单层递归逻辑。</li><li>验证二叉搜索树：递归函数参数有low、high。</li><li>二叉搜索树最小绝对差：中序遍历二叉搜索树得到一个有序结果。</li><li>二叉搜索树中的众数：要按中序遍历，这样相同值才能在一起凑出最大值。</li></ul><h2 id="八股-10"><a href="#八股-10" class="headerlink" title="八股"></a>八股</h2><h2 id="异步编程-2"><a href="#异步编程-2" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="对象创建、继承"><a href="#对象创建、继承" class="headerlink" title="对象创建、继承"></a>对象创建、继承</h3><ul><li>工厂模式，构造函数，原型模式，构造+原型模式</li><li>原型链模式，盗用构造函数，组合，原型式，寄生式，寄生式组合。</li></ul><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul><li>prototype，proto，constructor。</li></ul><!-- ### 移动端rem换算https://www.cnblogs.com/liangxuru/p/6970629.html -->]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>秋招学习记录</title>
    <link href="/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.%E7%A7%8B%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.%E7%A7%8B%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="待办知识点"><a href="#待办知识点" class="headerlink" title="待办知识点"></a>待办知识点</h1><ol><li>！性能优化相关检测工具！：<a href="https://juejin.cn/post/6992756615346651172#heading-0">https://juejin.cn/post/6992756615346651172#heading-0</a></li><li>fetch</li></ol><hr><p>css</p><p>js：基础、代码输出题、手写题。</p><p>vue：源码、八股。</p><p>ts：八股、手写。</p><p>webpack、vite：八股。</p><p>git：八股。</p><p>计算机网络</p><p>操作系统</p><p>算法 + 手写 &#9989;</p><p>浏览器原理</p><p>微前端：准备看源码 &#9989;</p><hr><h1 id="9-13-git知识"><a href="#9-13-git知识" class="headerlink" title="9.13(git知识)"></a>9.13(git知识)</h1><h2 id="git-submodule（git-子模块）"><a href="#git-submodule（git-子模块）" class="headerlink" title="git submodule（git 子模块）"></a>git submodule（git 子模块）</h2><ul><li>将一个git仓库嵌入到另一个git仓库，适用于代码库共享的场景</li></ul><h3 id="1-添加-Submodule"><a href="#1-添加-Submodule" class="headerlink" title="1.添加 Submodule"></a>1.添加 Submodule</h3><ul><li>要将一个外部仓库作为子模块添加到你的主仓库中</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">git submodule <span class="hljs-built_in">add</span> <span class="hljs-symbol">&lt;repository_url&gt;</span> <span class="hljs-symbol">&lt;path&gt;</span><br></code></pre></td></tr></table></figure><p>会在你的主仓库中创建一个名为 submodule_path 的目录，并将外部仓库克隆到该目录中。</p><h3 id="2-初始化和更新-Submodule"><a href="#2-初始化和更新-Submodule" class="headerlink" title="2.初始化和更新 Submodule"></a>2.初始化和更新 Submodule</h3><ul><li>当你克隆一个包含子模块的仓库时，子模块的内容不会自动克隆。你需要手动初始化和更新子模块</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">submodule </span>init<br>git <span class="hljs-keyword">submodule </span>update<br></code></pre></td></tr></table></figure><h2 id="gitmodules"><a href="#gitmodules" class="headerlink" title=".gitmodules"></a>.gitmodules</h2><ul><li>配置文件，存储子模块的相关信息。在git submodule add后自动生成。文件也像 .gitignore 文件一样受到（通过）git控制。</li></ul><h1 id="9-14-qiankun框架"><a href="#9-14-qiankun框架" class="headerlink" title="9.14(qiankun框架)"></a>9.14(qiankun框架)</h1><h2 id="qiankun实现原理"><a href="#qiankun实现原理" class="headerlink" title="qiankun实现原理"></a>qiankun实现原理</h2><ol><li>微前端是将多个独立应用聚合到一个整体的应用。原理是通过监听路由变化动态加载卸载微应用，并通过自定义事件实现微应用之间和主应用的通信。</li></ol><h2 id="设计微前端框架考虑点？"><a href="#设计微前端框架考虑点？" class="headerlink" title="设计微前端框架考虑点？"></a>设计微前端框架考虑点？</h2><ol><li>应用之间的通信</li><li>共享状态（和通信都是基于pinia实现）</li><li>监听变化：监听路由变化，动态加载卸载微应用</li><li>样式隔离：将子应用样式隔离，避免冲突</li><li>生命周期：微应用需要在自己的入口 js (通常就是你配置的 webpack 的 entry js) 导出 bootstrap、mount、unmount 三个生命周期钩子.<br>bootstrap:只执行一次，做全局变量初始化，将共享库导入到子应用中。<br>mount:挂载app到元素中。<br>unmount：innerHTML为空，卸载组件。</li></ol><h2 id="沙箱机制"><a href="#沙箱机制" class="headerlink" title="沙箱机制"></a>沙箱机制</h2><ul><li><p><a href="https://juejin.cn/post/6920110573418086413#heading-0">https://juejin.cn/post/6920110573418086413#heading-0</a><br>沙箱sandbox：它是一种安全机制，在程序中创建一个独立的运行环境，用于严格控制访问资源，隔离对外部程序影响。<em><strong>qiankun：每个子应用对应一个沙箱，确保微应用之间 全局变量&#x2F;事件 不冲突。</strong></em><br>qiankun有三种沙箱实现机制，前两种基于代理proxy，后一种支持无proxy的浏览器。</p></li><li><p><em><strong>LegacySandbox</strong></em>：单实例代理沙箱，简单来讲就是只存在一个window实例，所有的操作都是对这一个实例的操作。 legacySandbox设置了三个参数来记录全局变量,分别是记录沙箱新增的全局变量addedPropsMapInSandbox、记录沙箱更新的全局变量modifiedPropsOriginalValueMapInSandbox、持续记录更新的(新增和修改的)全局变量，用于在任意时刻做snapshot的currentUpdatedPropsValueMap。</p></li><li><p><em><strong>ProxySandbox</strong></em>：多实例代理沙箱，通过对window的拷贝建立多个副本，在沙箱中对建立的副本进行操作</p></li><li><p><em><strong>SnapshotSandbox</strong></em>：快照沙箱，基于 diff 方式实现的沙箱，用于不支持 Proxy 的低版本浏览器.将当前window的快照信息存到windowSnapshot中，如果modifyPropsMap有值，还需要还原上次的状态；激活期间，可能修改了window的数据；退出沙箱时，将修改过的信息存到modifyPropsMap里面，并且把window还原成初始进入的状态。</p></li></ul><h2 id="web-component"><a href="#web-component" class="headerlink" title="web-component"></a>web-component</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2019/08/web_components.html">https://www.ruanyifeng.com/blog/2019/08/web_components.html</a><br>Shadow DOM：我们不希望用户能够看到组件的内部代码，Web Component 允许内部代码隐藏起来，这叫做 Shadow DOM，即这部分 DOM 默认与外部 DOM 隔离，内部任何代码都无法影响外部。</li></ul><h2 id="样式隔离"><a href="#样式隔离" class="headerlink" title="样式隔离"></a>样式隔离</h2><ul><li><a href="https://www.cnblogs.com/shiazhen/p/17352397.html">https://www.cnblogs.com/shiazhen/p/17352397.html</a></li><li>主应用使用 styleLoader.js 加载子应用的 CSS 文件，生成style的标签，子应用template.innerHTML设置为模板，attachShadow设置当前元素是否样式隔离。</li></ul><h2 id="微前端跨域问题"><a href="#微前端跨域问题" class="headerlink" title="微前端跨域问题"></a>微前端跨域问题</h2><ul><li>qiankun 是通过 fetch 去获取子应用注册时配置的静态资源url，所有静态资源必须是支持跨域的，那就得设置允许源了</li></ul><h1 id="9-15-攻击"><a href="#9-15-攻击" class="headerlink" title="9.15(攻击)"></a>9.15(攻击)</h1><h2 id="XSS跨站脚本攻击"><a href="#XSS跨站脚本攻击" class="headerlink" title="XSS跨站脚本攻击"></a>XSS跨站脚本攻击</h2><ol><li>跨站脚本攻击,浏览器无法识别恶意脚本,一同执行.cookie,localStorage,DOM泄露.</li><li>解决方法:</li></ol><ul><li>CSP白名单:后端设置&#x2F;meta标签设置. </li><li>设置cookie为http-only,后端在响应头中的cookie-set字段设置.</li></ul><h2 id="CSRF跨站请求伪造攻击"><a href="#CSRF跨站请求伪造攻击" class="headerlink" title="CSRF跨站请求伪造攻击"></a>CSRF跨站请求伪造攻击</h2><ol><li>利用cookie在同源请求时候会携带,实现用户的身份冒充.用户信任网站A并授权cookie,并访问了恶意网站B.</li><li>get请求的CSRF,一般是img,script带src属性的标签,去发送请求<br>post请求是在form表单,有个js直接提交这个表单.</li><li>解决方法:</li></ol><ul><li>用token验证,token一般在请求头的authorization</li><li>HTTP请求头中的Referer字段:记录了请求的来源地址.网站A√,恶意网站B×</li><li>设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用.</li><li>cookie双重验证:除了cookie发送过去外,还从cookie中取出身份认证的参数再发一次(其实冗余了,不如用token)</li></ul><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><ol><li>攻击者和通信双方各自独立建立连接,交换其所收到的数据.</li></ol><h1 id="9-16-复习浏览器"><a href="#9-16-复习浏览器" class="headerlink" title="9.16(复习浏览器)"></a>9.16(复习浏览器)</h1><ul><li>白天复习完浏览器,刷两道链表.晚上项目</li></ul><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><ol><li>强制缓存,三种,expires&#x2F;cache-control判断是否过期</li><li>协商缓存,两种,last-modified&#x2F;etag判断是否有变化</li></ol><h2 id="地址栏回车-f5刷新-ctrl-f5刷新区别"><a href="#地址栏回车-f5刷新-ctrl-f5刷新区别" class="headerlink" title="地址栏回车,f5刷新,ctrl+f5刷新区别"></a>地址栏回车,f5刷新,ctrl+f5刷新区别</h2><ol><li>地址栏回车:强制缓存+协商缓存都走.</li><li>f5:不走强制缓存,走协商缓存.</li><li>ctrl+f5:强制缓存和协商缓存都不走.</li></ol><h2 id="浏览器的组成"><a href="#浏览器的组成" class="headerlink" title="浏览器的组成"></a>浏览器的组成</h2><ul><li>shell和内核组成</li></ul><ol><li>shell包括菜单栏,调用内核实现各种功能.</li><li>内核包括渲染引擎和js引擎.</li></ol><h2 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><ul><li><a href="https://segmentfault.com/a/1190000042909353">https://segmentfault.com/a/1190000042909353</a></li></ul><ol><li>解析html文档,生成DOM树,由html元素和属性节点组成.</li><li>解析css,生成css树.</li><li>根据DOM树和CSS树构建渲染树</li><li>布局(回流):渲染树进行布局计算每个渲染节点的位置和大小.</li><li>绘制(重绘):将渲染树的节点绘制到页面上.</li><li>复合: 浏览器的绘制是绘制到多层,每一层单独渲染,最后合成到一起形成页面.</li><li>重绘:重绘不会带来重新布局,一般是修改背景颜色,边框阴影等属性.</li><li>回流:消耗性能,改变元素位置,DOM结构发生变化.</li></ol><h2 id="浏览器渲染优化"><a href="#浏览器渲染优化" class="headerlink" title="浏览器渲染优化"></a>浏览器渲染优化</h2><ol><li>js: script标签写在body后面. 用async和defer.</li><li>css:用link引入,开启一个线程去加载,不阻塞GUI渲染线程. @import:GUI线程会停止渲染去加载资源. css少的话就写在style标签中直接GUI渲染.</li><li>html:减少嵌套层次,减少回流重绘操作</li></ol><h2 id="减少回流和重绘操作"><a href="#减少回流和重绘操作" class="headerlink" title="减少回流和重绘操作"></a>减少回流和重绘操作</h2><ol><li>操作低层次的DOM.</li><li>脱离文档流,减少对其他元素影响.</li><li>将DOM读写操作分别放到一起,浏览器的渲染队列机制.</li><li>一些css属性形成新的合成层: transform,opacity等等.浏览器把这些变化交给GPU处理(不是所有合成层都给GPU,只有动画视觉效果时候交给GPU),GPU直接在显存中更改元素显示位置,无需CPU进行布局绘制的计算.</li></ol><h2 id="浏览器的本地存储"><a href="#浏览器的本地存储" class="headerlink" title="浏览器的本地存储"></a>浏览器的本地存储</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ol><li>大小限制4kb,不能跨域.</li><li>主要和seesion配合,存储sessionid,发送请求时候可以携带cookie,服务器识别sessionid来识别身份.</li></ol><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><ol><li>大小5MB,存储在本地,请求不会携带.</li><li>除非主动删除,否则不会消失.</li><li>同源多个标签可以共享数据.</li></ol><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><ol><li>同.</li><li>关闭窗口后会消失</li><li>同源多个标签不可以共享数据.</li></ol><h2 id="cookie字段"><a href="#cookie字段" class="headerlink" title="cookie字段"></a>cookie字段</h2><ol><li>domain:可以访问该cookie的域名</li><li>path:域名下的哪些路径可以访问该cookie</li><li>Expires:cookie过期时间,注意这个是cookie的expires!和缓存的不一样,缓存的是在请求头中!</li><li>name,value,size.</li></ol><ul><li>服务端在响应头可以用set-cookie来配置cookie信息.http-only限制cookie不能被js脚本读取.也有domain,path,expires.<br>(不要把缓存的六个字段和cookie的搞混了,缓存的是在请求头和响应头中)</li></ul><h2 id="indexDB"><a href="#indexDB" class="headerlink" title="indexDB"></a>indexDB</h2><ol><li>键值对存储,异步,支持事务(不会出现只修改部分数据情况),存储空间大(250MB+)</li></ol><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><ol><li>安全机制,隔离恶意文件.要求协议域名端口号都相同.</li><li>限制cookie,localstorage,indexDB&#x2F;DOM&#x2F;跨域请求.</li></ol><h2 id="场景题-Promise-allSettled"><a href="#场景题-Promise-allSettled" class="headerlink" title="场景题,Promise.allSettled()"></a>场景题,Promise.allSettled()</h2><ul><li>静态方法将一个 Promise 可迭代对象作为输入，并返回一个单独的 Promise。当所有输入的 Promise 都已敲定时（包括传入空的可迭代对象时），返回的 Promise 将被兑现，并带有描述每个 Promise 结果的对象数组。</li></ul><h1 id="9-17浏览器-刷题-项目"><a href="#9-17浏览器-刷题-项目" class="headerlink" title="9.17浏览器,刷题,项目."></a>9.17浏览器,刷题,项目.</h1><h2 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h2><ol><li>CORS(跨域资源共享):</li></ol><ul><li>简单请求: 浏览器直接发送请求携带origin,服务端响应时候设置access-control-allow-xxx等字段.</li><li>非简单请求(DELETE,PUT):在正式请求会发送一个<strong>预检请求options.</strong>,浏览器请求头中除了origin还会告诉服务器请求有哪些额外的http方法,哪些额外的请求头部.服务端响应头返回同意的字段后,后续浏览器请求只要origin.<br>(小点:默认跨域请求不携带cookie,后端响应头withCredentials字段可以设置带cookie)</li></ul><ol start="2"><li>JSONP:利用script标签没有跨域限制.script的src发送带有回调函数的cb请求,服务端返回js代码,代码中调用回调函数,传递的参数传给该回调函数.<br>缺点:只能发送get请求,容易受到XSS攻击.</li><li>window.postmessage</li></ol><h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><ol><li>DOM0:不会传播,没有事件流</li><li>IE模型:事件触发,事件冒泡(从里到外).</li><li>DOM2模型:事件捕获(从外到里),事件触发,事件冒泡.</li></ol><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><ul><li>利用了事件冒泡的机制,将子节点的事件绑定到父节点上,由父节点的监听函数统一处理子节点.</li><li>减少了内存消耗,动态绑定事件.</li></ul><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ul><li>js是单线程,将不同函数的执行上下文压入栈中确保执行的顺序,遇到异步任务会挂起,等同步执行完后再去异步.</li><li>整体顺序是:先取出大的宏任务script,执行同,微任务进微任务队列,宏任务进宏任务队列.同执行完后执行微任务,然后下一个script.</li></ul><h2 id="宏任务-微任务"><a href="#宏任务-微任务" class="headerlink" title="宏任务,微任务"></a>宏任务,微任务</h2><ol><li>宏任务:script,setTimeout.</li><li>微任务: promise的回调,mutationObserver.</li></ol><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><ul><li>dom,闭包,全局变量,定时器.</li></ul><h2 id="环形链表1-2-快慢指针-快指针最后为null或者最后一个-循环条件是快指针"><a href="#环形链表1-2-快慢指针-快指针最后为null或者最后一个-循环条件是快指针" class="headerlink" title="环形链表1,2(快慢指针,快指针最后为null或者最后一个,循环条件是快指针)"></a>环形链表1,2(快慢指针,快指针最后为null或者最后一个,循环条件是快指针)</h2><h1 id="9-18"><a href="#9-18" class="headerlink" title="9.18"></a>9.18</h1><h2 id="常见http状态码？"><a href="#常见http状态码？" class="headerlink" title="常见http状态码？"></a>常见http状态码？</h2><ul><li>200，204，206.</li><li>301，302，304.</li><li>400，403，404.</li><li>500，502，503</li></ul><h2 id="get和post请求区别？"><a href="#get和post请求区别？" class="headerlink" title="get和post请求区别？"></a>get和post请求区别？</h2><ol><li>get获取数据，post修改</li><li>post有请求体</li><li>get安全，幂等</li><li>缓存</li></ol><h2 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>长连接，无需重复建立TCP连接。</li><li>管道运输。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>无状态</li><li>明文传输</li><li>队头阻塞，后面排序的请求无法发出。（管道传输大部分不支持）</li></ol><h2 id="http1-0和http1-1"><a href="#http1-0和http1-1" class="headerlink" title="http1.0和http1.1"></a>http1.0和http1.1</h2><ol><li>长连接短链接</li><li>强制缓存协商缓存字段区别</li><li>新增了状态码</li><li>范围请求：请求头加入range字段，请求部分数据，返回206。</li><li>是否支持管道运输</li><li>Host头部字段</li></ol><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><ul><li>在http和tcp中加入了ssl&#x2F;tls协议，数据加密&#x2F;身份认证&#x2F;信息完整</li></ul><ol><li>混合加密：非对称加密，对称加密</li><li>摘要算法+数字签名：提取内容hash值， 私钥加密，公钥解密，对比hash是否相同。（区分内容加密和数字证书加密）</li><li>数字证书：CA私钥给服务端得公钥加密形成数字证书，数字证书发送给客户端，客户端浏览器内嵌了CA公钥，解密数字证书获取公钥。</li></ol><h2 id="TLS握手"><a href="#TLS握手" class="headerlink" title="TLS握手"></a>TLS握手</h2><ol><li>客户端向服务端发送加密请求：版本号，随机数，密码套件。</li><li>服务端确定版本号和采用的算法，生成随机数，数字证书。</li><li>客户端生成第三个随机数，生成会话密钥。从数字证书中取出服务端公钥，通知后续采用加密数据通信。</li><li>服务端获取第三个随机数也生成会话密钥，后续采用加密数据通信。</li></ol><h2 id="证书信用链"><a href="#证书信用链" class="headerlink" title="证书信用链"></a>证书信用链</h2><h2 id="http2-0（不要忘了它是基于https）"><a href="#http2-0（不要忘了它是基于https）" class="headerlink" title="http2.0（不要忘了它是基于https）"></a>http2.0（不要忘了它是基于https）</h2><ol><li>头部压缩</li><li>二进制传输</li><li>并向传输</li><li>主动推送资源</li></ol><h2 id="http1-1优化"><a href="#http1-1优化" class="headerlink" title="http1.1优化"></a>http1.1优化</h2><ol><li>强制缓存协商缓存</li><li>减少http请求</li></ol><ul><li>减少重定向次数，代理服务器处理重定向。</li><li>合并请求，减少重复请求头部。</li><li>延迟发送请求：按需加载</li></ul><ol start="3"><li>压缩：减少传输的数据</li></ol><h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><ol><li>服务端主动推送，会先通知会在哪个streamID发送。请求了html，css也返回</li><li>头部压缩：静态表，哈夫曼表，动态表</li><li>二进制帧传输</li><li>并发请求：一个TCP上面多个steam流，每个steam流中包含<em><strong>一个</strong></em>http请求或者响应，每个http请求可能由多个frame组成。</li></ol><h1 id="9-22"><a href="#9-22" class="headerlink" title="9.22"></a>9.22</h1><h2 id="https优化"><a href="#https优化" class="headerlink" title="https优化"></a>https优化</h2><ol><li>协议优化:TLS升级,RSA算法&#x3D;&gt;ECDHE算法,2RTT到1RTT,支持前向保密性.</li><li>证书优化:证书验证是否过期:服务端周期性向CA查询证书状态,将结果直接返回给客户端,客户端不用再向CA请求.</li><li>会话复用:类似token的机制,快速识别身份.</li></ol><h2 id="http3-0"><a href="#http3-0" class="headerlink" title="http3.0"></a>http3.0</h2><ul><li>采用UDP+quic协议,解决队头阻塞+握手时延+连接迁移问题.</li></ul><ol><li>无队头阻塞,2.0某个流数据丢失会导影响其他流的数据接受,而3.0各个流之间无影响</li><li>更快的建立连接:quic协议握手和tls握手没有分层,quic协议握手一个RTT可以顺带上tls的信息,quic协议是用tls1.3,一次RTT可以完成建立连接和密钥协商.</li><li>连接迁移:(从4G网切换成wifi)quic协议握手时候协商了连接id,通过这个id可以快速恢复连接,避免原来的tcp,tls握手过程.</li><li>头部压缩:静态表扩充,动态表两个单向流同步.</li></ol><h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><ol><li>扫码登录时候,前端无法感知用户是否扫码,只能不断轮询请求后端.</li><li>长轮询机制,超时时间设置为30s,发出请求后30s内,服务端如果收到用户扫码的数据可以随时返回结果给客户端.</li></ol><h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><ul><li>基于tcp的协议</li><li>tcp是支持双向通信的(全双工),而http是单向通信(半双工)</li></ul><ol><li>使用websocket前会进行一次http通信,http请求头中携带upgrade:websocket字段</li></ol><h2 id="TCP传输层协议"><a href="#TCP传输层协议" class="headerlink" title="TCP传输层协议"></a>TCP传输层协议</h2><ol><li>面向连接</li><li>可靠的</li><li>基于字节流</li></ol><h2 id="UDP和TCP区别"><a href="#UDP和TCP区别" class="headerlink" title="UDP和TCP区别"></a>UDP和TCP区别</h2><ol><li>连接<br>tcp需要建立连接,udp直接传输数据</li><li>服务数量<br>tcp一对一,udp一对多</li><li>可靠<br>tcp可靠传输,udp不可靠传输</li><li>拥塞控制,流量控制</li><li>传输方式<br>tcp按顺序,udp不用</li></ol><h2 id="tcp和udp可以用同一个端口吗"><a href="#tcp和udp可以用同一个端口吗" class="headerlink" title="tcp和udp可以用同一个端口吗"></a>tcp和udp可以用同一个端口吗</h2><ul><li>可以,端口作用是传输层根据端口号将数据交付给不用的应用程序,ip包头的协议号可以知道该数据包是TCP&#x2F;UDP,然后交付给传输层的TCP&#x2F;UDP模块处理,然后根据端口号交给对应的应用程序.</li></ul><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ol><li>一开始都处于close状态,客户端打开连接,服务端被动打开进入listen状态.</li><li>客户端发送SYN同步标志为1,同时把初始化序号放到序号中,发送给服务端,客户端进入<em><strong>SYN-sent</strong></em>阶段.</li><li>服务端也同步SYN为1,ACK为1接受,确认号为客户端序号下一位,同时也把自己初始化序号放入序号中,服务端进入<em><strong>SYN-REC</strong></em>阶段.</li><li>客户端最后应答,ACK&#x3D;1,确认号为服务端序号下一位,这时可以携带数据发送.客户端进入ESTABLISHED状态</li><li>服务端收到后也进入ESTABLISHED(既定)状态.</li></ol><h2 id="为什么三次握手而不是两次"><a href="#为什么三次握手而不是两次" class="headerlink" title="为什么三次握手而不是两次?"></a>为什么三次握手而不是两次?</h2><ol><li>避免历史连接</li><li>同步双方初始序列号</li></ol><h2 id="为什么三次握手而不是四次"><a href="#为什么三次握手而不是四次" class="headerlink" title="为什么三次握手而不是四次?"></a>为什么三次握手而不是四次?</h2><ul><li>四次也可以,现在的第二次握手融合了四次的中间两次,ack和syn一起发送给客户端.</li></ul><h1 id="9-23"><a href="#9-23" class="headerlink" title="9.23"></a>9.23</h1><h2 id="第一次握手丢失-第二次握手丢失-第三次握手丢失"><a href="#第一次握手丢失-第二次握手丢失-第三次握手丢失" class="headerlink" title="第一次握手丢失,第二次握手丢失,第三次握手丢失"></a>第一次握手丢失,第二次握手丢失,第三次握手丢失</h2><ol><li>第一次: 客户端重传(没得到服务端响应),达到最大次数断开连接.</li><li>第二次: 客户端重传(没得到服务端响应),服务端重传(没得到客户端响应),达到最大次数断开连接.</li><li>第三次: 服务端重传,客户端收到后再重传第三次握手.(ACK应答不会主动传)</li></ol><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><ol><li>客户端打算关闭连接,发送FIN&#x3D;1,进入FIN_wait状态</li><li>服务端收到后回包ACK &#x3D; 1,进入CLOSED_WAIT状态</li><li>客户端收到ACK后进入FIN_wait2状态</li><li>服务端发送完数据后,发送FIN &#x3D; 1,进入last-ack</li><li>客户端收到后回包ACK &#x3D; 1,进入TIME_WAIT</li><li>服务端收到后进入CLOSE状态</li><li>客户端等2MSL（报文最大生存时间）后进入CLOSE状态</li></ol><h2 id="第一二三四次挥手丢失"><a href="#第一二三四次挥手丢失" class="headerlink" title="第一二三四次挥手丢失"></a>第一二三四次挥手丢失</h2><ol><li>第一次:客户端重传,达到最大次数后进入close状态</li><li>第二次:(ACK不会主动超时重传)客户端重传,服务端收到后再发送ACK.客户端达到最大次数后进入close状态.</li><li>第三次:服务端重传,达到最大次数后服务端close,客户端FIN_WAIT2状态等60s后进入close.</li><li>第四次:服务端重传,达到最大次数后close,客户端收到fin会重置TIME_WAIT时间(这里要原本等2MSL)</li></ol><h2 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h2><ul><li>MSL 报文最大生存时间</li></ul><ol><li>客户端ACK发出后,如果在最后丢失,服务端重传,重传的FIN可以在2MSL内到达客户端.</li></ol><h1 id="9-24"><a href="#9-24" class="headerlink" title="9.24"></a>9.24</h1><ul><li>投美团,滴滴,网易,B站,小红书,小米,拼多多.</li><li>投了美团</li></ul><h2 id="TCP滑动窗口-流量控制-拥塞控制"><a href="#TCP滑动窗口-流量控制-拥塞控制" class="headerlink" title="TCP滑动窗口,流量控制,拥塞控制."></a>TCP滑动窗口,流量控制,拥塞控制.</h2><h2 id="如何基于UDP协议实现可靠传输"><a href="#如何基于UDP协议实现可靠传输" class="headerlink" title="如何基于UDP协议实现可靠传输"></a>如何基于UDP协议实现可靠传输</h2><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><img src="/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.%E7%A7%8B%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image.png" alt="alt text"></p><h1 id="9-25"><a href="#9-25" class="headerlink" title="9.25"></a>9.25</h1><h2 id="为什么需要TIME-WAIT状态"><a href="#为什么需要TIME-WAIT状态" class="headerlink" title="为什么需要TIME_WAIT状态?"></a>为什么需要TIME_WAIT状态?</h2><ol><li>避免历史数据被后续连接吸收,2MSL可以让这次连接中的数据包自然丢失.</li><li>保证被关闭方可以正确关闭.如果ACK在最后丢失,服务端可以重传FIN在2MSL内到达客户端.</li></ol><h2 id="UDP是面向报文的协议-TCP是面向字节流的协议"><a href="#UDP是面向报文的协议-TCP是面向字节流的协议" class="headerlink" title="UDP是面向报文的协议,TCP是面向字节流的协议"></a>UDP是面向报文的协议,TCP是面向字节流的协议</h2><ol><li>UDP协议传输数据时候不会对数据进行拆分,每个UDP报文就是一个消息边界.</li><li>TCP发送的包大小取决于滑动窗口,(拥塞控制流量控制).</li></ol><h1 id="9-26"><a href="#9-26" class="headerlink" title="9.26"></a>9.26</h1><h2 id="如何解决沾包问题"><a href="#如何解决沾包问题" class="headerlink" title="如何解决沾包问题?"></a>如何解决沾包问题?</h2><ol><li>固定长度的消息.</li><li>http头部设置回车,换行两个为消息边界.</li></ol><h2 id="为什么可以三次挥手"><a href="#为什么可以三次挥手" class="headerlink" title="为什么可以三次挥手?"></a>为什么可以三次挥手?</h2><ul><li>需要四次原因是因为还有数据要发送,数据发送完再调用关闭函数进入LAST-ACK状态.</li></ul><ol><li><em><strong>没有数据发送</strong></em>且<em><strong>开启了TCP延迟确认机制</strong></em>,那么第二次和第三次挥手就回合并,三次挥手.</li><li>TCP延迟确认机制是优化单独发ACK数据效率低,延迟等待一段时间,如果有数据发送则和ACK一起发送,提高效率.</li></ol><h2 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP&#x2F;IP网络模型"></a>TCP&#x2F;IP网络模型</h2><ol><li>应用层:专注为用户提供应用功能,不关注数据传输</li><li>传输层:TCPUDP,将应用层报文作为数据部分,添加TCP头部(IP地址,端口信息,SYN,FIN标志位)流量控制,拥塞控制,可靠传输,有端口号信息,负责把数据交付给对应的应用程序.</li><li>网络层:IP协议,将传输层报文作为数据部分,添加IP头部,每一个设备对应一个ip地址:网络号+主机号,各个局域网通过路由器连接起来,路由器作用就是找到目的地址的子网,找到后把数据包发送到对应的子网了. </li><li>数据链路(网络接口)层:在ip数据基础上再加MAC头部尾部,封装成数据帧.ARP地址解析协议(ip与mac地址的映射表)通过mac地址找到对应的主机.</li></ol><h2 id="输入url后发生的过程"><a href="#输入url后发生的过程" class="headerlink" title="输入url后发生的过程"></a>输入url后发生的过程</h2><ol><li>解析url(协议+域名+资源路径),生成get请求</li><li>浏览器本地缓存</li><li>查询DNS服务器,获取域名对应的IP地址.先查询本地域名服务器缓存,本地域名服务器没有则向根域名服务器(最高级的域名服务器)请求,根域名服务器给出顶级域名服务器(.com),顶级域名服务器给权威域名服务器,权威域名服务器给对应IP地址.</li><li>TCP三次握手,如果是https的话还有tls四次握手.确保可靠传输,拥塞控制,流量控制.</li><li>IP协议:封装成ip数据包,借助路由器转发.</li><li>MAC地址:借助ARP协议获取mac地址,可能是对应网络的路由器mac地址,如果是同一个网络则是对应主机的mac地址.交换机负责同一网络下的交付.</li><li>同样流程返回数据.</li></ol><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ol><li>运行中的程序,包括数据段,程序段,PCB(进程控制块:描述进程的信息,比如程序存放的位置);</li></ol><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><ul><li>创建态,就绪态,运行态,阻塞态,结束态.</li><li>就绪挂起态,阻塞挂起态.大量阻塞态会占据有限的内存,可以将这些进程放到外存(磁盘中)</li></ul><h2 id="进程的控制和管理"><a href="#进程的控制和管理" class="headerlink" title="进程的控制和管理"></a>进程的控制和管理</h2><ol><li>PCB(进程的唯一标识):进程的状态,进程的优先级,CPU上下文信息</li><li>通过链表存储,相同状态存放在一起,比如:就绪队列,阻塞队列.更适应进程创建,销毁多的场景.</li></ol><h2 id="线程-并发-共享资源"><a href="#线程-并发-共享资源" class="headerlink" title="线程:并发 共享资源"></a>线程:并发 共享资源</h2><ol><li>CPU调度的基本单位,<em><strong>可以并发且共享资源的执行</strong></em>,相比进程上下文切换线程的切换速度更快.</li></ol><h2 id="进程和线程的区别-10024"><a href="#进程和线程的区别-10024" class="headerlink" title="进程和线程的区别 &#10024;"></a>进程和线程的区别 &#10024;</h2><ol><li>根本区别:进程是操作系统资源分配的基本单位,线程是CPU任务调度和执行的基本单位.</li><li>关系:进程包含一个或多个线程</li><li>资源开销:进程有独立的数据段和程序段,程序之间切换成本大;线程是轻量级的进程,同一进程下的线程共享程序段和数据段,线程有自己独立的PC(程序计数器:记录下一条指令的位置)和执行栈,线程切换成本低速度快.</li></ol><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><ol><li>先来先服务</li><li>最短作业优先</li><li>高响应比优先调度: (等待时间+要求服务时间)&#x2F;要求服务时间.</li><li>时间片轮调度算法</li><li>优先级调度算法</li></ol><h2 id="http1-1-1"><a href="#http1-1-1" class="headerlink" title="http1.1"></a>http1.1</h2><ol><li>强制缓存,协商缓存</li><li>host字段</li><li>增加更多状态码</li><li>允许局部请求</li><li>短连接,长连接</li></ol><h1 id="9-27"><a href="#9-27" class="headerlink" title="9.27"></a>9.27</h1><ul><li>白天搞完操作系统,晚上复习计算机网络</li></ul><h2 id="操作系统-1"><a href="#操作系统-1" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h3><h3 id="进程状态-进程管理"><a href="#进程状态-进程管理" class="headerlink" title="进程状态,进程管理"></a>进程状态,进程管理</h3><h3 id="调度算法-1"><a href="#调度算法-1" class="headerlink" title="调度算法"></a>调度算法</h3><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><h3 id="get-post区别"><a href="#get-post区别" class="headerlink" title="get,post区别"></a>get,post区别</h3><h3 id="http头部"><a href="#http头部" class="headerlink" title="http头部"></a>http头部</h3><h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h3><h3 id="输入url到页面展示过程"><a href="#输入url到页面展示过程" class="headerlink" title="输入url到页面展示过程"></a>输入url到页面展示过程</h3><h1 id="9-28"><a href="#9-28" class="headerlink" title="9.28"></a>9.28</h1><h2 id="计算机网络复习完"><a href="#计算机网络复习完" class="headerlink" title="计算机网络复习完"></a>计算机网络复习完</h2><h2 id="手写object-create"><a href="#手写object-create" class="headerlink" title="手写object.create"></a>手写object.create</h2><h2 id="手写instanceof"><a href="#手写instanceof" class="headerlink" title="手写instanceof"></a>手写instanceof</h2><h2 id="手写new"><a href="#手写new" class="headerlink" title="手写new"></a>手写new</h2><h2 id="手写promise-all"><a href="#手写promise-all" class="headerlink" title="手写promise.all"></a>手写promise.all</h2><h2 id="手写promise-race"><a href="#手写promise-race" class="headerlink" title="手写promise.race"></a>手写promise.race</h2><h1 id="9-29休息一天"><a href="#9-29休息一天" class="headerlink" title="9.29休息一天"></a>9.29休息一天</h1><h1 id="9-30"><a href="#9-30" class="headerlink" title="9.30"></a>9.30</h1><h2 id="setTimeout的this的问题"><a href="#setTimeout的this的问题" class="headerlink" title="setTimeout的this的问题"></a>setTimeout的this的问题</h2><h2 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h2><h2 id="手写类型判断"><a href="#手写类型判断" class="headerlink" title="手写类型判断"></a>手写类型判断</h2><h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call,apply,bind"></a>call,apply,bind</h2><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><h1 id="10-1"><a href="#10-1" class="headerlink" title="10.1"></a>10.1</h1><h2 id="函数柯里化-参数长度不固定-固定两种情况"><a href="#函数柯里化-参数长度不固定-固定两种情况" class="headerlink" title="函数柯里化:参数长度不固定&#x2F;固定两种情况"></a>函数柯里化:参数长度不固定&#x2F;固定两种情况</h2><h2 id="ajax发送请求"><a href="#ajax发送请求" class="headerlink" title="ajax发送请求"></a>ajax发送请求</h2><h2 id="promise封装ajax发送请求"><a href="#promise封装ajax发送请求" class="headerlink" title="promise封装ajax发送请求"></a>promise封装ajax发送请求</h2><h2 id="浅拷贝-深拷贝"><a href="#浅拷贝-深拷贝" class="headerlink" title="浅拷贝,深拷贝"></a>浅拷贝,深拷贝</h2><h2 id="数据处理-差一个解析url参数"><a href="#数据处理-差一个解析url参数" class="headerlink" title="数据处理(差一个解析url参数)"></a>数据处理(差一个解析url参数)</h2><h1 id="10-2"><a href="#10-2" class="headerlink" title="10.2"></a>10.2</h1><h2 id="代码输出题this"><a href="#代码输出题this" class="headerlink" title="代码输出题this."></a>代码输出题this.</h2><h2 id="代码输出题-作用域"><a href="#代码输出题-作用域" class="headerlink" title="代码输出题:作用域"></a>代码输出题:作用域</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ol><li>var申明会提升,函数执行上下文或全局执行上下文</li><li>注意如果函数或全局有if等其他大括号包含的var申明,也会提升到函数和全局.</li></ol><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><ul><li>代码执行环境的抽象概念</li><li>全局执行上下文,函数执行上下文</li><li>执行栈</li><li>创建(this指向,词法环境: let const,变量环境)-执行-销毁</li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul><li>变量和函数可以被访问的区域</li><li>全局作用域,函数作用域,块级作用域</li><li>词法作用域</li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li>一个函数访问另一个函数中的变量,一个函数捆绑了另一个函数的词法环境,这个函数就是闭包.</li><li>原理:函数在定义时候会创建作用域链,保存在<code>[[scope]]</code>中,当执行这个函数时候会创建函数上下文(包括词法环境),复制scope并将该词法环境推到作用域链最前端</li><li>创建私有变量,延长变量的生命周期.</li></ul><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><ol><li>new构造函数</li><li>call,apply,bind</li><li>对象调用</li><li>全局调用</li></ol><h1 id="10-3"><a href="#10-3" class="headerlink" title="10.3"></a>10.3</h1><h2 id="执行上下文-作用域-闭包-代码输出题总结-this-作用域"><a href="#执行上下文-作用域-闭包-代码输出题总结-this-作用域" class="headerlink" title="执行上下文,作用域,闭包 + 代码输出题总结:this,作用域"></a>执行上下文,作用域,闭包 + 代码输出题总结:this,作用域</h2><h2 id="对象-基本概念-创建-继承"><a href="#对象-基本概念-创建-继承" class="headerlink" title="对象 : 基本概念,创建,继承"></a>对象 : 基本概念,创建,继承</h2><h2 id="原型链-代码输出题"><a href="#原型链-代码输出题" class="headerlink" title="原型链+ 代码输出题"></a>原型链+ 代码输出题</h2><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><ul><li>为变量分配内存,当变量不再被访问时候清除,回收内存</li><li>标记清除: 垃圾回收器遍历所有对象,可访问的变量标记,对于没有标记的对象进行清除.</li><li>引用计数: 循环引用.</li><li>标记清除之上: 分代收集:新生代存放生命周期短的变量频繁清理,新生代变量可能变为老生代,清理频率低</li><li>内存泄漏: 全局变量,dom引用,未关闭的定时器,错误的闭包使用.</li></ul><h1 id="10-4"><a href="#10-4" class="headerlink" title="10.4"></a>10.4</h1><h2 id="复习对象-原型链-this-垃圾回收机制-9989"><a href="#复习对象-原型链-this-垃圾回收机制-9989" class="headerlink" title="复习对象,原型链,this,垃圾回收机制 &#9989;"></a>复习对象,原型链,this,垃圾回收机制 &#9989;</h2><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="异步-1"><a href="#异步-1" class="headerlink" title="异步"></a>异步</h3><ul><li>js是单线程,不会一直等请求回来,去执行其他代码,就有了异步概念.任务分为同步任务和异步任务,同步代码按顺序进主线程执行,异步任务分为宏任务队列和微任务队列,同步任务执行完后再执行微任务队列.</li></ul><h3 id="事件循环-1"><a href="#事件循环-1" class="headerlink" title="事件循环"></a>事件循环</h3><ul><li>先执行第一个大的宏任务script,执行同步代码,有微任务推进微任务队列,有宏任务推进宏任务队列.同步执行完后执行微任务队列,然后执行下一个宏任务.依次类推.</li></ul><h3 id="promise和async-看了promise输出的前12题"><a href="#promise和async-看了promise输出的前12题" class="headerlink" title="promise和async,看了promise输出的前12题"></a>promise和async,看了promise输出的前12题</h3><ol><li>promise是一个有状态的对象,创建时候传入执行器函数,在执行器函数里初始化异步行为和控制promise最终状态的转换,执行器函数是同步执行的.</li><li>状态有pending,fulfilled,rejected三种,状态落定后是不可改变的.</li><li>promise的状态代表异步行为是否完成,通过resolve,reject函数决定.</li></ol><h2 id="浏览器渲染原理-1"><a href="#浏览器渲染原理-1" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><ul><li><a href="https://segmentfault.com/a/1190000042909353">https://segmentfault.com/a/1190000042909353</a></li></ul><ol><li>解析html文档,生成DOM树,由html元素和属性节点组成.</li><li>解析css,生成css树.</li><li>根据DOM树和CSS树构建渲染树</li><li>布局(回流):渲染树进行布局计算每个渲染节点的位置和大小.</li><li>绘制(重绘):将渲染树的节点绘制到页面上.</li><li>复合: 浏览器的绘制是绘制到多层,每一层单独渲染,最后合成到一起形成页面.</li><li>重绘:重绘不会带来重新布局,一般是修改背景颜色,边框阴影等属性.</li><li>回流:消耗性能,改变元素位置,DOM结构发生变化.</li></ol><h2 id="浏览器渲染优化-1"><a href="#浏览器渲染优化-1" class="headerlink" title="浏览器渲染优化"></a>浏览器渲染优化</h2><ol><li>js: script标签写在body后面. 用async和defer.</li><li>css:用link引入,开启一个线程去加载,不阻塞GUI渲染线程. @import:GUI线程会停止渲染去加载资源. css少的话就写在style标签中直接GUI渲染.</li><li>html:减少嵌套层次,减少回流重绘操作</li></ol><h2 id="减少回流和重绘操作-1"><a href="#减少回流和重绘操作-1" class="headerlink" title="减少回流和重绘操作"></a>减少回流和重绘操作</h2><ol><li>操作低层次的DOM.</li><li>脱离文档流,减少对其他元素影响.</li><li>将DOM读写操作分别放到一起,浏览器的渲染队列机制.</li><li>一些css属性形成新的合成层: transform,opacity等等.浏览器把这些变化交给GPU处理(不是所有合成层都给GPU,只有动画视觉效果时候交给GPU),GPU直接在显存中更改元素显示位置,无需CPU进行布局绘制的计算.</li></ol><h2 id="算法继续推进"><a href="#算法继续推进" class="headerlink" title="算法继续推进"></a>算法继续推进</h2><h2 id="准备进入vue"><a href="#准备进入vue" class="headerlink" title="准备进入vue"></a>准备进入vue</h2><h1 id="10-5"><a href="#10-5" class="headerlink" title="10.5"></a>10.5</h1><h2 id="js基础"><a href="#js基础" class="headerlink" title="js基础"></a>js基础</h2><h3 id="栈内存-堆内存"><a href="#栈内存-堆内存" class="headerlink" title="栈内存,堆内存"></a>栈内存,堆内存</h3><ul><li><a href="https://juejin.cn/post/7264503343995912246#heading-1">https://juejin.cn/post/7264503343995912246#heading-1</a></li><li>堆内存才有垃圾回收机制,栈内存在函数调用变量声明时候压入数据,函数执行完变量词法环境销毁时候压出栈.</li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li>+运算符有字符串时候进行拼接.其他运算符都是能转换为数字都转换为数字.</li></ul><h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><ul><li>对象一般调用的都是Object.prototype上面的同String()方法,但function和date两个内置对象在原型上重写了toString()方法.</li></ul><h3 id="let-const-var"><a href="#let-const-var" class="headerlink" title="let,const,var"></a>let,const,var</h3><ol><li>变量提升,作用死区</li><li>重复声明</li><li>块级作用域</li><li>var给全局window对象添加属性</li><li>const要设置初始值.<br>10.5 - 10.7vue搞完,后面进webpack,css.</li></ol><h1 id="10-6"><a href="#10-6" class="headerlink" title="10.6"></a>10.6</h1><h2 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h2><h2 id="map-weakMap-10024"><a href="#map-weakMap-10024" class="headerlink" title="map weakMap &#10024;"></a>map weakMap &#10024;</h2><ul><li>键有顺序,任意值,没有原型其他键,本质其实是一个二维数组. 有size,可遍历.</li><li>weakMap键只能为对象,且为弱引用,垃圾回收机制不会考虑weakMap的引用,如果对象没有其他引用,会自动清除weakMap的键及其的值.</li><li>set get has delete clear</li></ul><h2 id="set-weakSet-10024"><a href="#set-weakSet-10024" class="headerlink" title="set weakSet &#10024;"></a>set weakSet &#10024;</h2><ol><li>NaN是相等的,<em><strong>两个对象是不相等的</strong></em>.</li><li>add has delete clear</li><li>weakSet只能放对象和symbol值,都是弱引用,不考虑垃圾回收机制.</li></ol><h2 id="JSON-stringify-JSON-prase-10024"><a href="#JSON-stringify-JSON-prase-10024" class="headerlink" title="JSON.stringify JSON.prase &#10024;"></a>JSON.stringify JSON.prase &#10024;</h2><ol><li>function,symbol,undefined,不可枚举属性会消失,NaN&#x3D;&#x3D;&gt;null</li><li>原型链 循环引用不会转换</li></ol><h2 id="es和commonjs模块化区别"><a href="#es和commonjs模块化区别" class="headerlink" title="es和commonjs模块化区别"></a>es和commonjs模块化区别</h2><h2 id="AST语法树生成过程"><a href="#AST语法树生成过程" class="headerlink" title="AST语法树生成过程"></a>AST语法树生成过程</h2><ol><li>模板裁剪到为空,开始标签,结束标签,文本标签.</li><li>生成ast节点.</li><li>栈和全局变量:控制父子节点关系和根节点.</li><li>返回ast树.</li></ol><h2 id="ast语法树和虚拟dom区别"><a href="#ast语法树和虚拟dom区别" class="headerlink" title="ast语法树和虚拟dom区别?"></a>ast语法树和虚拟dom区别?</h2><ol><li>ast语法树出现在编译阶段,一般是开发环境的构建工具(如vite)启的服务器上执行,把.vue文件生成js代码,生成一个render渲染函数.</li><li>虚拟DOM出现在运行阶段,由浏览器执行js代码,执行render函数生成虚拟DOM,diff对比,最后生成新的DOM页面.</li></ol><h2 id="npm-run-build理解"><a href="#npm-run-build理解" class="headerlink" title="npm run build理解?"></a>npm run build理解?</h2><ul><li>Vue 项目会将 .vue 文件中的内容转换为 JavaScript，并进行编译、优化，最终打包为浏览器可执行的 JavaScript 文件。然而，这个打包后的文件通常不包含 AST 转换相关的函数文件或编译器代码。</li><li>vue的两个版本:生产环境版本和运行时版本,运行版本没有编译器功能.</li></ul><h2 id="AST语法对象-render函数-虚拟DOM"><a href="#AST语法对象-render函数-虚拟DOM" class="headerlink" title="AST语法对象 &#x3D;&gt; render函数 &#x3D;&gt; 虚拟DOM"></a>AST语法对象 &#x3D;&gt; render函数 &#x3D;&gt; 虚拟DOM</h2><ul><li>代码拼接,生成字符串,_c,_v函数,这些函数是生成虚拟DOM节点.</li><li>new Function,with(this)</li><li>执行,去组件对象上拿数据,生成虚拟DOM.</li></ul><h2 id="vue2的diff算法"><a href="#vue2的diff算法" class="headerlink" title="vue2的diff算法"></a>vue2的diff算法</h2><ul><li>对比是否为相同节点,如果标签名和key相同,则复用旧节点的DOM.</li><li>修改文本内容和DOM属性</li><li>对比孩子<br>头头,尾尾,头尾,映射表</li></ul><h2 id="vue3的diff算法"><a href="#vue3的diff算法" class="headerlink" title="vue3的diff算法"></a>vue3的diff算法</h2><ul><li>只有头头指针和尾尾指针对比,最长递增子序列 </li><li>对事件缓存,缓存监听器,减少监听器的重复创建和销毁.</li><li>静态标记</li></ul><h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><h2 id="数组响应式原理"><a href="#数组响应式原理" class="headerlink" title="数组响应式原理"></a>数组响应式原理</h2><h2 id="vue2响应式原理缺点-vue3响应式原理"><a href="#vue2响应式原理缺点-vue3响应式原理" class="headerlink" title="vue2响应式原理缺点,vue3响应式原理"></a>vue2响应式原理缺点,vue3响应式原理</h2><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><ul><li>监听的数据会封装成一个函数,函数会默认执行一次,读取数据,数据调用get收集该watcher.</li></ul><h1 id="10-7"><a href="#10-7" class="headerlink" title="10.7"></a>10.7</h1><ul><li>看完vue的read,interview.</li></ul><h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><h2 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h2><ul><li>创建watcher</li></ul><ol><li>lazy,默认不求值.</li><li>dirty,有缓存.</li><li>默认脏数据,执行回调函数,读取里面的响应式数据,里面的数据收集计算属性的watcher,当里面的数据被更改时候,触发notify,让计算属性变为脏数据,重新求值.</li><li>(代理到组件对象上)</li></ol><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol><li>watcher去重,渲染函数只会执行一次</li><li>底层调用了nextTick方法,js事件循环的应用,有一个队列缓冲这次事件循环所有的同步任务,上一个队列执行完后才能执行下一个队列.</li><li>优雅降级: promise.then &#x3D;&gt; mutationObserver &#x3D;&gt; setImmediate &#x3D;&gt; setTimeout.</li></ol><h2 id="Vue-extend-为什么data为函数"><a href="#Vue-extend-为什么data为函数" class="headerlink" title="Vue.extend(为什么data为函数)"></a>Vue.extend(为什么data为函数)</h2><ul><li>返回子构造函数,选项相同则复用子构造函数,如果不为函数则共享对象内存地址.</li></ul><h2 id="Vue-mixin"><a href="#Vue-mixin" class="headerlink" title="Vue.mixin"></a>Vue.mixin</h2><ol><li>Vue.options</li></ol><h2 id="组件渲染过程"><a href="#组件渲染过程" class="headerlink" title="组件渲染过程"></a>组件渲染过程</h2><ul><li>父组件在创建虚拟DOM时候,遇到子组件标签时会把自己身上的子组件构造函数(核心:父组件的选项中有子组件的构造函数)放到子组件虚拟DOM上.</li><li>父组件渲染到子组件时候,会调用子组件虚拟DOM上的init方法,创建组件实例进行渲染.</li></ul><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul><li>补丁函数.</li></ul><h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><ul><li>组件不需要上来就渲染,避免同步加载卡顿页面,异步引入.先渲染一个占位组件,后续加载完后重新渲染.</li><li>异步组件本身是一个promise对象,pending状态时候返回占位组件,等promise状态变为resolve或reject时候重新渲染.</li></ul><h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><ol><li>组件类型分为类组件和函数式组件,类组件有this.函数式组件没有this,生命周期,watcher</li><li>调用h函数&#x2F;render返回虚拟DOM直接进行渲染,适合只有渲染逻辑的情况.</li></ol><h2 id="props原理"><a href="#props原理" class="headerlink" title="props原理"></a>props原理</h2><ul><li>创建组件虚拟节点时候会拿到组件声明的props,与传入到组件的属性一一映射,如果属性中找到props申明,会把该属性单独拿出来放到componentOptions上.</li><li>初始化init时候把props放到组件实例$options上,并把props属性定义为响应式放到组件上(可以直接被模板读取).</li></ul><h2 id="props为什么是单向数据流"><a href="#props为什么是单向数据流" class="headerlink" title="props为什么是单向数据流?"></a>props为什么是单向数据流?</h2><ul><li>props数据的setter里面会进行判断,是否为根组件,是否为父组件,否则报错.</li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul><li>创建组件虚拟节点时候把事件放到虚拟节点$listener</li><li>初始化init时候放到组件实例的$options上.</li><li>从组件实例上拿事件,组件实例有个event属性维护事件,<code>$on</code>把事件名和事件绑定到上面,$emit从event数组中取出事件执行.</li></ul><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><h3 id="默认-具名插槽"><a href="#默认-具名插槽" class="headerlink" title="默认&#x2F;具名插槽"></a>默认&#x2F;具名插槽</h3><ul><li>父组件调用渲染函数的时候创建插槽的虚拟节点,所以插槽这个时候使用的是父组件的数据.将插槽虚拟节点作为子组件虚拟节点的属性.子组件初始化创建组件实例后将插槽虚拟节点放到组件实例上,同时解析插槽虚拟节点是否有slot属性,有的话就是具名插槽,会和默认插槽区分.渲染子组件时候遇到slot标签则去组件实例上获取插槽.</li></ul><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><ul><li>不会再直接创建插槽虚拟节点作为子组件虚拟节点属性,而是将其格式化为一个函数再作为属性.</li><li>子组件初始化时候将函数放到组件实例上</li><li>子组件渲染时候,在slot标签上通过name找到对应的函数,传入参数.函数执行&#x3D;&gt;插槽虚拟节点.</li></ul><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><ol><li>keep-alive也是个组件,它里面的组件也是插槽,在父组件执行渲染函数时候会把插槽虚拟节点作为keep-alive虚拟节点的属性</li><li>keep-alive虚拟节点初始化后将插槽虚拟节点放到组件实例上.</li><li>includes判断该插槽虚拟节点是否需要缓存,不需要直接返回虚拟节点,然后渲染.<br>需要的话:<br>判断是否在缓存数组中,在的话删除key,然后将这个组件key放置末尾(LRU算法)<br>不存在的话,则把key加入末尾,如果数组长度超过max则去除最长未使用的组件key.</li></ol><h2 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide,inject"></a>provide,inject</h2><ul><li>在组件init中有个initprovide方法,会在当前组件实例上添加一个_provide属性,provide提供的数据都会存储在里面.</li><li>子组件inject数据时递归查询父组件的_provide属性,找到为止.会先在自己的_provide属性上查找,所以依赖来源不明确.</li></ul><h2 id="v-if和v-for优先级"><a href="#v-if和v-for优先级" class="headerlink" title="v-if和v-for优先级"></a>v-if和v-for优先级</h2><ul><li>vue2中,v-for优先级高于v-if,vue3相反.</li></ul><h2 id="v-if和v-show区别及其原理"><a href="#v-if和v-show区别及其原理" class="headerlink" title="v-if和v-show区别及其原理"></a>v-if和v-show区别及其原理</h2><ul><li>v-if控制是否渲染虚拟节点</li><li>v-show,display属性为原先值还是none</li></ul><h2 id="display-visibility-opacity"><a href="#display-visibility-opacity" class="headerlink" title="display,visibility,opacity"></a>display,visibility,opacity</h2><ol><li>空间上,display不占据,其他占据</li><li>性能上:display回流重绘,visibility重绘,opacity单独形成合成层,利用GPU加速渲染</li><li>事件上:opacity触发事件</li></ol><h2 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h2><ul><li>非组件情况:v-bind+@input的语法糖.</li><li>组件情况: props+绑定事件的语法糖</li></ul><h1 id="10-8"><a href="#10-8" class="headerlink" title="10.8"></a>10.8</h1><ul><li>复习vue</li></ul><h2 id="打家劫舍1"><a href="#打家劫舍1" class="headerlink" title="打家劫舍1"></a>打家劫舍1</h2><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><h2 id="MVC-MVVM-MVP"><a href="#MVC-MVVM-MVP" class="headerlink" title="MVC MVVM MVP"></a>MVC MVVM MVP</h2><ol><li><em><strong>MVC观察者模式model可直接到view</strong></em>:采用了<strong>观察者模式</strong>,数据更改立即通知页面更新.数据和页面有一定耦合性.页面更改时,会触发controller来控制model层数据更新.</li><li><em><strong>MVP</strong></em>:view和model都需要经过中间处理.</li><li><em><strong>MVVM</strong></em>:VM对P的升级,将手动的   数据更改&#x3D;&gt;页面 操作自动化.降低代码复杂度</li></ol><h2 id="computed和watch区别"><a href="#computed和watch区别" class="headerlink" title="computed和watch区别"></a>computed和watch区别</h2><ol><li>computed:同步,缓存.</li><li>watch: 异步,不缓存.</li></ol><h2 id="computed和method区别"><a href="#computed和method区别" class="headerlink" title="computed和method区别"></a>computed和method区别</h2><ol><li>computed缓存,依赖的值未变化时候不会执行函数.</li><li>method总会执行函数.</li></ol><h2 id="slot默认插槽-具名插槽-作用域插槽"><a href="#slot默认插槽-具名插槽-作用域插槽" class="headerlink" title="slot默认插槽,具名插槽,作用域插槽"></a>slot默认插槽,具名插槽,作用域插槽</h2><ol><li>创建子组件虚拟节点时候把插槽虚拟节点作为其属性</li><li>子组件实例init后,插槽虚拟节点放到$slot属性上</li><li>子组件调用render函数时候遇到slot标签用插槽虚拟节点替换.</li></ol><h2 id="如何保存当前页面状态"><a href="#如何保存当前页面状态" class="headerlink" title="如何保存当前页面状态"></a>如何保存当前页面状态</h2><ol><li>localStorage,sessionStorage.</li><li>路由传值</li><li>vuex(微前端在全局事件总线)</li><li>父组件存储</li></ol><h2 id="事件模型-1"><a href="#事件模型-1" class="headerlink" title="事件模型"></a>事件模型</h2><ol><li>DOM0事件模型: 没有事件流</li><li>IE事件模型: 事件触发,事件冒泡</li><li>DOM2事件模型:事件捕获,事件触发,事件冒泡.(从document一直往下传播到目标元素)</li></ol><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><ol><li>.stop阻止冒泡</li><li>.prevent阻止默认事件</li><li>.capture事件捕获模型</li><li>.self只触发自己</li><li>.once只触发一次</li></ol><h2 id="v-html原理"><a href="#v-html原理" class="headerlink" title="v-html原理"></a>v-html原理</h2><ol><li>移除当前元素下的所有标签,添加innerHtmL,值为v-html的值.</li></ol><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><ol><li>表单元素上: v-bind + @input</li><li>组件元素上: props + 绑定事件</li></ol><h2 id="data为什么是一个函数"><a href="#data为什么是一个函数" class="headerlink" title="data为什么是一个函数?"></a>data为什么是一个函数?</h2><ul><li>Vue.extend返回构造函数,传入的选项放在构造函数上.如果选项相同则会复用构造函数,因此多个组件实例的data会访问同一个共享地址的对象.</li></ul><h2 id="keep-alive原理"><a href="#keep-alive原理" class="headerlink" title="keep-alive原理"></a>keep-alive原理</h2><ol><li>keep-alive也为一个组件,将插槽虚拟节点作为keepalive组件虚拟节点的属性</li><li>创建keepalive组件实例时候把插槽节点放到组件实例$slots上.</li><li>调用render函数创建真实节点,includes判断是否在缓存数组中,不在的话直接返回虚拟节点渲染.在的话,在缓存数组中查看是否有,有的话移到数组末尾.(LRU算法)不在的话添加到数组末尾.超过max则删除第一个.</li></ol><h2 id="nextTick-1"><a href="#nextTick-1" class="headerlink" title="nextTick"></a>nextTick</h2><ol><li>对js事件循环的应用,利用js的异步任务队列实现vue框架的异步任务队列.</li><li>如果是同步更新,多次对一个属性赋值会频繁触发DOM渲染,可以减少无用渲染</li></ol><h1 id="10-9"><a href="#10-9" class="headerlink" title="10.9"></a>10.9</h1><ul><li>上午复习完vue.30min:生命周期+组件通信.剩下时间vue基础,但上午要进入vue-router</li><li>下午vue-router+vuex+刷题</li><li>后续规划: vue复习,项目亮点,算法,webpack和css</li></ul><h2 id="TCP-UDP区别"><a href="#TCP-UDP区别" class="headerlink" title="TCP,UDP区别"></a>TCP,UDP区别</h2><ol><li>连接,可靠,流量控制拥塞控制,字节流包,服务对象.</li></ol><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><h2 id="两次握手不行原因"><a href="#两次握手不行原因" class="headerlink" title="两次握手不行原因?"></a>两次握手不行原因?</h2><ol><li>避免历史连接<br>服务端没有中间状态给客户端阻止连接,导致服务端建立一个无用的历史连接浪费资源.<br>三次握手客户端在收到服务端ACK时候可以判断是否为正确序号.</li><li>避免资源浪费:两次握手的话服务端在收到客户端SYN后就会进行通信.</li><li>同步双方初始化序号:服务端发送初始化序号时候客户端需要应答回应ack.</li></ol><h2 id="数组响应式-set"><a href="#数组响应式-set" class="headerlink" title="数组响应式,$set"></a>数组响应式,$set</h2><ol><li>Observer处理对象属性为set,get时也会给对象本身加一个dep类,该dep类也会会收集其属性依赖的watcher.</li><li>$set其实就是手动调用了该对象dep类的notify通知watcher更新执行渲染函数</li><li>数组方法进行了重写,一是调用原来的数组方法,二是调用数组的dep.notify().</li></ol><h2 id="单页面和多页面"><a href="#单页面和多页面" class="headerlink" title="单页面和多页面"></a>单页面和多页面</h2><ol><li>单页面一次性加载资源,多页面多次加载</li><li>路由:单页面应用:history,hash.多页面应用通过路径跳转.</li><li>数据传递:单页面vuex.多页面cookie,localStorage,sessionStorage,接口保存.</li><li>单页面局部更新,切换速度快.多页面全局更新,切换速度慢.</li></ol><h2 id="react和vue区别"><a href="#react和vue区别" class="headerlink" title="react和vue区别"></a>react和vue区别</h2><h2 id="Vue优点"><a href="#Vue优点" class="headerlink" title="Vue优点"></a>Vue优点</h2><h2 id="assets和static区别"><a href="#assets和static区别" class="headerlink" title="assets和static区别"></a>assets和static区别</h2><ol><li>两者都可以存储静态资源,图片样式等等.</li><li>assets文件在npm run build时候会进行打包压缩,最后一起放到static中跟随index.html一同上传到服务器.</li><li>static资源不会走打包压缩格式化流程,而是直接进入打包后的目录上传至服务器.效率跟高,但占用体积更大.</li></ol><h2 id="delete和Vue-delete"><a href="#delete和Vue-delete" class="headerlink" title="delete和Vue.delete"></a>delete和Vue.delete</h2><ol><li>两者对对象处理结果相同</li><li>对数组处理:delete会把数组对应元素变为empty或undefined,Vue.delete会改变数组长度.</li></ol><h2 id="SSR服务端渲染"><a href="#SSR服务端渲染" class="headerlink" title="SSR服务端渲染?"></a>SSR服务端渲染?</h2><ul><li>优点:</li></ul><ol><li>更快的首屏加载速度.服务端根据请求路径获取到对应组件,服务端组件请求数据,将组件渲染为html.将html和vue文件作为响应内容返回给客户端.客户端渲染页面,并加载vue文件,将页面变为动态页面.</li><li>更好支持SEO,搜索引擎爬虫可以获取到完全渲染的页面.</li></ol><ul><li>缺点:</li></ul><ol><li>只支持beforeCreate钩子和created钩子.</li><li>增大服务端压力.</li></ol><h2 id="对SPA单页面应用的理解"><a href="#对SPA单页面应用的理解" class="headerlink" title="对SPA单页面应用的理解?"></a>对SPA单页面应用的理解?</h2><ul><li>优点:</li></ul><ol><li>一次性获取所有js,css,html文件,减少服务端压力.</li><li>内容改动无需重新加载整个页面,局部更新页面.</li><li>前后端分离,前端负责图层,后端负责数据层.</li></ol><ul><li>缺点:</li></ul><ol><li>首屏加载速度慢</li><li>客户端占用更多内存和cpu资源.</li><li>前端手动实现路由,管理浏览器前进后退功能.</li></ol><h2 id="vue初始化页面闪动问题"><a href="#vue初始化页面闪动问题" class="headerlink" title="vue初始化页面闪动问题"></a>vue初始化页面闪动问题</h2><ul><li>数据异步获取,页面先渲染完出现闪动情况.</li><li>解决方法:[v-cloak]:{display:none}</li></ul><h2 id="MVVM优缺点"><a href="#MVVM优缺点" class="headerlink" title="MVVM优缺点"></a>MVVM优缺点</h2><ol><li>将视图和数据解耦合,提高视图和数据的复用性.</li><li>双向绑定,无需编写复杂的操作DOM逻辑.</li></ol><h2 id="生命周期-10024"><a href="#生命周期-10024" class="headerlink" title="生命周期 &#10024;"></a>生命周期 &#10024;</h2><ol><li>beforeCreate:调用组件init方法时候调用,此时无法访问初始化数据,创建页面watcher,计算属性等等.</li><li>created:响应式数据,计算属性,监听器等初始化完成,但还未进入渲染阶段.</li><li>beforeMount:模板编译,将模板转换为AST语法树,代码拼接成渲染函数,执行渲染函数生成虚拟DOM,diff对比后生成真实DOM.但未挂载到容器上.</li><li>mounted:将生成的html挂载到容器上.</li><li>beforeUpdate:响应式数据更新时调用,此时数据进行了更新,但页面还未渲染.</li><li>updated:render函数重新执行,页面更新.</li><li>beforeUnmount:组件实例销毁前调用,此时还保留了组件所有功能.</li><li>unMounted: 组件卸载完后调用,清除定时器 DOM监听器等等.</li></ol><h2 id="父子组件执行顺序"><a href="#父子组件执行顺序" class="headerlink" title="父子组件执行顺序"></a>父子组件执行顺序</h2><ul><li>加载渲染过程:父组件beforeCreate,created,beforeMount,子组件一直到mounted,父组件mounted.</li><li>更新过程:父组件beforeUpdate,子组件beforeUpdate,updated,父组件updated.</li><li>销毁过程: 父组件beforeUmount,子组件before&#x3D;&gt;unmounted,父组件unmounted.</li></ul><h2 id="keep-alive生命周期"><a href="#keep-alive生命周期" class="headerlink" title="keep-alive生命周期"></a>keep-alive生命周期</h2><ul><li>deactivated,activated</li></ul><h2 id="组件通信-10024"><a href="#组件通信-10024" class="headerlink" title="组件通信 &#10024;"></a>组件通信 &#10024;</h2><ol><li>props,emits.</li><li>vuex.pinia</li><li>事件总线</li><li>provide,inject</li><li>ref</li><li>$attrs</li><li>localStorage,cookie</li></ol><h2 id="项目中的通信"><a href="#项目中的通信" class="headerlink" title="项目中的通信"></a>项目中的通信</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-number">1</span>. props:defineProps.@update:defineEmits,emits([&#x27;update&#x27;]);<br><span class="hljs-number">2</span>. 全局vuex存储:用户信息及其所在组织架构的基本信息,权限节点,是否为白名单,可以访问<br>的模板.<br><span class="hljs-number">3</span>. 基于vuex的事件总线,Bus类共享了vuex数据,并且支持数据总线实现各个子应用之间通<br>信. 每个子应用都需要选择一个模板,红一政治,色情等等.<br><span class="hljs-number">3.1</span>: 子应用把自己需要初始化的事件绑定到总线,主应用监听到模板变化时候<span class="hljs-string">$e</span>mit子应用初<br>始化事件.<br><span class="hljs-number">3.2</span>: 子应用<span class="hljs-string">$o</span>n绑定解锁事件,解锁按钮在主应用模板,主应用<span class="hljs-string">$e</span>mit触发解锁.<br><br><br><span class="hljs-number">4</span>. provide,inject<br><span class="hljs-number">5</span>. ref<br><span class="hljs-number">6</span>. <span class="hljs-string">$a</span>ttrs<br></code></pre></td></tr></table></figure><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><ol><li>箭头函数+import</li></ol><h2 id="路由hash-history模式"><a href="#路由hash-history模式" class="headerlink" title="路由hash&#x2F;history模式"></a>路由hash&#x2F;history模式</h2><ul><li>后端路由</li></ul><ol><li>服务端根据客户端的请求路径找到对应组件,将页面渲染完后返回给客户端.seo优化好,但服务端压力大.</li></ol><ul><li>前端路由<br>js动态改变html.前端路由就是基于SPA实现,对url进行处理,使每一个url对应一个资源,监听url变化执行操作.</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">hash模式:<br><span class="hljs-bullet">1.</span> hash值是#xxx<br><span class="hljs-bullet">2.</span> 只出现在url中,请求时候不会发送给后端.<br><span class="hljs-bullet">3.</span> 监听onhashchange事件加载对应的页面<br><span class="hljs-bullet">4.</span> hash值变化会被浏览器监听下来,实现浏览器前进后退. <br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">history模式:<br><span class="hljs-bullet">1.</span> 没有#.<br><span class="hljs-bullet">2.</span> historyAPI主要分外两个部分:<br>pushstate,repalcestate<br>go,back,forward<br><span class="hljs-bullet">3.</span> 通过监听pushstate和replacestate去加载对应页面.<br></code></pre></td></tr></table></figure><h2 id="vue中路由模式"><a href="#vue中路由模式" class="headerlink" title="vue中路由模式"></a>vue中路由模式</h2><ul><li><p>createWebHistory创建history模式.</p></li><li><p>createWebHashHistory创建hash模式.</p></li></ul><h2 id="route-router"><a href="#route-router" class="headerlink" title="$route,$router"></a><code>$route</code>,<code>$router</code></h2><ul><li>route是当前路由信息对象,包括path,params,query,</li><li>router是路由实例,包括跳转方法,钩子函数.</li></ul><h1 id="10-10"><a href="#10-10" class="headerlink" title="10.10"></a>10.10</h1><h2 id="路由钩子"><a href="#路由钩子" class="headerlink" title="路由钩子"></a>路由钩子</h2><ol><li>全局前置守卫:获取权限节点,判断用户是否有权限进入该页面.进入的页面主应用判断是启动子应用还是主应用,如果是子应用则启动qiankun框架.</li><li>组件内守卫:beforeRouteEnter,beforeRouteLeave,beforeRouteUpdate.</li><li>路由守卫: beforeEnter,嵌套组件时候可以在父路由匹配规则加上路由守卫,则子路由都会触发.</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css">顺序:<br><span class="hljs-number">1</span>. beforeRouteLeave<br><span class="hljs-number">2</span>. beforeEach<br><span class="hljs-number">3</span>. 重用组件调用beforeRouteUpdate<br><span class="hljs-number">4</span>. 调用路由守卫beforeEnter<br><span class="hljs-number">5</span>. 解析异步路由<br><span class="hljs-number">6</span>. 非重用调用beforeRouteEnter<br><span class="hljs-number">7</span>. 全局解析守卫beforeResolve<br><span class="hljs-number">8</span>. 全局后置守卫<br><span class="hljs-number">9</span>. DOM更新<br><br>// 路由守卫beforeEnter例子<br>const routes = [<br>  &#123;<br>    <span class="hljs-selector-tag">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>,<br>    <span class="hljs-built_in">beforeEnter</span>() &#123;<br>      // ...<br>    &#125;,<br>    children: [<br>      &#123; <span class="hljs-selector-tag">path</span>: <span class="hljs-string">&#x27;list&#x27;</span>, component: UserList &#125;,<br>      &#123; <span class="hljs-selector-tag">path</span>: <span class="hljs-string">&#x27;details&#x27;</span>, component: UserDetails &#125;,<br>    ],<br>  &#125;,<br>]<br></code></pre></td></tr></table></figure><h2 id="history-pushstate-和location-href-区别"><a href="#history-pushstate-和location-href-区别" class="headerlink" title="history.pushstate()和location.href &#x3D; 区别?"></a>history.pushstate()和location.href &#x3D; 区别?</h2><ul><li>前者静态跳转,不会刷新页面. 后者会刷新页面</li></ul><h2 id="params传参和query传参区别"><a href="#params传参和query传参区别" class="headerlink" title="params传参和query传参区别?"></a>params传参和query传参区别?</h2><ul><li>query参数是在路径后? &amp; &#x3D; 拼接,是查询参数,不是必需的.类似get请求.</li><li>params参数是路由一部分,路径要设置为&#x2F;:id&#x2F;:name,必须在路由后添加参数名.类似post请求.</li></ul><h2 id="vuex和pinia区别-10024"><a href="#vuex和pinia区别-10024" class="headerlink" title="vuex和pinia区别? &#10024;"></a>vuex和pinia区别? &#10024;</h2><ol><li>pinia是用 ts编写,类型支持更友好.</li><li>去除mutations. state,getters,actions.</li><li>vuex树结构,读取数据不方便.都会定义到根模块,覆盖根模块状态.只能创建一个,单例模式. pinia定义多个store,store之间互相引用,扁平化结构.</li></ol><h2 id="Vue-use"><a href="#Vue-use" class="headerlink" title="Vue.use"></a>Vue.use</h2><ol><li>查看这个插件是否安装过,安装过不再引用</li><li>调用插件对象的install方法(或者直接传入函数),并传入app实例.</li></ol><h2 id="pinia基本注意项"><a href="#pinia基本注意项" class="headerlink" title="pinia基本注意项."></a>pinia基本注意项.</h2><ol><li>定义的state&#x3D;&gt;reactive,getter&#x3D;&gt;computed,actions&#x3D;&gt;method</li><li>如果解构出来会丧失响应式,得用storeToRefs&#x2F;toRefs(用前者,后者会把actions也变成ref).<br><img src="/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.%E7%A7%8B%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image.png" alt="alt text"></li></ol><h2 id="actions和mutations区别"><a href="#actions和mutations区别" class="headerlink" title="actions和mutations区别"></a>actions和mutations区别</h2><ol><li>作用:mutation修改状态,action处理业务代码和异步请求,提交到commit.</li><li>同异步:mutation同步执行,action是异步执行</li></ol><h2 id="为什么需要vuex"><a href="#为什么需要vuex" class="headerlink" title="为什么需要vuex"></a>为什么需要vuex</h2><ol><li>多层嵌套的组件传参和兄弟组件之间传参不便,将组件的公共状态抽离出来,由统一的store仓库管理.</li></ol><h2 id="vuex和localStorage区别"><a href="#vuex和localStorage区别" class="headerlink" title="vuex和localStorage区别?"></a>vuex和localStorage区别?</h2><ol><li>vuex在内存中,localStorage本地磁盘</li><li>SPA组件访问,跨页面访问,响应式,非响应式.</li><li>刷新丢失不丢失</li></ol><h2 id="为什么vuex需要actions-为什么pinia不需要"><a href="#为什么vuex需要actions-为什么pinia不需要" class="headerlink" title="为什么vuex需要actions?为什么pinia不需要?"></a>为什么vuex需要actions?为什么pinia不需要?</h2><ol><li>将同步和异步分离,代码结构更清晰,方便追踪状态变化,mutations执行后对应一个新的状态.</li><li>更贴合组合式API写法,将同步异步逻辑集中到一起,组件中直接调用状态的方法,代码更简洁规范.</li></ol><h2 id="vuex严格模式"><a href="#vuex严格模式" class="headerlink" title="vuex严格模式"></a>vuex严格模式</h2><ul><li>开启后只能通过mutation修改state.</li></ul><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><ol><li>ref通信:setup默认对外不暴露,使用defineExpose.</li><li>provide,inject: 如果传给子代数据很多,可以provide当前父实例getCurrentInstance,在父实例definExpose.</li></ol><h2 id="fn-bind-a-bind-b"><a href="#fn-bind-a-bind-b" class="headerlink" title="fn.bind(a).bind(b)"></a>fn.bind(a).bind(b)</h2><ul><li>bind只能绑定第一个this,第二个绑定无效.</li></ul><h1 id="10-11"><a href="#10-11" class="headerlink" title="10.11"></a>10.11</h1><h2 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h2><ol><li>简单请求: 浏览器在请求头添加origin字段,表明该请求来自哪个源.服务端如果同意这次请求则在响应头配置对应允许的字段.</li><li>非简单请求: 先进行一次预检请求,携带origin,额外的请求方法,额外的请求头.服务端同意请求后,后续请求只需携带origin.</li></ol><h2 id="单页面和多页面-1"><a href="#单页面和多页面-1" class="headerlink" title="单页面和多页面"></a>单页面和多页面</h2><ol><li>请求资源:单页面一次性加载资源,多页面多次加载</li><li>路由:单页面应用:history,hash.多页面应用通过路径跳转.</li><li>数据传递:单页面vuex.多页面cookie,localStorage,sessionStorage,接口保存.</li><li>单页面局部更新,切换速度快.多页面全局更新,切换速度慢.</li></ol><h2 id="SSR服务端渲染-1"><a href="#SSR服务端渲染-1" class="headerlink" title="SSR服务端渲染?"></a>SSR服务端渲染?</h2><ul><li>优点:</li></ul><ol><li>更快的首屏加载速度.服务端根据请求路径获取到对应组件,服务端组件请求数据,将组件渲染为html.将html和vue文件作为响应内容返回给客户端.客户端渲染页面,并加载vue文件,将页面变为动态页面.</li><li>更好支持SEO,搜索引擎爬虫可以获取到完全渲染的页面.</li></ol><ul><li>缺点:</li></ul><ol><li>只支持beforeCreate钩子和created钩子.</li><li>增大服务端压力.</li></ol><h2 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h2><ol><li>全局在Vue构造函数上</li><li>生命周期,响应式数据</li><li>可插拔可复用,优先原来组件</li></ol><h2 id="优雅降级和渐进增强"><a href="#优雅降级和渐进增强" class="headerlink" title="优雅降级和渐进增强"></a>优雅降级和渐进增强</h2><ul><li>渐进增强:针对低版本浏览器构建页面,针对高版本浏览器加强功能改进和更好的用户体验.</li><li>优雅降级:一开始完善功能和用户体验,针对低版本浏览器做兼容.</li></ul><h2 id="actions和mutations区别-1"><a href="#actions和mutations区别-1" class="headerlink" title="actions和mutations区别"></a>actions和mutations区别</h2><ol><li>作用:mutation修改状态,action处理业务代码和异步请求,提交到commit.</li><li>同异步:mutation同步执行,action是异步执行</li></ol><h2 id="为什么vuex需要actions-为什么pinia不需要-1"><a href="#为什么vuex需要actions-为什么pinia不需要-1" class="headerlink" title="为什么vuex需要actions?为什么pinia不需要?"></a>为什么vuex需要actions?为什么pinia不需要?</h2><ol><li>将同步和异步分离,代码结构更清晰,方便追踪状态变化,mutations执行后对应一个新的状态.</li><li>更贴合组合式API写法,将同步异步逻辑集中到一起,组件中直接调用状态的方法,代码更简洁规范.</li></ol><h1 id="10-12"><a href="#10-12" class="headerlink" title="10.12"></a>10.12</h1><h2 id="k个一组翻转"><a href="#k个一组翻转" class="headerlink" title="k个一组翻转"></a>k个一组翻转</h2><h2 id="链表翻转"><a href="#链表翻转" class="headerlink" title="链表翻转"></a>链表翻转</h2><h2 id="随机链表的复制-没搞出来"><a href="#随机链表的复制-没搞出来" class="headerlink" title="随机链表的复制(没搞出来)"></a>随机链表的复制(没搞出来)</h2><h2 id="小米笔试"><a href="#小米笔试" class="headerlink" title="小米笔试"></a>小米笔试</h2><h2 id="美团笔试"><a href="#美团笔试" class="headerlink" title="美团笔试"></a>美团笔试</h2><h1 id="10-13"><a href="#10-13" class="headerlink" title="10.13"></a>10.13</h1><h2 id="oauth2"><a href="#oauth2" class="headerlink" title="oauth2"></a>oauth2</h2><h2 id="随机链表复制"><a href="#随机链表复制" class="headerlink" title="随机链表复制"></a>随机链表复制</h2><h2 id="合并k个升序数组"><a href="#合并k个升序数组" class="headerlink" title="合并k个升序数组"></a>合并k个升序数组</h2><h2 id="环形链表1-2"><a href="#环形链表1-2" class="headerlink" title="环形链表1,2"></a>环形链表1,2</h2><h1 id="10-14"><a href="#10-14" class="headerlink" title="10.14"></a>10.14</h1><ul><li>上午:看完登录,直传oss. 下午:webworker</li></ul><h2 id="浏览器六大对象"><a href="#浏览器六大对象" class="headerlink" title="浏览器六大对象"></a>浏览器六大对象</h2><ul><li>window窗口 history历史记录 screen屏幕 navigator浏览器相关信息 location地址栏<br>document当前页面文档</li></ul><h2 id="auth2授权登录全过程"><a href="#auth2授权登录全过程" class="headerlink" title="auth2授权登录全过程"></a>auth2授权登录全过程</h2><h2 id="单点登录全过程"><a href="#单点登录全过程" class="headerlink" title="单点登录全过程"></a>单点登录全过程</h2><ol><li>同父域名: 公司的单点登录</li><li>非同父域名:<blockquote><p>两者后端拿到code,token都会去企业微信API,认证中心验证合理性和时效性.</p></blockquote></li></ol><h2 id="oss直传"><a href="#oss直传" class="headerlink" title="oss直传"></a>oss直传</h2><h2 id="无感刷新"><a href="#无感刷新" class="headerlink" title="无感刷新"></a>无感刷新</h2><ol><li>双token</li><li>token续期</li></ol><h2 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h2><ul><li>描述文件类型: 文本,图片,视频,音频.</li></ul><h2 id="文件相关对象-10024"><a href="#文件相关对象-10024" class="headerlink" title="文件相关对象 &#10024;"></a>文件相关对象 &#10024;</h2><ol><li>blob，二进制大对象，类文件对象，不可修改。</li><li>fileReader：读取blob对象。</li><li>file：blob对象的特殊类型。通过input选择。</li><li>ArrayBuffer：二进制数据的缓冲区，字节数组。</li><li>TypedArray：读取ArrayBuffer。</li></ol><h2 id="xlsx和csv"><a href="#xlsx和csv" class="headerlink" title="xlsx和csv"></a>xlsx和csv</h2><ul><li>都是存储表格数据的文件格式</li><li>csv纯文本，体积更小，支持所有文本编辑器，但不支持密码保护。前端csv就是逗号拼接起来的数据。</li><li>xlsx是excel专有格式，适合复杂数据管理。</li></ul><h2 id="webworker基本知识"><a href="#webworker基本知识" class="headerlink" title="webworker基本知识"></a>webworker基本知识</h2><h1 id="10-15"><a href="#10-15" class="headerlink" title="10.15"></a>10.15</h1><h2 id="webWorker结合项目"><a href="#webWorker结合项目" class="headerlink" title="webWorker结合项目"></a>webWorker结合项目</h2><h2 id="sharedWorker"><a href="#sharedWorker" class="headerlink" title="sharedWorker"></a>sharedWorker</h2><h2 id="css八股"><a href="#css八股" class="headerlink" title="css八股"></a>css八股</h2><h1 id="10-16"><a href="#10-16" class="headerlink" title="10.16"></a>10.16</h1><h2 id="css八股复习完"><a href="#css八股复习完" class="headerlink" title="css八股复习完"></a>css八股复习完</h2><ul><li>基础，浮动，定位，flex，两栏布局三栏布局垂直居中。</li></ul><h2 id="flex：1"><a href="#flex：1" class="headerlink" title="flex：1"></a>flex：1</h2><ol><li>flex是flex-grow，flex-shrink，flex-basis简写。</li><li>flex：1 &#x3D;&gt; flex:1,1,0%.表示子元素等比放大缩小。</li></ol><h1 id="10-17"><a href="#10-17" class="headerlink" title="10.17"></a>10.17</h1><h2 id="虚拟列表"><a href="#虚拟列表" class="headerlink" title="虚拟列表"></a>虚拟列表</h2><ul><li>有三个div元素，一个div里包了两个div，外层div开启相对定位，里层一个div开启绝对定位，设置z-index为-1，高度为整个大列表实际高度，解决滚动条无法拖到底和滚动条长度变化的问题。另一个子div负责展示列表。</li><li>监听外层div的滚动事件，滚动过的高度&#x2F;每一个元素高度，再加上渲染的个数从大列表中进行截取。通过transform：translate对里层子div进行偏移。transform会单独抽离出一个合成层，不会触发回流重绘，可以利用GPU加速渲染。</li></ul><h2 id="晚上抽离公共组件工具方法以及样式类，并通过子模块仓库引入，提高开发效率"><a href="#晚上抽离公共组件工具方法以及样式类，并通过子模块仓库引入，提高开发效率" class="headerlink" title="晚上抽离公共组件工具方法以及样式类，并通过子模块仓库引入，提高开发效率"></a>晚上抽离公共组件工具方法以及样式类，并通过子模块仓库引入，提高开发效率</h2><h1 id="10-18"><a href="#10-18" class="headerlink" title="10.18"></a>10.18</h1><h2 id="手写发布订阅"><a href="#手写发布订阅" class="headerlink" title="手写发布订阅"></a>手写发布订阅</h2><h2 id="实现自定义角色权限，为不同管理权限设置不同路由，并完成按钮级别权限控制"><a href="#实现自定义角色权限，为不同管理权限设置不同路由，并完成按钮级别权限控制" class="headerlink" title="实现自定义角色权限，为不同管理权限设置不同路由，并完成按钮级别权限控制"></a>实现自定义角色权限，为不同管理权限设置不同路由，并完成按钮级别权限控制</h2><ul><li>在子模块仓库封装了getCurModuleAuth获取当前模块权限的函数，iauth是一个权限申请平台，各个系统权限节点可以在上面申请，因此可以实现自定义角色权限；配置中心获取基本配置信息，白名单用户，权限节点&#x3D;&gt;权限的映射。从七彩石配置中心拉取权限节点&#x3D;&gt;权限的映射，从iauth平台拉取当前用户所有的权限。再传入当前模块字符串，返回权限数组比如[增加策略，删除策略，修改策略，发布策略].按钮级权限控制：按钮disabled时候判断权限数组是否包含按钮操作的节点。</li><li>子模块仓库封装了injectAuthId注入路由权限id函数，在全局路由前置守卫调用。七彩石配置中心获取权限节点&#x3D;&gt;权限映射，iauth获取权限数组。路由配置时候不同页面配置对应的权限信息。权限&#x3D;&gt;权限id，查看用户是否有当前id的权限，有的话在路由的meta元信息注入字段&#x2F;白名单用户也会注入该字段，根据是否有该字段来判断是给用户放行&#x2F;还是跳转到403统一无权限页面。</li></ul><h2 id="vuex和pinia区别-10024-1"><a href="#vuex和pinia区别-10024-1" class="headerlink" title="vuex和pinia区别? &#10024;"></a>vuex和pinia区别? &#10024;</h2><ol><li>pinia是用 ts编写,类型支持更友好.</li><li>去除mutations. state,getters,actions.</li><li>vuex树结构,读取数据不方便.都会定义到根模块,覆盖根模块状态.只能创建一个,单例模式. pinia定义多个store,store之间互相引用,扁平化结构.</li></ol><h2 id="作为子应用接入微前端框架，通过暴露生命周期钩子和基于pinia的事件注册和分发来实现与主应用的数据共享"><a href="#作为子应用接入微前端框架，通过暴露生命周期钩子和基于pinia的事件注册和分发来实现与主应用的数据共享" class="headerlink" title="作为子应用接入微前端框架，通过暴露生命周期钩子和基于pinia的事件注册和分发来实现与主应用的数据共享"></a>作为子应用接入微前端框架，通过暴露生命周期钩子和基于pinia的事件注册和分发来实现与主应用的数据共享</h2><h2 id><a href="#" class="headerlink" title=".*"></a>.*</h2><ul><li>匹配任意长度的字符串</li></ul><h2 id="动态路由参数"><a href="#动态路由参数" class="headerlink" title="动态路由参数"></a>动态路由参数</h2><ol><li>：pathName：user&#x2F;:id &#x3D;&gt; user&#x2F;1 ,user&#x2F;2</li></ol><h2 id="POWERED-BY-QIANKUN"><a href="#POWERED-BY-QIANKUN" class="headerlink" title="POWERED_BY_QIANKUN"></a>POWERED_BY_QIANKUN</h2><p>window.<del><strong>POWERED_BY_QIANKUN</strong></del>：这是一个标识，用于判断当前应用是否在 qiankun 的环境中运行。如果为 true，说明当前是子应用。</p><h2 id="process-env"><a href="#process-env" class="headerlink" title="process.env"></a>process.env</h2><ul><li>是Node.js 中的一个<em><strong>全局变量</strong></em>，包含当前环境（开发环境，线上环境）信息。可在vue项目中全局访问，使代码在不同环境使用不同配置，不需要修改源代码。</li></ul><!-- vue开启本地服务器先启动node环境运行js，对模板编译生成渲染函数，将vue文件=> 浏览器可识别的js，html，css文件执行 --><h1 id="10-19"><a href="#10-19" class="headerlink" title="10.19"></a>10.19</h1><h2 id="复习权限控制"><a href="#复习权限控制" class="headerlink" title="复习权限控制"></a>复习权限控制</h2><h2 id="qiankun和iframe区别"><a href="#qiankun和iframe区别" class="headerlink" title="qiankun和iframe区别"></a>qiankun和iframe区别</h2><ol><li>实现方式</li><li>数据通信</li><li>加载性能</li><li>使用场景</li></ol><h2 id="微前端解决了什么问题"><a href="#微前端解决了什么问题" class="headerlink" title="微前端解决了什么问题"></a>微前端解决了什么问题</h2><ol><li>可维护性</li><li>团队独立性</li><li>技术灵活性</li><li>增量升级</li></ol><h2 id="子应用如何接入qiankun框架？"><a href="#子应用如何接入qiankun框架？" class="headerlink" title="子应用如何接入qiankun框架？"></a>子应用如何接入qiankun框架？</h2><ol><li>在加载主应用入口文件时候注册子应用，当url变化时候自动触发qiankun的匹配逻辑。</li><li>主应用路由全局前置守卫判断：403，404，主应用页面，子应用（挂载到一个空壳路由也页面）。子应用的话start启动qiankun框架。</li><li>切换到子应用挂载的路由，id为container，子应用配置container字段为#container。</li><li>子应用启动时候调用mount生命周期钩子，卸载时候调用unmount生命周期钩子。bootstrap首次初始化加载，设置全局状态的缓存，不会在unmount卸载；mount里挂载子组件，unmount里卸载子组件。</li></ol><h2 id="父子应用通信"><a href="#父子应用通信" class="headerlink" title="父子应用通信"></a>父子应用通信</h2><h2 id="组件通信-1"><a href="#组件通信-1" class="headerlink" title="组件通信"></a>组件通信</h2><ol><li>ref通信:setup默认对外不暴露,使用defineExpose.</li><li>provide,inject: 如果传给子代数据很多,可以provide当前父实例getCurrentInstance,在父实例definExpose.</li></ol><h2 id="fn-bind-a-bind-b-1"><a href="#fn-bind-a-bind-b-1" class="headerlink" title="fn.bind(a).bind(b)"></a>fn.bind(a).bind(b)</h2><ul><li>bind只能绑定第一个this,第二个绑定无效.</li></ul><h2 id="京东笔试"><a href="#京东笔试" class="headerlink" title="京东笔试"></a>京东笔试</h2><h1 id="10-20"><a href="#10-20" class="headerlink" title="10.20"></a>10.20</h1><h2 id="js沙箱机制"><a href="#js沙箱机制" class="headerlink" title="js沙箱机制"></a>js沙箱机制</h2><h2 id="css样式隔离"><a href="#css样式隔离" class="headerlink" title="css样式隔离"></a>css样式隔离</h2><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><ul><li>三道题（两数之和，字母异位词分组，最长连续序列）</li></ul><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ul><li>四道题：接雨水（动态规划或双指针）</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul><li>两道题</li></ul><ol><li>相加链表：hash，双指针</li><li>反转链表</li></ol><!-- ## get请求没问题,post请求失败? --><h1 id="10-21"><a href="#10-21" class="headerlink" title="10.21"></a>10.21</h1><ul><li><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/</a></li></ul><h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><ul><li>十五道题</li></ul><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><ul><li>理论基础</li><li>五道题</li></ul><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul><li>满二叉树：除叶子节点外的节点都有两个子节点。</li><li>完全二叉树：叶子节点一定是从左到右的，中间不能断。</li><li>二叉搜索树：搜索复杂度是logn，</li></ul><h1 id="10-22"><a href="#10-22" class="headerlink" title="10.22"></a>10.22</h1><h2 id="链表思路"><a href="#链表思路" class="headerlink" title="链表思路"></a>链表思路</h2><ul><li>快慢指针 slow &#x3D; fast &#x3D; head;</li><li>创建hair指针 res &#x3D; hair &#x3D; new ListNode(0,head); return res.next;</li></ul><h2 id="按值传递-按引用传递"><a href="#按值传递-按引用传递" class="headerlink" title="按值传递,按引用传递"></a>按值传递,按引用传递</h2><ul><li>js是按值传递,复制一份.</li></ul><ol><li>按值传递&#x3D;&#x3D;&#x3D;&gt;复制一份,按引用传递&#x3D;&#x3D;&#x3D;&gt;变量的内存被赋给另一个局部变量,局部变量的修改会影响原变量.</li></ol><h2 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h2><p>backTracking<br>if（）{return} for path.push() backTracking() path.pop()</p><h2 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h2><ul><li>前中后序遍历</li><li>层序遍历</li></ul><h2 id="前端攻击"><a href="#前端攻击" class="headerlink" title="前端攻击"></a>前端攻击</h2><ul><li>xss攻击，csrf攻击。</li></ul><h2 id="浏览器渲染进程有哪些线程？"><a href="#浏览器渲染进程有哪些线程？" class="headerlink" title="浏览器渲染进程有哪些线程？"></a>浏览器渲染进程有哪些线程？</h2><ul><li>js引擎线程，渲染线程，定时器相关的线程，事件循环相关的线程。</li></ul><h2 id="强制缓存，协商缓存"><a href="#强制缓存，协商缓存" class="headerlink" title="强制缓存，协商缓存"></a>强制缓存，协商缓存</h2><ul><li>强制缓存：expires，cache-control</li><li>协商缓存：if-modified-since，if-none-match。</li></ul><h2 id="f5刷新，ctrl-f5刷新，地址栏输入"><a href="#f5刷新，ctrl-f5刷新，地址栏输入" class="headerlink" title="f5刷新，ctrl+f5刷新，地址栏输入"></a>f5刷新，ctrl+f5刷新，地址栏输入</h2><ul><li>1：强制缓存失效，2：都失效。3：都有效。</li></ul><h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><ol><li>解析html文档,生成DOM树,由html元素和属性节点组成.</li><li>解析css,生成css树.</li><li>根据DOM树和CSS树构建渲染树</li><li>布局(回流):渲染树进行布局计算每个渲染节点的位置和大小.</li><li>绘制(重绘):将渲染树的节点绘制到页面上.</li><li>复合: 浏览器的绘制是绘制到多层,每一层单独渲染,最后合成到一起形成页面.</li><li>重绘:重绘不会带来重新布局,一般是修改背景颜色,边框阴影等属性.</li><li>回流:消耗性能,改变元素位置,DOM结构发生变化.</li></ol><h2 id="减少回流，重绘"><a href="#减少回流，重绘" class="headerlink" title="减少回流，重绘"></a>减少回流，重绘</h2><ol><li>浏览器队列机制。</li><li>脱离文档流</li><li>操作低层次dom</li><li>translate，opcity单独抽离出合成层，利用gpu加速渲染。</li></ol><h2 id="浏览器渲染优化-2"><a href="#浏览器渲染优化-2" class="headerlink" title="浏览器渲染优化"></a>浏览器渲染优化</h2><ol><li>js用async，defer。</li><li>css用link，@import。</li><li>减少回流重绘。</li></ol><h2 id="cookie，localStorage，sessionStorage"><a href="#cookie，localStorage，sessionStorage" class="headerlink" title="cookie，localStorage，sessionStorage"></a>cookie，localStorage，sessionStorage</h2><ol><li>cookie：请求携带发送，内存小，服务端可以设置客户端不准读取。</li><li>localStorage：请求不会携带，内存大，不删除的话一直存在。</li><li>sessionStroage：请求不会携带，内存大，退出页面则删除。</li></ol><h2 id="浏览器的本地存储-1"><a href="#浏览器的本地存储-1" class="headerlink" title="浏览器的本地存储"></a>浏览器的本地存储</h2><h3 id="cookie-1"><a href="#cookie-1" class="headerlink" title="cookie"></a>cookie</h3><ol><li>大小限制4kb,不能跨域.</li><li>主要和seesion配合,存储sessionid,发送请求时候可以携带cookie,服务器识别sessionid来识别身份.</li></ol><h3 id="localStorage-1"><a href="#localStorage-1" class="headerlink" title="localStorage"></a>localStorage</h3><ol><li>大小5MB,存储在本地,请求不会携带.</li><li>除非主动删除,否则不会消失.</li><li>同源多个标签可以共享数据.</li></ol><h3 id="sessionStorage-1"><a href="#sessionStorage-1" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><ol><li>同.</li><li>关闭窗口后会消失</li><li>同源多个标签不可以共享数据.</li></ol><h2 id="cookie字段-1"><a href="#cookie字段-1" class="headerlink" title="cookie字段"></a>cookie字段</h2><ol><li>domain:可以访问该cookie的域名</li><li>path:域名下的哪些路径可以访问该cookie</li><li>Expires:cookie过期时间,注意这个是cookie的expires!和缓存的不一样,缓存的是在请求头中!</li><li>name,value,size.</li></ol><ul><li>服务端在响应头可以用set-cookie来配置cookie信息.http-only限制cookie不能被js脚本读取.也有domain,path,expires.<br>(不要把缓存的六个字段和cookie的搞混了,缓存的是在请求头和响应头中)</li></ul><h2 id="indexDB-1"><a href="#indexDB-1" class="headerlink" title="indexDB"></a>indexDB</h2><ul><li>内存更大，异步，事务。</li></ul><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ol><li>CORS</li><li>jsonp</li><li>postmessage</li><li>开发中：代理服务器。</li></ol><h2 id="事件模型-2"><a href="#事件模型-2" class="headerlink" title="事件模型"></a>事件模型</h2><ol><li>DOM0：没有事件流。</li><li>IE：事件触发，事件冒泡</li><li>DOM2：事件捕获，事件触发，事件冒泡。</li></ol><h2 id="事件委托-1"><a href="#事件委托-1" class="headerlink" title="事件委托"></a>事件委托</h2><ol><li>利用事件冒泡机制</li><li>动态添加事件，减少内存消耗。</li></ol><h2 id="美团面试"><a href="#美团面试" class="headerlink" title="美团面试"></a>美团面试</h2><h1 id="10-23"><a href="#10-23" class="headerlink" title="10.23"></a>10.23</h1><h2 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h2><ul><li>浏览器主进程，渲染进程，插件进程，GUI进程</li></ul><h2 id="浏览器并发机制"><a href="#浏览器并发机制" class="headerlink" title="浏览器并发机制."></a>浏览器并发机制.</h2><ol><li>避免线程频繁切换</li><li>良性机制</li><li>避免占据服务端过多资源</li><li>端口号限制</li></ol><h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><p>200 204 206<br>301 302 304<br>400 404 403<br>500</p><h2 id="get，post请求区别"><a href="#get，post请求区别" class="headerlink" title="get，post请求区别"></a>get，post请求区别</h2><ol><li>获取，修改数据</li><li>请求体</li><li>幂等安全</li><li>get可以强制缓存，协商缓存</li></ol><h2 id="http1-1和1-0区别"><a href="#http1-1和1-0区别" class="headerlink" title="http1.1和1.0区别"></a>http1.1和1.0区别</h2><ol><li>强制缓存协商缓存字段</li><li>部分请求</li><li>增加的请求状态码</li><li>长连接</li><li>host</li></ol><h2 id="http和https区别"><a href="#http和https区别" class="headerlink" title="http和https区别"></a>http和https区别</h2><ol><li>加密通信：明文传输，加密传输 &#x3D;&gt; 非对称加密，对称加密结合</li><li>防止请求被篡改 &#x3D;&gt; 摘要算法+私钥签名</li><li>身份认证 &#x3D;&gt; 数字证书</li></ol><h2 id="TLS握手-1"><a href="#TLS握手-1" class="headerlink" title="TLS握手"></a>TLS握手</h2><ol><li>支持的tls版本号，支持的密码套件，随机数</li><li>选择版本号，密码套件，随机数，数字证书</li><li>验证数字证书，获取公钥，生成第三个随机数 &#x3D;&gt; 生成会话密钥，通知后续采用加密发送。</li><li>私钥解密获取第三个随机数，生成会话密钥，通知后续采用加密发送。</li></ol><h2 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h2><ol><li>主动推送</li><li>头部压缩</li><li>二进制流</li><li>一个tcp连接下有多个stream流，每个stream流对应一个请求和响应，</li></ol><h2 id="http3-0-1"><a href="#http3-0-1" class="headerlink" title="http3.0"></a>http3.0</h2><ul><li>udp，quic协议</li></ul><ol><li>扩充了静态表，动态表维护。</li><li>更快建立连接，quic协议握手和tls1.3握手一同发送，一次RTT完成连接。</li><li>更快的恢复连接建立</li><li>无队头阻塞</li></ol><h2 id="如何解决沾包问题-1"><a href="#如何解决沾包问题-1" class="headerlink" title="如何解决沾包问题?"></a>如何解决沾包问题?</h2><ol><li>固定长度的消息.</li><li>http头部设置回车,换行两个为消息边界.</li></ol><h2 id="为什么可以三次挥手-1"><a href="#为什么可以三次挥手-1" class="headerlink" title="为什么可以三次挥手?"></a>为什么可以三次挥手?</h2><ul><li>需要四次原因是因为还有数据要发送,数据发送完再调用关闭函数进入LAST-ACK状态.</li></ul><ol><li><em><strong>没有数据发送</strong></em>且<em><strong>开启了TCP延迟确认机制</strong></em>,那么第二次和第三次挥手就回合并,三次挥手.</li><li>TCP延迟确认机制是优化单独发ACK数据效率低,延迟等待一段时间,如果有数据发送则和ACK一起发送,提高效率.</li></ol><h2 id="setTimeout-允许我们将函数推迟到一段时间间隔之后再执行。"><a href="#setTimeout-允许我们将函数推迟到一段时间间隔之后再执行。" class="headerlink" title="setTimeout 允许我们将函数推迟到一段时间间隔之后再执行。"></a>setTimeout 允许我们将函数推迟到一段时间间隔之后再执行。</h2><p>setInterval 允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。</p><h1 id="10-24"><a href="#10-24" class="headerlink" title="10.24"></a>10.24</h1><h2 id="爬楼梯-1"><a href="#爬楼梯-1" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><h2 id="杨辉三角-1"><a href="#杨辉三角-1" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2><h2 id="不同路径-1"><a href="#不同路径-1" class="headerlink" title="不同路径"></a>不同路径</h2><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><h2 id="10-25"><a href="#10-25" class="headerlink" title="10.25"></a>10.25</h2><h3 id="微前端父子应用路由"><a href="#微前端父子应用路由" class="headerlink" title="微前端父子应用路由"></a>微前端父子应用路由</h3><h3 id="微前端如何加载多个子应用"><a href="#微前端如何加载多个子应用" class="headerlink" title="微前端如何加载多个子应用"></a>微前端如何加载多个子应用</h3><h3 id="京东面试"><a href="#京东面试" class="headerlink" title="京东面试"></a>京东面试</h3><h2 id="10-26"><a href="#10-26" class="headerlink" title="10.26"></a>10.26</h2><h3 id="01背包问题滚动数组"><a href="#01背包问题滚动数组" class="headerlink" title="01背包问题滚动数组"></a>01背包问题滚动数组</h3><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><h3 id="最后一块石头的重量"><a href="#最后一块石头的重量" class="headerlink" title="最后一块石头的重量"></a>最后一块石头的重量</h3><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h3><h2 id="10-27"><a href="#10-27" class="headerlink" title="10.27"></a>10.27</h2><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h3><h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h3><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h3><h3 id="loader和plugin区别-10024"><a href="#loader和plugin区别-10024" class="headerlink" title="loader和plugin区别&#10024;"></a>loader和plugin区别&#10024;</h3><h3 id="webpack构建流程-10024"><a href="#webpack构建流程-10024" class="headerlink" title="webpack构建流程&#10024;"></a>webpack构建流程&#10024;</h3><h3 id="如何提高构建速度-10024"><a href="#如何提高构建速度-10024" class="headerlink" title="如何提高构建速度&#10024;"></a>如何提高构建速度&#10024;</h3><h3 id="vite和webpack区别-10024"><a href="#vite和webpack区别-10024" class="headerlink" title="vite和webpack区别&#10024;"></a>vite和webpack区别&#10024;</h3><h3 id="webpack热模块更新-10024"><a href="#webpack热模块更新-10024" class="headerlink" title="webpack热模块更新 &#10024;"></a>webpack热模块更新 &#10024;</h3><h1 id="10-28"><a href="#10-28" class="headerlink" title="10.28"></a>10.28</h1><!-- - 我感觉我每天都处在崩溃边缘和状态好的边缘，找寻着未知的答案。 --><h2 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a>寻找重复数</h2><h2 id="多数元素摩尔投票法：找数组中的众数"><a href="#多数元素摩尔投票法：找数组中的众数" class="headerlink" title="多数元素摩尔投票法：找数组中的众数"></a>多数元素摩尔投票法：找数组中的众数</h2><ul><li>消除不同元素之间的对抗来找到可能的多数元素。</li></ul><h2 id="UDP和TCP区别-1"><a href="#UDP和TCP区别-1" class="headerlink" title="UDP和TCP区别"></a>UDP和TCP区别</h2><ul><li>可靠 连接 服务 控制 传输</li></ul><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h2 id="流量控制，拥塞控制"><a href="#流量控制，拥塞控制" class="headerlink" title="流量控制，拥塞控制"></a>流量控制，拥塞控制</h2><h2 id="冯诺依曼体系结构-10024"><a href="#冯诺依曼体系结构-10024" class="headerlink" title="冯诺依曼体系结构 &#10024;"></a>冯诺依曼体系结构 &#10024;</h2><ol><li>以<em><strong>运算器</strong></em>为中心。现代计算机以<em><strong>存储器</strong></em>为中心。</li><li>五种结构：运算器，控制器，存储器，输入设备，输出设备。</li></ol><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><ul><li>由地址寄存器（MAR），数据寄存器（MDR），存储体组成。</li><li>分为内存和外存，cpu处理数据只能处理内存，外存的数据被处理要先放到内存中。</li></ul><!-- 读取：读取的地址放到地址寄存器，存储体找到后放到数据寄存器，然后CPU读取。     写入：写入的地址放到地址寄存器，写入的数据放到数据寄存器，然后写入到存储体。 --><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><ul><li>进行算术运算和逻辑运算，核心是通过ALU算术逻辑单元进行运算。</li></ul><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><ul><li>取指令、翻译指令、分析指令，然后向有关部件发送命令，协调指挥整个计算机操作。控制器和运算器共同共同组成CPU。</li></ul><h3 id="输入设备，输出设备"><a href="#输入设备，输出设备" class="headerlink" title="输入设备，输出设备"></a>输入设备，输出设备</h3><ul><li>入：键盘，鼠标。</li><li>出：显示屏，打印机。</li></ul><h2 id="不同地点访问同一个url区别-9997"><a href="#不同地点访问同一个url区别-9997" class="headerlink" title="不同地点访问同一个url区别 &#9997;"></a>不同地点访问同一个url区别 &#9997;</h2><ol><li>缓存</li><li>ip地址不同，路由器转发，交换机转发经过的网络路径不同。</li><li>网速不同，获取资源速度不同。</li></ol><h2 id="KMP算法基础"><a href="#KMP算法基础" class="headerlink" title="KMP算法基础"></a>KMP算法基础</h2><ul><li><a href="https://www.bilibili.com/video/BV1PD4y1o7nd/?spm_id_from=333.337.search-card.all.click&vd_source=9b9c9c2844427b792423aada902b836b">https://www.bilibili.com/video/BV1PD4y1o7nd/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9b9c9c2844427b792423aada902b836b</a></li></ul><h2 id="tcp三次握手，两次握手，四次握手"><a href="#tcp三次握手，两次握手，四次握手" class="headerlink" title="tcp三次握手，两次握手，四次握手"></a>tcp三次握手，两次握手，四次握手</h2><h1 id="10-29"><a href="#10-29" class="headerlink" title="10.29"></a>10.29</h1><!-- 我的灵魂失语了，只剩下疲软的病态。 --><h2 id="tcp为什么初始化序列号不同？"><a href="#tcp为什么初始化序列号不同？" class="headerlink" title="tcp为什么初始化序列号不同？"></a>tcp为什么初始化序列号不同？</h2><h2 id="第一二三次握手丢失发生什么"><a href="#第一二三次握手丢失发生什么" class="headerlink" title="第一二三次握手丢失发生什么"></a>第一二三次握手丢失发生什么</h2><h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><h2 id="tcp四次挥手流程"><a href="#tcp四次挥手流程" class="headerlink" title="tcp四次挥手流程"></a>tcp四次挥手流程</h2><h2 id="tcp可以三次挥手的原因"><a href="#tcp可以三次挥手的原因" class="headerlink" title="tcp可以三次挥手的原因"></a>tcp可以三次挥手的原因</h2><h2 id="第一二三四次挥手丢失发生什么"><a href="#第一二三四次挥手丢失发生什么" class="headerlink" title="第一二三四次挥手丢失发生什么"></a>第一二三四次挥手丢失发生什么</h2><h2 id="等待时间是2MSL原因"><a href="#等待时间是2MSL原因" class="headerlink" title="等待时间是2MSL原因"></a>等待时间是2MSL原因</h2><h2 id="time-wait的意义"><a href="#time-wait的意义" class="headerlink" title="time-wait的意义"></a>time-wait的意义</h2><h2 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h2><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h2 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h2><h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><h2 id="手写发布订阅-1"><a href="#手写发布订阅-1" class="headerlink" title="手写发布订阅"></a>手写发布订阅</h2><h1 id="10-30"><a href="#10-30" class="headerlink" title="10.30"></a>10.30</h1><!-- 寻找内心的平静 --><h2 id="git-如何解决冲突-10024"><a href="#git-如何解决冲突-10024" class="headerlink" title="git 如何解决冲突&#10024;"></a>git 如何解决冲突&#10024;</h2><h2 id="git-rebase和git-merge区别-10024"><a href="#git-rebase和git-merge区别-10024" class="headerlink" title="git rebase和git merge区别 &#10024;"></a>git rebase和git merge区别 &#10024;</h2><h2 id="减少回流和重绘操作-10024"><a href="#减少回流和重绘操作-10024" class="headerlink" title="减少回流和重绘操作 &#10024;"></a>减少回流和重绘操作 &#10024;</h2><ol><li>操作低层次的DOM.</li><li>脱离文档流,减少对其他元素影响.</li><li>将DOM读写操作分别放到一起,浏览器的渲染队列机制.</li><li>一些css属性形成新的合成层: transform,opacity等等.浏览器把这些变化交给GPU处理(不是所有合成层都给GPU,只有动画视觉效果时候交给GPU),GPU直接在显存中更改元素显示位置,无需CPU进行布局绘制的计算.</li><li>不要使用table布局，一个小的改动可能导致整个table重新布局。</li></ol><h2 id="table布局"><a href="#table布局" class="headerlink" title="table布局"></a>table布局</h2><ul><li>父元素：display：table。子元素：display：table-cell。</li></ul><h2 id="set和map原理-10024"><a href="#set和map原理-10024" class="headerlink" title="set和map原理 &#10024;"></a>set和map原理 &#10024;</h2><ul><li>七个数据类型 + object经过hash值处理运算，对应到0-7八个数字；有个长为8的数组，数组每个元素对应一个数据类型，数组每个元素是链表结构存储相同数据类型的不同值。</li></ul><h2 id="输入url后发生什么"><a href="#输入url后发生什么" class="headerlink" title="输入url后发生什么"></a>输入url后发生什么</h2><ol><li>生成http请求</li><li>浏览器缓存</li><li>DNS域名解析，本地域名服务器缓存，根域名服务器，顶级域名服务器，权威域名服务器。</li><li>tcp三次握手</li><li>tls四次握手</li><li>ip地址封装ip帧，路由器转发，各个网络之间通信</li><li>到达目的主机网络后交换机ARP地址解析，找到目的主机的mac地址。</li><li>返回数据到浏览器，执行渲染过程。</li><li>tcp四次挥手。</li></ol><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h2><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h1 id="10-31"><a href="#10-31" class="headerlink" title="10.31"></a>10.31</h1><!-- 爱你所爱，行你所行，听从你心，无问西东 --><h2 id="数组和链表删除、新增元素的时间复杂度-9997"><a href="#数组和链表删除、新增元素的时间复杂度-9997" class="headerlink" title="数组和链表删除、新增元素的时间复杂度 &#9997;"></a>数组和链表删除、新增元素的时间复杂度 &#9997;</h2><ul><li>数组复杂度是O（n）：插入、删除要移动元素。</li><li>链表如果知道位置复杂度是O（1）。</li></ul><h2 id="js是单线程语言，如果写出死循环会怎么样？-9997"><a href="#js是单线程语言，如果写出死循环会怎么样？-9997" class="headerlink" title="js是单线程语言，如果写出死循环会怎么样？&#9997;"></a>js是单线程语言，如果写出死循环会怎么样？&#9997;</h2><ul><li>这个循环会占用主线程，导致js无法处理其他任务，包括用户界面的更新和事件的响应，导致页面冻结，无法进行交互。</li></ul><h2 id="微前端解决了什么问题-1"><a href="#微前端解决了什么问题-1" class="headerlink" title="微前端解决了什么问题"></a>微前端解决了什么问题</h2><h2 id="微前端工作原理"><a href="#微前端工作原理" class="headerlink" title="微前端工作原理"></a>微前端工作原理</h2><ul><li>应用的加载和切换，应用的隔离和通信</li></ul><h2 id="iframe和qiankun区别"><a href="#iframe和qiankun区别" class="headerlink" title="iframe和qiankun区别"></a>iframe和qiankun区别</h2><ol><li>实现方式</li><li>加载性能</li><li>通信方式</li><li>应用场景</li></ol><h2 id="子应用如何接入微前端"><a href="#子应用如何接入微前端" class="headerlink" title="子应用如何接入微前端"></a>子应用如何接入微前端</h2><h2 id="父子应用通信-1"><a href="#父子应用通信-1" class="headerlink" title="父子应用通信"></a>父子应用通信</h2><h2 id="js沙箱机制-1"><a href="#js沙箱机制-1" class="headerlink" title="js沙箱机制"></a>js沙箱机制</h2><p>-（激活沙箱干什么，退出沙箱干什么）</p><ol><li>快照沙箱：遍历window对象</li><li>单实例沙箱：代理层，解决遍历window对象问题</li><li>多实例沙箱：解决全局window对象被污染的问题</li></ol><h2 id="CSS样式隔离"><a href="#CSS样式隔离" class="headerlink" title="CSS样式隔离"></a>CSS样式隔离</h2><h2 id="mvc，mvp，mvvm"><a href="#mvc，mvp，mvvm" class="headerlink" title="mvc，mvp，mvvm"></a>mvc，mvp，mvvm</h2><h2 id="晚上复习项目，排序算法"><a href="#晚上复习项目，排序算法" class="headerlink" title="晚上复习项目，排序算法"></a>晚上复习项目，排序算法</h2><h1 id="11-1"><a href="#11-1" class="headerlink" title="11.1"></a>11.1</h1><h2 id="npm-和pnpm区别"><a href="#npm-和pnpm区别" class="headerlink" title="npm 和pnpm区别"></a>npm 和pnpm区别</h2><ul><li>全局存储</li><li>硬链接</li><li>扁平化依赖</li></ul><h2 id="mvc，mvp，mvvm-1"><a href="#mvc，mvp，mvvm-1" class="headerlink" title="mvc，mvp，mvvm"></a>mvc，mvp，mvvm</h2><h2 id="XSS，CSRF攻击"><a href="#XSS，CSRF攻击" class="headerlink" title="XSS，CSRF攻击"></a>XSS，CSRF攻击</h2><ul><li>CSRF：同源检测，token，sameSite</li></ul><h2 id="下午美团三面"><a href="#下午美团三面" class="headerlink" title="下午美团三面"></a>下午美团三面</h2><h1 id="11-2-休息一天"><a href="#11-2-休息一天" class="headerlink" title="11.2 休息一天"></a>11.2 休息一天</h1><h1 id="11-3"><a href="#11-3" class="headerlink" title="11.3"></a>11.3</h1><ul><li>树题目</li></ul><h2 id="二叉树前中后序递归遍历"><a href="#二叉树前中后序递归遍历" class="headerlink" title="二叉树前中后序递归遍历"></a>二叉树前中后序递归遍历</h2><h2 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h2><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><h2 id="二叉树最大深度"><a href="#二叉树最大深度" class="headerlink" title="二叉树最大深度"></a>二叉树最大深度</h2><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><h2 id="二叉树直径"><a href="#二叉树直径" class="headerlink" title="二叉树直径"></a>二叉树直径</h2><h2 id="将有序数组转换为二叉树"><a href="#将有序数组转换为二叉树" class="headerlink" title="将有序数组转换为二叉树"></a>将有序数组转换为二叉树</h2><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><h2 id="二叉搜索树第K小的元素"><a href="#二叉搜索树第K小的元素" class="headerlink" title="二叉搜索树第K小的元素"></a>二叉搜索树第K小的元素</h2><h2 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/652632988">https://zhuanlan.zhihu.com/p/652632988</a></li></ul><h1 id="11-4-没睡好，摆烂了"><a href="#11-4-没睡好，摆烂了" class="headerlink" title="11.4 没睡好，摆烂了"></a>11.4 没睡好，摆烂了</h1><h1 id="11-5"><a href="#11-5" class="headerlink" title="11.5"></a>11.5</h1><h2 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h2><h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h2><h2 id="对typescript的理解？与js区别？"><a href="#对typescript的理解？与js区别？" class="headerlink" title="对typescript的理解？与js区别？"></a>对typescript的理解？与js区别？</h2><h2 id="ts数据类型"><a href="#ts数据类型" class="headerlink" title="ts数据类型"></a>ts数据类型</h2><h2 id="any和unknown区别-✨"><a href="#any和unknown区别-✨" class="headerlink" title="any和unknown区别 ✨"></a>any和unknown区别 ✨</h2><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><h2 id="接口，接口和类区别-✨"><a href="#接口，接口和类区别-✨" class="headerlink" title="接口，接口和类区别 ✨"></a>接口，接口和类区别 ✨</h2><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h2 id="对ts函数的理解"><a href="#对ts函数的理解" class="headerlink" title="对ts函数的理解"></a>对ts函数的理解</h2><h2 id="交叉类型-和联合类型-✨"><a href="#交叉类型-和联合类型-✨" class="headerlink" title="交叉类型 &amp; 和联合类型 | ✨"></a>交叉类型 &amp; 和联合类型 | ✨</h2><h1 id="11-6"><a href="#11-6" class="headerlink" title="11.6"></a>11.6</h1><h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h2><h2 id="路径总和I，II没写出来"><a href="#路径总和I，II没写出来" class="headerlink" title="路径总和I，II没写出来"></a>路径总和I，II没写出来</h2><h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h1 id="11-7"><a href="#11-7" class="headerlink" title="11.7"></a>11.7</h1><h2 id="路径总和II"><a href="#路径总和II" class="headerlink" title="路径总和II"></a>路径总和II</h2><h2 id="路径总和III"><a href="#路径总和III" class="headerlink" title="路径总和III"></a>路径总和III</h2><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><h2 id="patical"><a href="#patical" class="headerlink" title="patical"></a>patical</h2><h2 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h2><h2 id="returnType"><a href="#returnType" class="headerlink" title="returnType"></a>returnType</h2><h2 id="响应式为什么要用-reflect-这种-API-10024"><a href="#响应式为什么要用-reflect-这种-API-10024" class="headerlink" title="响应式为什么要用 reflect 这种 API &#10024;"></a>响应式为什么要用 reflect 这种 API &#10024;</h2><ul><li>提供一种更一致和可靠的方式来执行底层的 JavaScript 操作（比如属性访问、赋值、删除等）,代码更简洁易读，13种proxy的捕获器和reflect静态方法一一对应。</li><li>reflect第三个参数可以修改this的指向，把this指向改成代理对象，触发响应式依赖收集。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">如果被代理的对象本身有<span class="hljs-keyword">get</span>函数，<span class="hljs-keyword">get</span>函数里面的<span class="hljs-keyword">this</span>默认指向对象本身。proxy访问这个<br>数据时候，<span class="hljs-keyword">get</span>函数<span class="hljs-keyword">this</span>需要指向proxy，才能触发响应式依赖收集。<br><br> <span class="hljs-keyword">const</span> obj = &#123;<br>            a: <span class="hljs-number">1</span>,<br>            b: <span class="hljs-number">2</span>,<br>            <span class="hljs-keyword">get</span> c() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a + <span class="hljs-keyword">this</span>.b;<br>            &#125;<br>        &#125;<br>        let proxy = new Proxy(obj, &#123;<br>            <span class="hljs-keyword">get</span>(target, key) &#123;<br>                console.log(<span class="hljs-string">&quot;read&quot;</span>, key);<br>                <span class="hljs-comment">// return Reflect.get(target,key,proxy)</span><br>                <span class="hljs-keyword">return</span> target[key];<br>            &#125;<br>        &#125;)<br>        console.log(proxy.c);<br></code></pre></td></tr></table></figure><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><ul><li>算出子串最长前后缀</li><li>遇到不匹配时候，找前一位的前后缀长度，从子串对应长度下标开始比较。</li><li>因为前后缀相同，不用重新比较前面相同的部分。</li></ul><h2 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h2><h2 id="进程状态-1"><a href="#进程状态-1" class="headerlink" title="进程状态"></a>进程状态</h2><h2 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h2><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>cpu</li><li>可以并发且共享资源的执行</li></ul><h1 id="11-8"><a href="#11-8" class="headerlink" title="11.8"></a>11.8</h1><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ul><li>先来先服务</li><li>短作业优先</li><li>时间片轮询</li><li>最高响应比</li><li>最高优先级</li></ul><h2 id="进程通信-1"><a href="#进程通信-1" class="headerlink" title="进程通信"></a>进程通信</h2><ul><li>管道，消息队列，共享内存</li></ul><h2 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h2><ul><li>互斥，占有并等待，不可剥夺，循环等待。</li></ul><h2 id="锁-1"><a href="#锁-1" class="headerlink" title="锁"></a>锁</h2><h2 id="浏览器进程-1"><a href="#浏览器进程-1" class="headerlink" title="浏览器进程"></a>浏览器进程</h2><ul><li>GUI进程</li><li>插件进程</li><li>浏览器进程</li><li>渲染进程</li></ul><h2 id="为什么浏览器限制进程最大数量"><a href="#为什么浏览器限制进程最大数量" class="headerlink" title="为什么浏览器限制进程最大数量"></a>为什么浏览器限制进程最大数量</h2><ul><li>良性竞争</li><li>服务器端口数有限</li><li>避免并发过高</li><li>减少线程切换</li></ul><h2 id="虚拟内存-1"><a href="#虚拟内存-1" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><ul><li>进程隔离，内存扩展，内存管理</li></ul><h2 id="内存分段-1"><a href="#内存分段-1" class="headerlink" title="内存分段"></a>内存分段</h2><h2 id="内存分页-1"><a href="#内存分页-1" class="headerlink" title="内存分页"></a>内存分页</h2><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ul><li>先进先出 </li><li>最近最少使用</li><li>最佳</li><li>最不常用</li></ul><h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><ul><li>两个栈，保证常数时间复杂度查找最小值。</li></ul><h2 id="手写并发请求"><a href="#手写并发请求" class="headerlink" title="手写并发请求"></a>手写并发请求</h2><h1 id="11-9"><a href="#11-9" class="headerlink" title="11.9"></a>11.9</h1><ul><li>计算机网络，操作系统；复习项目，微前端；</li></ul><h2 id="http组成"><a href="#http组成" class="headerlink" title="http组成"></a>http组成</h2><ul><li>请求行，请求头，空行，请求体</li><li>状态行，响应头，空行，响应体</li></ul><h2 id="http状态码-1"><a href="#http状态码-1" class="headerlink" title="http状态码"></a>http状态码</h2><h2 id="http头部字段"><a href="#http头部字段" class="headerlink" title="http头部字段"></a>http头部字段</h2><h2 id="get和post请求区别"><a href="#get和post请求区别" class="headerlink" title="get和post请求区别"></a>get和post请求区别</h2><h2 id="http1-1与http1-0区别，也是http1-1优点"><a href="#http1-1与http1-0区别，也是http1-1优点" class="headerlink" title="http1.1与http1.0区别，也是http1.1优点"></a>http1.1与http1.0区别，也是http1.1优点</h2><ol><li>强制缓存,协商缓存</li><li>host字段</li><li>增加更多状态码</li><li>允许局部请求</li><li>短连接,长连接</li></ol><h2 id="http1-1缺点"><a href="#http1-1缺点" class="headerlink" title="http1.1缺点"></a>http1.1缺点</h2><ul><li>无状态 &#x3D;&gt; cookie,token</li><li>明文传输 &#x3D;&gt; https</li></ul><h2 id="优化http1-1"><a href="#优化http1-1" class="headerlink" title="优化http1.1"></a>优化http1.1</h2><ol><li>缓存</li><li>重定向，按需请求</li><li>压缩请求</li><li>cookie</li><li>https</li></ol><h2 id="https-1"><a href="#https-1" class="headerlink" title="https"></a>https</h2><ul><li>解决了明文传输，身份认证，信息篡改三个问题。</li></ul><ol><li>非对称加密，对称加密 &#x3D;》 明文传输</li><li>摘要算法，私钥签名 &#x3D;》 信息篡改</li><li>数字证书 &#x3D;》身份认证</li></ol><h2 id="tls握手"><a href="#tls握手" class="headerlink" title="tls握手"></a>tls握手</h2><ol><li>随机数，密码套件，tls版本号</li><li>随机数，数字证书，选择tls版本号、密码套件</li><li>解开数字证书获取公钥，公钥加密第三个随机数，三个随机数生成对称密钥，通知后续用对称密钥加密。</li><li>三个随机数生成对称密钥，后续用对称密钥加密。</li></ol><h2 id="https一定安全吗？"><a href="#https一定安全吗？" class="headerlink" title="https一定安全吗？"></a>https一定安全吗？</h2><ul><li>不一定，中间人攻击。如果客户端信任了中间人的非法证书。</li></ul><h2 id="http2-0-1"><a href="#http2-0-1" class="headerlink" title="http2.0"></a>http2.0</h2><h2 id="http3-0-2"><a href="#http3-0-2" class="headerlink" title="http3.0"></a>http3.0</h2><h2 id="父子进程-10024"><a href="#父子进程-10024" class="headerlink" title="父子进程 &#10024;"></a>父子进程 &#10024;</h2><ul><li>父进程：是创建其他进程的进程，父进程通常负责控制和管理其子进程，包括等待子进程的结束、收集子进程的状态、分配资源等。</li><li>子进程：子进程是由父进程创建的新进程，继承了父进程的大部分环境和资源。</li></ul><h2 id="孤儿进程和僵尸进程-10024"><a href="#孤儿进程和僵尸进程-10024" class="headerlink" title="孤儿进程和僵尸进程 &#10024;"></a>孤儿进程和僵尸进程 &#10024;</h2><ul><li>孤儿进程：父进程因特殊情况先于子进程终止。</li><li>僵尸进程：已经终止的子进程，但其进程控制块还在系统的进程表中，等待父进程获取状态。</li></ul><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><h2 id="非负大整数相加"><a href="#非负大整数相加" class="headerlink" title="非负大整数相加"></a>非负大整数相加</h2><h2 id="数组每隔千分位相加"><a href="#数组每隔千分位相加" class="headerlink" title="数组每隔千分位相加"></a>数组每隔千分位相加</h2><h2 id="虾皮一面"><a href="#虾皮一面" class="headerlink" title="虾皮一面"></a>虾皮一面</h2><!-- ## RSA算法 --><h1 id="11-10"><a href="#11-10" class="headerlink" title="11.10"></a>11.10</h1><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><h2 id="找到字符串异位字符"><a href="#找到字符串异位字符" class="headerlink" title="找到字符串异位字符"></a>找到字符串异位字符</h2><h2 id="如何判断需求复杂度"><a href="#如何判断需求复杂度" class="headerlink" title="如何判断需求复杂度"></a>如何判断需求复杂度</h2><ol><li><strong>功能逻辑</strong>：需要的功能越多，业务逻辑越复杂，该需求复杂度越高。</li><li><strong>交互逻辑</strong>：丰富的交互体验，比如：拖拉拽、复杂的表单数据校验。</li><li><strong>接口数量</strong>：接口数量多、数据依赖复杂，调试成本高。</li><li><strong>需求变化</strong>：需求变化是否影响代码的复用性和扩展性，是否需要拆分成多个公共组件等等。</li></ol><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><ul><li>flex-direction,justify-content,flex-wrap,align-item,flex-flow.</li><li>justify-content: flex-start,flex-end,center,space-around(平分剩余空间),space-between(先两边贴边，再平分剩余空间).</li><li>align-item:flex-start,flex-end,center,stretch.</li><li>align-content: flex-start, flex-end,center,space-around,space-between,stretch</li></ul><h1 id="11-11"><a href="#11-11" class="headerlink" title="11.11"></a>11.11</h1><!-- 好事降临 --><h2 id="es5实现extend"><a href="#es5实现extend" class="headerlink" title="es5实现extend"></a>es5实现extend</h2><h2 id="token原理-10024"><a href="#token原理-10024" class="headerlink" title="token原理 &#10024;"></a>token原理 &#10024;</h2><ul><li><a href="https://blog.csdn.net/qq_44972847/article/details/109249604">https://blog.csdn.net/qq_44972847/article/details/109249604</a></li><li>JWT：header（加密算法信息）、payload（用户基本信息，不会放敏感信息）、签名。</li><li>客户端请求头authorization字段携带token，服务端解密签名验证token合法性。</li></ul><h2 id="防抖节流-1"><a href="#防抖节流-1" class="headerlink" title="防抖节流"></a>防抖节流</h2><h2 id="函数柯里化-1"><a href="#函数柯里化-1" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><h2 id="promise-all、promise-race"><a href="#promise-all、promise-race" class="headerlink" title="promise.all、promise.race"></a>promise.all、promise.race</h2><h2 id="promise封装ajax"><a href="#promise封装ajax" class="headerlink" title="promise封装ajax"></a>promise封装ajax</h2><h2 id="xss攻击，csrf攻击"><a href="#xss攻击，csrf攻击" class="headerlink" title="xss攻击，csrf攻击"></a>xss攻击，csrf攻击</h2><h2 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h2><ul><li>剔除接口类型中不需要的属性。</li></ul><h2 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h2><h2 id="patical-1"><a href="#patical-1" class="headerlink" title="patical"></a>patical</h2><h2 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h2><h2 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h2><h2 id="extract"><a href="#extract" class="headerlink" title="extract"></a>extract</h2><h2 id="requied"><a href="#requied" class="headerlink" title="requied"></a>requied</h2><h2 id="回溯：全排列"><a href="#回溯：全排列" class="headerlink" title="回溯：全排列"></a>回溯：全排列</h2><h2 id="下午三点b站面试"><a href="#下午三点b站面试" class="headerlink" title="下午三点b站面试"></a>下午三点b站面试</h2><h2 id="下午五点美团hr面试"><a href="#下午五点美团hr面试" class="headerlink" title="下午五点美团hr面试"></a>下午五点美团hr面试</h2><!-- 操作系统，计算机网络，Ts，微前端 --><h1 id="11-12"><a href="#11-12" class="headerlink" title="11.12"></a>11.12</h1><h2 id="ping一个IP是哪一层协议？"><a href="#ping一个IP是哪一层协议？" class="headerlink" title="ping一个IP是哪一层协议？"></a>ping一个IP是哪一层协议？</h2><ul><li>网络层，用的是ICMP协议。</li></ul><h2 id="六种继承方法"><a href="#六种继承方法" class="headerlink" title="六种继承方法"></a>六种继承方法</h2><h2 id="es5实现extend-1"><a href="#es5实现extend-1" class="headerlink" title="es5实现extend"></a>es5实现extend</h2><h2 id="token原理"><a href="#token原理" class="headerlink" title="token原理"></a>token原理</h2><h2 id="防抖节流-2"><a href="#防抖节流-2" class="headerlink" title="防抖节流"></a>防抖节流</h2><h2 id="cookie和storage能跨域吗？"><a href="#cookie和storage能跨域吗？" class="headerlink" title="cookie和storage能跨域吗？"></a>cookie和storage能跨域吗？</h2><ul><li>不能，都有同源策略限制。</li></ul><h2 id="如何解决上一个问题？"><a href="#如何解决上一个问题？" class="headerlink" title="如何解决上一个问题？"></a>如何解决上一个问题？</h2><ol><li>cookie设置为父域，让子域共享cookie，单点登录时候我们可以这么做。</li></ol><h2 id="如果接手一个项目，如何处理？-10024"><a href="#如果接手一个项目，如何处理？-10024" class="headerlink" title="如果接手一个项目，如何处理？ &#10024;"></a>如果接手一个项目，如何处理？ &#10024;</h2><h2 id="JSON编辑器，其他的diff方案。"><a href="#JSON编辑器，其他的diff方案。" class="headerlink" title="JSON编辑器，其他的diff方案。"></a>JSON编辑器，其他的diff方案。</h2><h2 id="下午b站二面"><a href="#下午b站二面" class="headerlink" title="下午b站二面"></a>下午b站二面</h2><h1 id="11-13"><a href="#11-13" class="headerlink" title="11.13"></a>11.13</h1><!-- 如果结局并非所愿，那就在尘埃落定前奋力一搏。 --><h2 id="前端debug-10024"><a href="#前端debug-10024" class="headerlink" title="前端debug &#10024;"></a>前端debug &#10024;</h2><ul><li><a href="https://juejin.cn/post/7084924971901779998">https://juejin.cn/post/7084924971901779998</a></li><li><a href="https://blog.csdn.net/qq_42961150/article/details/123499276">https://blog.csdn.net/qq_42961150/article/details/123499276</a></li></ul><h3 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h3><ul><li>console.log，console.error</li></ul><h3 id="devtool工具。"><a href="#devtool工具。" class="headerlink" title="devtool工具。"></a>devtool工具。</h3><ul><li>debugger。</li><li>打断点：除了在代码写debugger外还能在调试工具标记断点。</li></ul><h3 id="线上怎么调试"><a href="#线上怎么调试" class="headerlink" title="线上怎么调试"></a>线上怎么调试</h3><ul><li>有代码：console.log，debugger；</li><li>无代码：Override替换功能，找到保存的文件夹开启替换，在请求网络中找到要调试的文件进行更改。</li></ul><h2 id="google-devtool工具-10024"><a href="#google-devtool工具-10024" class="headerlink" title="google devtool工具 &#10024;"></a>google devtool工具 &#10024;</h2><ul><li><a href="https://www.bilibili.com/video/BV1KM4y1G7EF/?spm_id_from=333.337.search-card.all.click&vd_source=9b9c9c2844427b792423aada902b836b">https://www.bilibili.com/video/BV1KM4y1G7EF/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9b9c9c2844427b792423aada902b836b</a></li></ul><h3 id="elements"><a href="#elements" class="headerlink" title="elements"></a>elements</h3><ol><li>查找DOM元素。</li><li>调试css样式，修改类里面的属性值，复制样式（有图形化面板：width、padding、border）</li><li>设置状态：比如按钮一直为hover。</li><li>查看事件：事件监听器里面查看绑定的事件。</li></ol><h3 id="console"><a href="#console" class="headerlink" title="console"></a>console</h3><ol><li>打印变量值</li><li>眼睛：监听变量值</li></ol><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><ol><li>debugger；</li><li>断点；</li><li>watch监测变量。</li></ol><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><ul><li>网络请求，请求是否发出、获取的结果是什么。</li></ul><h3 id="application"><a href="#application" class="headerlink" title="application"></a>application</h3><ul><li>查看cookie、storage。</li></ul><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><ul><li>发送请求，被浏览器代理拦截，请求指向到本机127.0.0.1：8899，8899端口号上有whistle代理，whistle代理配置规则请求的地址为我们本地跑起项目的地址。这样我们本地项目可以借助发送请求的网址的域名下的cookie。</li></ul><h1 id="11-14"><a href="#11-14" class="headerlink" title="11.14"></a>11.14</h1><h2 id="如何封装请求函数"><a href="#如何封装请求函数" class="headerlink" title="如何封装请求函数"></a>如何封装请求函数</h2><ol><li>封装了一个httpclient类，构造函数里确定超时时间</li><li>请求拦截器：携带默认参数content-type、token、post请求参数</li><li>响应拦截器：正常状态码返回data，登录状态过期跳转到登录页面，其他错误打印错误日志抛出错误。</li></ol><h2 id="如何取消请求？"><a href="#如何取消请求？" class="headerlink" title="如何取消请求？"></a>如何取消请求？</h2><ul><li><a href="https://blog.csdn.net/shanghai597/article/details/141132511">https://blog.csdn.net/shanghai597/article/details/141132511</a></li><li><strong>应用场景</strong>：用户加载数据时候跳转到其他页面、用户提交表单时候点击取消按钮就可以取消请求，减少资源消耗、提高用户体验。</li><li><strong>cancelToken取消逻辑</strong>：依赖promise的链式调用，调用cancel方法时候抛出错误，被catch捕获从而触发取消的逻辑。</li><li><strong>具体实现</strong>：每个请求生成唯一标识key，用全局map存储请求的source方法 map.set(key,cancel);请求拦截器取消重复的请求（比如之前请求过，再次请求）、在全局前置路由守卫取消所有请求。</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">config.cancelToken =<span class="hljs-keyword">new</span> axios.CancelToken(<span class="hljs-function"><span class="hljs-params">cancel</span>=&gt;</span><span class="hljs-built_in">map</span>.set(key,cancel));<br></code></pre></td></tr></table></figure><h2 id="setInterval缺点？"><a href="#setInterval缺点？" class="headerlink" title="setInterval缺点？"></a>setInterval缺点？</h2><ul><li>setInterval是每个一段时间把任务推送到任务队列当中</li></ul><ol><li>任务同时执行。上一个任务还在执行，下一个任务就已经推送进来了。</li><li>跳过某些间隔，setInterval仅当队列中没有该定时器其他任务时候才会推入任务。</li></ol><h2 id="vue实现倒计时器"><a href="#vue实现倒计时器" class="headerlink" title="vue实现倒计时器"></a>vue实现倒计时器</h2><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">count</span> &#125;&#125;</span><span class="language-xml"> s<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getCode</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> <span class="hljs-variable constant_">COUNT_NUM</span> = <span class="hljs-number">60</span>;</span></span><br><span class="language-javascript"><span class="language-xml">  count.<span class="hljs-property">value</span> = <span class="hljs-variable constant_">COUNT_NUM</span>;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">countDown</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    timer &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timer);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">if</span> (count.<span class="hljs-property">value</span> &gt; <span class="hljs-number">0</span> &amp;&amp; count.<span class="hljs-property">value</span> &lt;= <span class="hljs-variable constant_">COUNT_NUM</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      count.<span class="hljs-property">value</span>--;</span></span><br><span class="language-javascript"><span class="language-xml">      timer = <span class="hljs-built_in">setTimeout</span>(countDown, <span class="hljs-number">1000</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      timer = <span class="hljs-literal">null</span>;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">countDown</span>();</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">getCode</span>();</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">if</span> (timer) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-built_in">clearTimeout</span>(timer);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.box</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">display</span>: flex;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">justify-content</span>: center;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">align-items</span>: center;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol><li>beforeCreate:调用组件init方法时候调用,此时无法访问初始化数据,创建页面watcher,计算属性等等.</li><li>created:响应式数据,计算属性,监听器等初始化完成,但还未进入渲染阶段.</li><li>beforeMount:模板编译,将模板转换为AST语法树,代码拼接成渲染函数,执行渲染函数生成虚拟DOM,diff对比后生成真实DOM.但未挂载到容器上.</li><li>mounted:将生成的html挂载到容器上.</li><li>beforeUpdate:响应式数据更新时调用,此时数据进行了更新,但页面还未渲染.</li><li>updated:render函数重新执行,页面更新.</li><li>beforeUnmount:组件实例销毁前调用,此时还保留了组件所有功能.</li><li>unMounted: 组件卸载完后调用,清除定时器 DOM监听器等等.</li></ol><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><h2 id="实现准时setTimeout"><a href="#实现准时setTimeout" class="headerlink" title="实现准时setTimeout"></a>实现准时setTimeout</h2><ul><li><a href="https://blog.csdn.net/lgno2/article/details/116574487">https://blog.csdn.net/lgno2/article/details/116574487</a></li></ul><ol><li>worker.js，里面开启while循环</li><li>requestAnimationFrame</li></ol><h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><ul><li>接收一个回调函数作为参数,该回调函数会在浏览器下一次重绘前执行。</li><li>16.67ms执行一次，因为浏览器每秒刷新60次。</li></ul><h1 id="11-15"><a href="#11-15" class="headerlink" title="11.15"></a>11.15</h1><h2 id="上午十一点滴滴一面"><a href="#上午十一点滴滴一面" class="headerlink" title="上午十一点滴滴一面"></a>上午十一点滴滴一面</h2><h2 id="package-json内容"><a href="#package-json内容" class="headerlink" title="package.json内容"></a>package.json内容</h2><ol><li>基本信息：项目名、版本号。</li><li>依赖管理：项目运行时依赖、开发时依赖。</li><li>脚本命令：npm run build</li></ol><h2 id="响应式为什么要用-reflect-这种-API-10024-1"><a href="#响应式为什么要用-reflect-这种-API-10024-1" class="headerlink" title="响应式为什么要用 reflect 这种 API &#10024;"></a>响应式为什么要用 reflect 这种 API &#10024;</h2><ul><li>提供一种更一致和可靠的方式来执行底层的 JavaScript 操作（比如属性访问、赋值、删除等）,代码更简洁易读，13种proxy的捕获器和reflect静态方法一一对应。</li><li>reflect第三个参数可以修改this的指向，把this指向改成代理对象，触发响应式依赖收集。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">如果被代理的对象本身有<span class="hljs-keyword">get</span>函数，<span class="hljs-keyword">get</span>函数里面的<span class="hljs-keyword">this</span>默认指向对象本身。proxy访问这个<br>数据时候，<span class="hljs-keyword">get</span>函数<span class="hljs-keyword">this</span>需要指向proxy，才能触发响应式依赖收集。<br><br> <span class="hljs-keyword">const</span> obj = &#123;<br>            a: <span class="hljs-number">1</span>,<br>            b: <span class="hljs-number">2</span>,<br>            <span class="hljs-keyword">get</span> c() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a + <span class="hljs-keyword">this</span>.b;<br>            &#125;<br>        &#125;<br>        let proxy = new Proxy(obj, &#123;<br>            <span class="hljs-keyword">get</span>(target, key) &#123;<br>                console.log(<span class="hljs-string">&quot;read&quot;</span>, key);<br>                <span class="hljs-comment">// return Reflect.get(target,key,proxy)</span><br>                <span class="hljs-keyword">return</span> target[key];<br>            &#125;<br>        &#125;)<br>        console.log(proxy.c);<br></code></pre></td></tr></table></figure><h2 id="父子进程-10024-1"><a href="#父子进程-10024-1" class="headerlink" title="父子进程 &#10024;"></a>父子进程 &#10024;</h2><ul><li>父进程：是创建其他进程的进程，父进程通常负责控制和管理其子进程，包括等待子进程的结束、收集子进程的状态、分配资源等。</li><li>子进程：子进程是由父进程创建的新进程，继承了父进程的大部分环境和资源。</li></ul><h2 id="孤儿进程和僵尸进程-10024-1"><a href="#孤儿进程和僵尸进程-10024-1" class="headerlink" title="孤儿进程和僵尸进程 &#10024;"></a>孤儿进程和僵尸进程 &#10024;</h2><ul><li>孤儿进程：父进程因特殊情况先于子进程终止。</li><li>僵尸进程：已经终止的子进程，但其进程控制块还在系统的进程表中，等待父进程获取状态。</li></ul><h2 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h2><ul><li>每秒查询次数</li></ul><h2 id="通过前端的手段来减少后端的请求压力-10024"><a href="#通过前端的手段来减少后端的请求压力-10024" class="headerlink" title="通过前端的手段来减少后端的请求压力 &#10024;"></a>通过前端的手段来减少后端的请求压力 &#10024;</h2><!-- 面对一种瞬时的并发请求，QPS有一个瞬间的峰值，作为前端同学 --><ul><li>缓存</li><li>取消重复get请求</li><li>请求合并：前后端共同设计接口</li><li>防抖、节流</li><li>懒加载</li></ul><h2 id="发布订阅-事件总线"><a href="#发布订阅-事件总线" class="headerlink" title="发布订阅&#x2F;事件总线"></a>发布订阅&#x2F;事件总线</h2><h2 id="SSR服务端渲染-2"><a href="#SSR服务端渲染-2" class="headerlink" title="SSR服务端渲染?"></a>SSR服务端渲染?</h2><ul><li>优点:</li></ul><ol><li>更快的首屏加载速度.服务端根据请求路径获取到对应组件,服务端组件请求数据,将组件渲染为html.将html和vue文件作为响应内容返回给客户端.客户端渲染页面,并加载vue文件,将页面变为动态页面.</li><li>更好支持SEO,搜索引擎爬虫可以获取到完全渲染的页面.</li></ol><ul><li>缺点:</li></ul><ol><li>只支持beforeCreate钩子和created钩子.</li><li>增大服务端压力.</li></ol><h1 id="11-16"><a href="#11-16" class="headerlink" title="11.16"></a>11.16</h1><!-- 穷且益坚，不坠青云之志 --><h2 id="微前端项目难点"><a href="#微前端项目难点" class="headerlink" title="微前端项目难点"></a>微前端项目难点</h2><h2 id="diff功能"><a href="#diff功能" class="headerlink" title="diff功能"></a>diff功能</h2><h2 id="开放题：实现可视化报表，前端考虑哪些？-10024"><a href="#开放题：实现可视化报表，前端考虑哪些？-10024" class="headerlink" title="开放题：实现可视化报表，前端考虑哪些？ &#10024;"></a>开放题：实现可视化报表，前端考虑哪些？ &#10024;</h2><ol><li><p>需求分析：<br>数据来源：数据格式、接口、频率。<br>展示内容：维度、排序、拖拽功能。<br>展示形式：表格、柱状图、折线图。</p></li><li><p>数据处理：<br>数据格式化：转换为图表、表格需要的格式数据。<br>数据清洗：处理空值、异常值<br>数据缓存：本地缓存</p></li><li><p>设计实现：<br>技术选型：echarts、组件库。<br>样式上：响应式设计，颜色、字体风格<br>交互：excel导出、选取参数更改表格（一天内、七天内）、拖拽。</p></li><li><p>优化<br>分页<br>按需加载<br>虚拟列表<br>导出用webworker</p></li></ol><h2 id="上午虾皮二面"><a href="#上午虾皮二面" class="headerlink" title="上午虾皮二面"></a>上午虾皮二面</h2><h2 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h2><h1 id="11-17-出去玩一天"><a href="#11-17-出去玩一天" class="headerlink" title="11.17 出去玩一天"></a>11.17 出去玩一天</h1><!-- 后面一周：滴滴、b站、虾皮收尾，周五周末疯狂海投。     复习webpack、！vite！知识点； --><h1 id="11-18"><a href="#11-18" class="headerlink" title="11.18"></a>11.18</h1><h2 id="编写loader"><a href="#编写loader" class="headerlink" title="编写loader"></a>编写loader</h2><p><a href="https://juejin.cn/post/7100534685134454815?searchId=2024111811590127047A1230DEEC4E5372">https://juejin.cn/post/7100534685134454815?searchId=2024111811590127047A1230DEEC4E5372</a></p><ul><li>loader职责是单一、链式传输、易维护。</li></ul><ol><li>本质是函数，this会被webpack填充，不能用箭头函数。</li><li>接受一个参数，为webpack传递loader的文件源，源文件字符串。</li><li>this.callBack异步返回结果，return同步返回结果</li><li>获取配置文件配置项options：loader-utils.getOptions<br>缓存： this.cacheable</li></ol><h2 id="编写plugin"><a href="#编写plugin" class="headerlink" title="编写plugin"></a>编写plugin</h2><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><h2 id="webpack构建流程"><a href="#webpack构建流程" class="headerlink" title="webpack构建流程"></a>webpack构建流程</h2><h2 id="如何提高webpack构建速度"><a href="#如何提高webpack构建速度" class="headerlink" title="如何提高webpack构建速度"></a>如何提高webpack构建速度</h2><h2 id="webpack热模块更新的原理"><a href="#webpack热模块更新的原理" class="headerlink" title="webpack热模块更新的原理"></a>webpack热模块更新的原理</h2><h2 id="vite和webpack区别"><a href="#vite和webpack区别" class="headerlink" title="vite和webpack区别"></a>vite和webpack区别</h2><h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><h2 id="es-和-commonjs区别"><a href="#es-和-commonjs区别" class="headerlink" title="es 和 commonjs区别"></a>es 和 commonjs区别</h2><ul><li>值浅拷贝，引用</li><li>编译时加载、运行时加载</li><li>异步加载、同步加载</li></ul><h2 id="vite核心原理"><a href="#vite核心原理" class="headerlink" title="vite核心原理"></a>vite核心原理</h2><ul><li>浏览器可以支持es6的import，碰见import会发送http请求获取模块的内容；vite启动服务器拦截请求，并进行相应的处理（.vue文件的编译）将文件以ESM格式返回。</li></ul><h2 id="vite构建流程"><a href="#vite构建流程" class="headerlink" title="vite构建流程"></a>vite构建流程</h2><h1 id="11-19"><a href="#11-19" class="headerlink" title="11.19"></a>11.19</h1><h2 id="堆-10024"><a href="#堆-10024" class="headerlink" title="堆 &#10024;"></a>堆 &#10024;</h2><ul><li>必须是完全二叉树</li><li>堆序性：大根堆：每个父元素大于子元素；小根堆：每个父元素小于子元素。</li><li>上滤、下滤 O（logN）</li></ul><h2 id="vite本地开发esbuild，生产rollup-10024"><a href="#vite本地开发esbuild，生产rollup-10024" class="headerlink" title="vite本地开发esbuild，生产rollup &#10024;&#96;"></a>vite本地开发esbuild，生产rollup &#10024;&#96;</h2><ul><li>esbuild：构建速度快，利用浏览器原生支持ESM模块，import代表一个http请求，拦截请求做简单的转换（转换为ESM格式）。</li><li>rollup：只能做简单转换，一些插件API与esbuild打包还不兼容，rollup有打包生命周期钩子，可进行模块解析、treeShaking。</li></ul><h2 id="vue编写倒计时器"><a href="#vue编写倒计时器" class="headerlink" title="vue编写倒计时器"></a>vue编写倒计时器</h2><h2 id="promise数组顺序执行"><a href="#promise数组顺序执行" class="headerlink" title="promise数组顺序执行"></a>promise数组顺序执行</h2><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><h2 id="最长递增子序列-1"><a href="#最长递增子序列-1" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><h2 id="JQ和vue区别"><a href="#JQ和vue区别" class="headerlink" title="JQ和vue区别"></a>JQ和vue区别</h2><ul><li>jq是命令式框架，关注过程</li><li>vue是声明式框架，关注结果，命令式代码封装到vue中</li></ul><h2 id="vue设计"><a href="#vue设计" class="headerlink" title="vue设计"></a>vue设计</h2><ol><li><em><strong>声明式框架</strong></em>：响应式原理</li><li><em><strong>虚拟DOM</strong></em>：第一：diff算法。第二：支持跨平台，服务端渲染、浏览器渲染，将虚拟DOM转换为真实HTML元素。</li><li><em><strong>区分编译时和运行时</strong></em>：<br>编译时：将<strong>模板</strong>变成js语法渲染函数生成的<strong>虚拟DOM</strong>；<br>运行时：上线时只走运行时。</li><li><em><strong>拥抱Ts</strong></em></li></ol><h2 id="两个vue3源码视频"><a href="#两个vue3源码视频" class="headerlink" title="两个vue3源码视频"></a>两个vue3源码视频</h2><h1 id="11-20"><a href="#11-20" class="headerlink" title="11.20"></a>11.20</h1><ul><li>算法 + 手写</li></ul><h2 id="手写new-1"><a href="#手写new-1" class="headerlink" title="手写new"></a>手写new</h2><ul><li>四步</li></ul><h2 id="手写call、apply、bind"><a href="#手写call、apply、bind" class="headerlink" title="手写call、apply、bind"></a>手写call、apply、bind</h2><ul><li>判断是否为函数，拿到context，拿到参数，context.fn，delete</li></ul><h2 id="promise-all"><a href="#promise-all" class="headerlink" title="promise.all"></a>promise.all</h2><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h2><ul><li>返回promise</li></ul><h2 id="最长连续子序列"><a href="#最长连续子序列" class="headerlink" title="最长连续子序列"></a>最长连续子序列</h2><ul><li>动态规划</li><li>双指针</li></ul><h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h2 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h2><h2 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h2><h2 id="Array-prototype-splice-方法"><a href="#Array-prototype-splice-方法" class="headerlink" title="Array.prototype.splice()方法"></a>Array.prototype.splice()方法</h2><ul><li>第一个参数：开始操作数组的起始位置</li><li>第二个参数：删除的元素个数，不传的话后面所有元素都会删除。</li><li>第三个参数：插入&#x2F;替换的元素。</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>.splice(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) //[‘<span class="hljs-number">1</span>’,‘<span class="hljs-number">4</span>’]<br><span class="hljs-attribute">arr</span>.splice(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,&#x27;x&#x27;,<span class="hljs-string">&quot;x&quot;</span>) // 两个元素被替换成一个x/两个x。<br><span class="hljs-attribute">arr</span>.splice(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;x&quot;</span>) // 插入一个x<br></code></pre></td></tr></table></figure><h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><ol><li>返回值不是数组本身！</li><li></li></ol><h1 id="11-21"><a href="#11-21" class="headerlink" title="11.21"></a>11.21</h1><h2 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h2><ol><li>不要shift、pop两次!</li><li>数组为空shift、pop是undefined</li></ol><h2 id="url的字符串拼接"><a href="#url的字符串拼接" class="headerlink" title="url的字符串拼接"></a>url的字符串拼接</h2><h2 id="为什么要用axios而不用原生的xhr或者fetch-10024"><a href="#为什么要用axios而不用原生的xhr或者fetch-10024" class="headerlink" title="为什么要用axios而不用原生的xhr或者fetch &#10024;"></a>为什么要用axios而不用原生的xhr或者fetch &#10024;</h2><ol><li>简洁的API：axios基于promise封装，避免xhr复杂的回调逻辑&#x2F;</li><li>更好的错误处理：fetch不会将http错误码400、500抛出，需要手动抛出；axios会自动抛出。</li><li>请求拦截器、错误拦截器</li><li>自动序列化数据：JSON.stringify、解析数据。</li><li>版本：fetch兼容性更差。</li><li>更方便的请求配置：baseURL、超时设置。</li></ol><h2 id="如何封装请求函数-1"><a href="#如何封装请求函数-1" class="headerlink" title="如何封装请求函数"></a>如何封装请求函数</h2><ol><li>封装了一个httpclient类，构造函数里确定超时时间、baseUrl。</li><li>请求拦截器：携带默认参数content-type、token、post请求参数</li><li>响应拦截器：正常状态码返回data，登录状态过期跳转到登录页面，其他错误打印错误日志抛出错误。</li></ol><h2 id="display-visibility-opacity-1"><a href="#display-visibility-opacity-1" class="headerlink" title="display,visibility,opacity"></a>display,visibility,opacity</h2><ol><li>空间上,display不占据,其他占据</li><li>性能上:display回流重绘,visibility重绘,opacity单独形成合成层,利用GPU加速渲染</li><li>事件上:opacity触发事件</li></ol><h2 id="https缺点"><a href="#https缺点" class="headerlink" title="https缺点"></a>https缺点</h2><ol><li>tls握手开销 &#x3D;&gt; TLS升级</li><li>握手后加密解密的开销</li><li>会话复用：Session ID、token。</li></ol><h2 id="微前端复习"><a href="#微前端复习" class="headerlink" title="微前端复习"></a>微前端复习</h2><h2 id="concat和push区别"><a href="#concat和push区别" class="headerlink" title="concat和push区别"></a>concat和push区别</h2><ol><li>push改变原数组，concat不改变返回新数组。</li></ol><h2 id="滴滴二面"><a href="#滴滴二面" class="headerlink" title="滴滴二面"></a>滴滴二面</h2><h1 id="11-22"><a href="#11-22" class="headerlink" title="11.22"></a>11.22</h1><h2 id="为什么要用axios而不用原生的xhr或者fetch-10024-1"><a href="#为什么要用axios而不用原生的xhr或者fetch-10024-1" class="headerlink" title="为什么要用axios而不用原生的xhr或者fetch &#10024;"></a>为什么要用axios而不用原生的xhr或者fetch &#10024;</h2><ol><li>简洁的API：axios基于promise封装，避免xhr复杂的回调逻辑&#x2F;</li><li>更好的错误处理：fetch不会将http错误码400、500抛出，需要手动抛出；axios会自动抛出。</li><li>请求拦截器、错误拦截器</li><li>自动序列化数据：JSON.stringify、解析数据。</li><li>版本：fetch兼容性更差。</li><li>更方便的请求配置：baseURL、超时设置。</li></ol><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><h2 id="http状态码-2"><a href="#http状态码-2" class="headerlink" title="http状态码"></a>http状态码</h2><ol><li>200、204、206</li><li>301、302、304</li><li>400、403、404</li><li>500、502、503</li></ol><h2 id="http头部字段-1"><a href="#http头部字段-1" class="headerlink" title="http头部字段"></a>http头部字段</h2><ol><li>expires&#x2F;cache-control；etag&#x2F;if-none-match；last-modified&#x2F;if-modified-since；</li><li>content-type&#x2F;accept、content-length、content-encoding&#x2F;accept-coding；</li><li>connection：keep-alive</li><li>host：解决一个ip地址对应多个域名。</li><li>跨域头部字段。</li></ol><h2 id="get和post区别"><a href="#get和post区别" class="headerlink" title="get和post区别"></a>get和post区别</h2><ol><li>本质：获取资源、增删改资源</li><li>缓存：get可以强制缓存、协商缓存</li><li>幂等：get是幂等的、post不是</li><li>请求体：get请求有长度限制，编码只能是url编码；post请求可以放在请求体，编码格式多种。</li></ol><h2 id="强制缓存和协商缓存"><a href="#强制缓存和协商缓存" class="headerlink" title="强制缓存和协商缓存"></a>强制缓存和协商缓存</h2><h2 id="http1-1优缺点（和http1-0区别）"><a href="#http1-1优缺点（和http1-0区别）" class="headerlink" title="http1.1优缺点（和http1.0区别）"></a>http1.1优缺点（和http1.0区别）</h2><p>优点：</p><ol><li>长连接</li><li>局部请求</li><li>增加了状态码</li><li>缓存字段升级</li><li>host字段：解决一个ip地址对应多个域名情况</li></ol><p>缺点：</p><ol><li>无状态 &#x3D;&gt; token&#x2F;session+cookie</li><li>安全性</li></ol><h2 id="https优缺点"><a href="#https优缺点" class="headerlink" title="https优缺点"></a>https优缺点</h2><!-- 先进行TCP三次握手再进行TLS四次握手 --><p>优点：</p><ol><li>加密传输：非对称加密协商会话密钥，通信内容经过会话密钥加密。</li><li>防止内容篡改：摘要算法计算出hash值，对hash值和内容用私钥签名；客户端用公钥解密，摘要算法计算新的hash对比，没变化则说明内容没被篡改。（私钥签名是为了防止内容和hash值一同被篡改）</li><li>身份认证：服务端公钥经过CA私钥签名生成数字证书；客户端浏览器或操作系统内置了CA的公钥，解开数字证书后获取公钥</li></ol><h2 id="非对称加密和对称加密"><a href="#非对称加密和对称加密" class="headerlink" title="非对称加密和对称加密"></a>非对称加密和对称加密</h2><ol><li>非对称加密：有公钥和私钥，可以传输公钥而私钥保密，解决了密钥交换问题但速度慢。</li><li>对称加密：只有一个会话密钥，必须保密，加密解密速度快但不能解决密钥交换。</li></ol><h1 id="11-24"><a href="#11-24" class="headerlink" title="11.24"></a>11.24</h1><h2 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h2><h2 id="TLS握手过程"><a href="#TLS握手过程" class="headerlink" title="TLS握手过程"></a>TLS握手过程</h2><h2 id="数字证书验证-10024"><a href="#数字证书验证-10024" class="headerlink" title="数字证书验证 &#10024;"></a>数字证书验证 &#10024;</h2><ul><li>CA对公钥、有效时间、颁发者等信息进行hash运算，通过私钥签名生成数字证书。客户端拿到数字证书后用内置的公钥解密，计算hash值对比，相同则说明身份是正确的。</li></ul><h2 id="证书信任链"><a href="#证书信任链" class="headerlink" title="证书信任链"></a>证书信任链</h2><ul><li>根证书信任了某些中间证书用私钥加密，中间证书给服务器公钥颁发数字证书。</li><li>我们可以先用根证书的公钥验证中间证书 &#x3D;》 获取中间证书的公钥；再去验证服务器的数字证书。</li></ul><h2 id="https缺点-1"><a href="#https缺点-1" class="headerlink" title="https缺点"></a>https缺点</h2><p>1.<br>2.<br>3. 成本问题<br>4. 安全问题</p><h2 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h2><h2 id="DH、DHE、ECDHE算法"><a href="#DH、DHE、ECDHE算法" class="headerlink" title="DH、DHE、ECDHE算法"></a>DH、DHE、ECDHE算法</h2><h2 id="压缩css类名"><a href="#压缩css类名" class="headerlink" title="压缩css类名"></a>压缩css类名</h2><ul><li>要复习set、map语法</li><li>闭包思想</li><li>fromCharCode API</li></ul><h1 id="11-25"><a href="#11-25" class="headerlink" title="11.25"></a>11.25</h1><h2 id="RSA算法难题"><a href="#RSA算法难题" class="headerlink" title="RSA算法难题"></a>RSA算法难题</h2><ul><li>基于大整数难分解的数学难题。攻击者拿到大整数n、公钥，很难计算大整数n的欧拉函数，因为很难把其拆分成两个质数。但我们私钥计算时候依赖大整数的欧拉函数。</li></ul><h2 id="set和map原理-10024-1"><a href="#set和map原理-10024-1" class="headerlink" title="set和map原理 &#10024;"></a>set和map原理 &#10024;</h2><ul><li>七个数据类型 + object经过hash值处理运算，对应到0-7八个数字；有个长为8的数组，数组每个元素对应一个数据类型，数组每个元素是链表结构存储相同数据类型的不同值。</li></ul><h2 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h2><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><h2 id="平衡二叉树高度-10024"><a href="#平衡二叉树高度-10024" class="headerlink" title="平衡二叉树高度 &#10024;"></a>平衡二叉树高度 &#10024;</h2><p><img src="/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.%E7%A7%8B%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-1.png" alt="alt text"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h1 id="11-26"><a href="#11-26" class="headerlink" title="11.26"></a>11.26</h1><h2 id="如何判断需求复杂度-1"><a href="#如何判断需求复杂度-1" class="headerlink" title="如何判断需求复杂度"></a>如何判断需求复杂度</h2><ol><li><strong>功能逻辑</strong>：需要的功能越多，业务逻辑越复杂，该需求复杂度越高。</li><li><strong>交互逻辑</strong>：丰富的交互体验，比如：拖拉拽、复杂的表单数据校验。</li><li><strong>接口数量</strong>：接口数量多、数据依赖复杂，调试成本高。</li><li><strong>需求变化</strong>：需求变化是否影响代码的复用性和扩展性，是否需要拆分成多个公共组件等等。</li></ol><h2 id="开放题：实现可视化报表，前端考虑哪些？-10024-1"><a href="#开放题：实现可视化报表，前端考虑哪些？-10024-1" class="headerlink" title="开放题：实现可视化报表，前端考虑哪些？ &#10024;"></a>开放题：实现可视化报表，前端考虑哪些？ &#10024;</h2><ol><li><p>需求分析：<br>数据来源：数据格式、接口、频率。<br>展示内容：维度、排序、拖拽功能。<br>展示形式：表格、柱状图、折线图。</p></li><li><p>数据处理：<br>数据格式化：转换为图表、表格需要的格式数据。<br>数据清洗：处理空值、异常值<br>数据缓存：本地缓存</p></li><li><p>设计实现：<br>技术选型：echarts、组件库。<br>样式上：响应式设计，颜色、字体风格<br>交互：excel导出、选取参数更改表格（一天内、七天内）、拖拽。</p></li><li><p>优化<br>分页<br>按需加载<br>虚拟列表<br>导出用webworker</p></li></ol><h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><ul><li>线程之间谦让资源，但都不执行。</li><li>当多线程中出现了相互谦让，都主动将资源释放给别的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。</li></ul><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="堆-9997"><a href="#堆-9997" class="headerlink" title="堆 &#9997;"></a>堆 &#9997;</h2><ul><li><strong>堆是一个完全二叉树</strong>：只允许最后一行不为满，且从左到右排列。</li><li><strong>堆序性</strong>：小根堆，大根堆。</li><li><strong>堆的基本操作</strong>：上滤、下滤。复杂度为O(logn).</li><li><strong>建堆的方法</strong>：<br>自顶向下建堆法（插入堆、上滤：复杂度O(nlogn)：插入一个元素上滤<br>自下而上建堆法（先建个堆、下滤：复杂度O(n)）：从倒数第二行开始下滤<br><strong>！下滤时候与较大的子节点交换！</strong></li></ul><h1 id="11-27"><a href="#11-27" class="headerlink" title="11.27"></a>11.27</h1><h2 id="排序算法时间、空间复杂度"><a href="#排序算法时间、空间复杂度" class="headerlink" title="排序算法时间、空间复杂度"></a>排序算法时间、空间复杂度</h2><ol><li>快速排序：nlogn n2&#x2F; nlogn</li><li>冒泡排序：n2 n  &#x2F; 1</li><li>选择排序 n2 &#x2F; 1</li><li>插入排序：n2 n&#x2F; 1</li><li>归并排序：nlogn &#x2F; n</li></ol><h2 id="js的sort方法"><a href="#js的sort方法" class="headerlink" title="js的sort方法"></a>js的sort方法</h2><ul><li>快速排序和插入排序的结合</li><li>n &lt; 10，插入排序：平均时间复杂度是n2，但理想情况可到n，优于nlogn。</li><li>n &gt; 10，快速排序，时间复杂度nlogn。</li></ul><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul><li>自下而上建堆法：不是nlogn，因为不是每个节点都要下滤到底部，只要最上面一个节点下滤到底部需要logn次操作，所以复杂度为O（n）。</li><li>建立成大根堆后，叶子节点和根节点交换，最大节点到最底层；然后下滤，倒数第二大节点到根节点，交换叶子节点。循环交换和下滤的过程。O（nlogn）。</li></ul><!--两者时间复杂度区别：建堆时候：大部分节点下滤一两次，只有最上面下滤logn次。排序时候：所有节点都要交换到根节点然后下滤，大部分节点下滤logn次。 --><h2 id="压缩css类名-1"><a href="#压缩css类名-1" class="headerlink" title="压缩css类名"></a>压缩css类名</h2><ol><li>闭包，记录index值和映射关系。</li><li>除以26，类似26进制。</li></ol><h2 id="fromCharCode"><a href="#fromCharCode" class="headerlink" title="fromCharCode"></a>fromCharCode</h2><p>fromCharCode() 可接受一个指定的 Unicode 值，然后返回一个字符串。</p><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><ul><li>深度搜索</li><li>广度搜索</li></ul><h2 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById"></a>getElementById</h2><h1 id="11-28"><a href="#11-28" class="headerlink" title="11.28"></a>11.28</h1><h2 id="js基础复习"><a href="#js基础复习" class="headerlink" title="js基础复习"></a>js基础复习</h2><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><ul><li>扩展、拷贝。</li><li>数组合并（别用concat了）</li></ul><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><ul><li>提取变量：解构后，赋值。</li></ul><h2 id="map和object区别"><a href="#map和object区别" class="headerlink" title="map和object区别"></a>map和object区别</h2><ul><li>map键有顺序、无额外值（原型对象）、完整的键值对、可遍历的。</li></ul><h2 id="JSON-stringify-10024"><a href="#JSON-stringify-10024" class="headerlink" title="JSON.stringify &#10024;"></a>JSON.stringify &#10024;</h2><ol><li>数组、undefined、函数、NaN、Infinity、symbol都是null</li><li>循环引用报错</li><li>不可遍历属性不能转换</li></ol><h2 id="encodeURI、encodeURIComponent-10024"><a href="#encodeURI、encodeURIComponent-10024" class="headerlink" title="encodeURI、encodeURIComponent &#10024;"></a>encodeURI、encodeURIComponent &#10024;</h2><ol><li>encode URI：对整体uri转义（比如：中文、空格），但不会转换特殊字符（比如：&amp; ？ ： &#x2F;）</li><li>encodeURIComponent：对所有进行转义,如果我们参数里面有（&amp; ？ ： &#x2F;避免其影响url解析，就要用这个）</li></ol><h2 id="为什么要用axios而不用原生的xhr或者fetch-10024-2"><a href="#为什么要用axios而不用原生的xhr或者fetch-10024-2" class="headerlink" title="为什么要用axios而不用原生的xhr或者fetch &#10024;"></a>为什么要用axios而不用原生的xhr或者fetch &#10024;</h2><ol><li>简洁的API：axios基于promise封装，避免xhr复杂的回调逻辑&#x2F;</li><li>更好的错误处理：fetch不会将http错误码400、500抛出，需要手动抛出；axios会自动抛出。</li><li>请求拦截器、错误拦截器</li><li>自动序列化数据：JSON.stringify、解析数据。</li><li>版本：fetch兼容性更差。</li><li>更方便的请求配置：baseURL、超时设置。</li></ol><ul><li>下午复习完js基础+原型链（速过）深搜、广搜、腐烂的橘子</li></ul><h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><ul><li>默认是一个空的Object对象，存放共有属性和方法，减少内存。</li><li>不是所有函数都有原型对象，箭头函数、bind返回的函数</li></ul><h2 id="原型上的方法this指向-10024"><a href="#原型上的方法this指向-10024" class="headerlink" title="原型上的方法this指向 &#10024;"></a>原型上的方法this指向 &#10024;</h2><ul><li>指向实例对象，不是原型对象！</li></ul><h2 id="Function-proto-Function-prototype鸡蛋问题-10024"><a href="#Function-proto-Function-prototype鸡蛋问题-10024" class="headerlink" title="Function.proto &#x3D;&#x3D;&#x3D; Function.prototype鸡蛋问题 &#10024;"></a>Function.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Function.prototype鸡蛋问题 &#10024;</h2><ul><li>两者指向同一地址，先有prototype再有__proto__.</li><li>Function在任何引擎执行代码前就已经在内存中。先有的原型链顶层Object.prototype，继承该对象有了Function.prototype，然后将Function原型对象指向Function.prototype.其它构造函数继承Function.prototype产生。</li></ul><h1 id="11-29"><a href="#11-29" class="headerlink" title="11.29"></a>11.29</h1><h2 id="js看完，看部分es6"><a href="#js看完，看部分es6" class="headerlink" title="js看完，看部分es6."></a>js看完，看部分es6.</h2><h2 id="为什么变量提升？"><a href="#为什么变量提升？" class="headerlink" title="为什么变量提升？"></a>为什么变量提升？</h2><ul><li>预解析阶段，创建执行上下文，词法环境（对外部环境的引用）；代码开始执行后，会去作用域链查找对应的值。</li></ul><h2 id="编译性语言和解释性语言"><a href="#编译性语言和解释性语言" class="headerlink" title="编译性语言和解释性语言"></a>编译性语言和解释性语言</h2><ul><li>编译性语言：编译代码为机器码，后续运行使用同一编译结果即可。执行效率高，但依赖编译器跨平台性差。</li><li>解释性语言：解释器边转换代码边执行，没有编译过程。跨平台性好。</li></ul><h2 id="执行上下文-1"><a href="#执行上下文-1" class="headerlink" title="执行上下文"></a>执行上下文</h2><h2 id="作用域-1"><a href="#作用域-1" class="headerlink" title="作用域"></a>作用域</h2><h2 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h2><h2 id="this指向-1"><a href="#this指向-1" class="headerlink" title="this指向"></a>this指向</h2><h2 id="call和apply区别"><a href="#call和apply区别" class="headerlink" title="call和apply区别"></a>call和apply区别</h2><h1 id="11-30"><a href="#11-30" class="headerlink" title="11.30"></a>11.30</h1><!-- 不知不觉11月最后一天了，offer在哪一天？ --><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h2 id="promise中断请求"><a href="#promise中断请求" class="headerlink" title="promise中断请求"></a>promise中断请求</h2><ul><li>promise.race，只有一个promise结果可以返回，获取请求promise的reject函数，在另一个promise（一直是pending状态）调用该reject。</li></ul><h2 id="异步编程代码输出题"><a href="#异步编程代码输出题" class="headerlink" title="异步编程代码输出题"></a>异步编程代码输出题</h2><ul><li>如果async函数中抛出了错误，就会终止错误结果，不会继续向下执行。除非用try catch或者catch回调捕捉错误。</li><li>注意setTimeout时间，不一定都是0s。</li></ul><h2 id="settimeout"><a href="#settimeout" class="headerlink" title="settimeout"></a>settimeout</h2><h2 id="this代码输出题目"><a href="#this代码输出题目" class="headerlink" title="this代码输出题目"></a>this代码输出题目</h2><h1 id="12-1"><a href="#12-1" class="headerlink" title="12.1"></a>12.1</h1><!-- 十二月咯 --><h2 id="作用域代码输出题"><a href="#作用域代码输出题" class="headerlink" title="作用域代码输出题"></a>作用域代码输出题</h2><ul><li>思路要清晰</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n, o)</span></span> &#123;<br>  console.log(o)<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span>: <span class="hljs-title">function</span><span class="hljs-params">(m)</span></span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(m, n)</span></span>;<br>    &#125;<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;  a.<span class="hljs-keyword">fun</span>(<span class="hljs-number">1</span>);  a.<span class="hljs-keyword">fun</span>(<span class="hljs-number">2</span>);  a.<span class="hljs-keyword">fun</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>.<span class="hljs-keyword">fun</span>(<span class="hljs-number">1</span>).<span class="hljs-keyword">fun</span>(<span class="hljs-number">2</span>).<span class="hljs-keyword">fun</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> c = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>.<span class="hljs-keyword">fun</span>(<span class="hljs-number">1</span>);  c.<span class="hljs-keyword">fun</span>(<span class="hljs-number">2</span>);  c.<span class="hljs-keyword">fun</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h2 id="js的离谱转换"><a href="#js的离谱转换" class="headerlink" title="js的离谱转换"></a>js的离谱转换</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">f = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;   <br>g = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;   <br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;   <br>   <span class="hljs-keyword">if</span> (g() &amp;&amp; [] == ![]) &#123;   <br>      f = <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;   <br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;   <br>   &#125;   <br>&#125;)();   <br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(f());<br></code></pre></td></tr></table></figure><h2 id="var-1"><a href="#var-1" class="headerlink" title="var"></a>var</h2><ul><li>没有声明符的变量，就是全局变量。</li><li>var的变量提升。</li></ul><h2 id="原型链代码输出题"><a href="#原型链代码输出题" class="headerlink" title="原型链代码输出题"></a>原型链代码输出题</h2><h2 id="原型上的方法this指向-10024-1"><a href="#原型上的方法this指向-10024-1" class="headerlink" title="原型上的方法this指向 &#10024;"></a>原型上的方法this指向 &#10024;</h2><ul><li>如果是原型链自己查找的，指向对象本身。</li><li>如果显性写出来，是原型对象。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(a)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.a = a;<br>&#125;<br><span class="hljs-keyword">fun</span>.prototype = &#123;<br>    a: <span class="hljs-number">9999</span>,<br>    f()&#123;<br>    console.log(<span class="hljs-keyword">this</span>);<br>    console.log(<span class="hljs-keyword">this</span>.a);<br>    &#125;            <br>&#125;<br>let fn = new <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">123</span>)</span></span>;<br>fn.f(); <span class="hljs-comment">// this指向fn本身。</span><br>fn.__proto__.f(); <span class="hljs-comment">// this指向原型对象。</span><br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol><li>原型链继承</li><li>盗用构造函数</li><li>组合继承</li><li>原型式继承</li><li>寄生式继承</li><li>寄生组合继承</li></ol><h2 id="垃圾回收机制-1"><a href="#垃圾回收机制-1" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><h1 id="12-02"><a href="#12-02" class="headerlink" title="12.02"></a>12.02</h1><h2 id="Object-create是浅拷贝"><a href="#Object-create是浅拷贝" class="headerlink" title="Object.create是浅拷贝"></a>Object.create是浅拷贝</h2><ul><li>如果父构造函数原型对象改变，会影响到子构造函数原型对象。</li><li>理解错误纠正点：子构造函数改变不会影响父构造函数，因为父构造函数是子构造函数的__proto__属性，两者隔了一层。</li></ul><h2 id="作用域链和执行上下文"><a href="#作用域链和执行上下文" class="headerlink" title="作用域链和执行上下文"></a>作用域链和执行上下文</h2><ul><li>理解错误纠正点：当代码解析到函数定义时候，外层的执行上下文是已经创建好了的，所以解析到函数定义时候预创建作用域链是合理的。</li></ul><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ul><li>注意查找原型链是去proto上面去找，不要因为构造函数被误导去prototype上去找了。</li></ul><h2 id="总结一道题"><a href="#总结一道题" class="headerlink" title="总结一道题"></a>总结一道题</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function Parent() &#123;<br>    <span class="hljs-keyword">this</span>.a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">this</span>.b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-keyword">this</span>.a];<br>    <span class="hljs-keyword">this</span>.c = &#123; demo: <span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-keyword">this</span>.show = function () &#123;<br>        console.log(<span class="hljs-keyword">this</span>.a , <span class="hljs-keyword">this</span>.b , <span class="hljs-keyword">this</span>.c.demo );<br>    &#125;<br>&#125;<br><br>function Child() &#123;<br>    <span class="hljs-keyword">this</span>.a = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">this</span>.change = function () &#123;<br>        <span class="hljs-keyword">this</span>.b.push(<span class="hljs-keyword">this</span>.a);<br>        <span class="hljs-keyword">this</span>.a = <span class="hljs-keyword">this</span>.b.length;<br>        <span class="hljs-keyword">this</span>.c.demo = <span class="hljs-keyword">this</span>.a++;<br>    &#125;<br>&#125;<br><br>Child.prototype = new Parent();<br><span class="hljs-keyword">var</span> parent = new Parent();<br><span class="hljs-keyword">var</span> child1 = new Child();<br><span class="hljs-keyword">var</span> child2 = new Child();<br>child1.a = <span class="hljs-number">11</span>;<br>child2.a = <span class="hljs-number">12</span>;<br>parent.show();<br>child1.show();<br>child2.show();<br>child1.change();<br>child2.change();<br>parent.show();<br>child1.show();<br>child2.show();<br><br><span class="hljs-number">1.</span> 创建两个Parent实例，一个实例为子构造函数的原型对象，子构造函数共享这个实例的数据。（原型链继承）<br><span class="hljs-number">2.</span>  <br></code></pre></td></tr></table></figure><h2 id="MVC-MVVM-MVP-1"><a href="#MVC-MVVM-MVP-1" class="headerlink" title="MVC MVVM MVP"></a>MVC MVVM MVP</h2><ol><li><em><strong>MVC观察者模式model可直接到view</strong></em>:采用了<strong>观察者模式</strong>,数据更改立即通知页面更新.数据和页面有一定耦合性.页面更改时,会触发controller来控制model层数据更新.</li><li><em><strong>MVP</strong></em>:view和model都需要经过中间处理.</li><li><em><strong>MVVM</strong></em>:VM对P的升级,将手动的   数据更改&#x3D;&gt;页面 操作自动化.降低代码复杂度</li></ol><h2 id="URLSearchParams-9997"><a href="#URLSearchParams-9997" class="headerlink" title="URLSearchParams &#9997;"></a>URLSearchParams &#9997;</h2><ul><li><a href="https://blog.csdn.net/weixin_42289279/article/details/134157803">https://blog.csdn.net/weixin_42289279/article/details/134157803</a></li></ul><ol><li>size：参数个数</li><li><strong>get、getAll</strong></li><li><strong>有迭代器，for…of 可以遍历</strong></li><li>has、set、delete、append</li><li>toString</li></ol><h2 id="new-URL-9997"><a href="#new-URL-9997" class="headerlink" title="new URL &#9997;"></a>new URL &#9997;</h2><ul><li>将url字符串构造解析为一个URL对象，方便获取&#x2F;操作url的部分，也可以修改后toString返回新的url。</li></ul><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">const</span> <span class="hljs-built_in">url</span> = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&#x27;https://example.com/path?name=John#section&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">url</span>.protocol); <span class="hljs-comment">// &#x27;https:&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">url</span>.hostname); <span class="hljs-comment">// &#x27;example.com&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">url</span>.pathname); <span class="hljs-comment">// &#x27;/path&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">url</span>.search);   <span class="hljs-comment">// &#x27;?name=John&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">url</span>.hash);     <span class="hljs-comment">// &#x27;#section&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="不同地点访问同一个url区别-9997-1"><a href="#不同地点访问同一个url区别-9997-1" class="headerlink" title="不同地点访问同一个url区别 &#9997;"></a>不同地点访问同一个url区别 &#9997;</h2><ol><li>缓存</li><li>ip地址不同，路由器转发，交换机转发经过的网络路径不同。</li><li>网速不同，获取资源速度不同。</li></ol><h2 id="手撕：如何进入if语句"><a href="#手撕：如何进入if语句" class="headerlink" title="手撕：如何进入if语句"></a>手撕：如何进入if语句</h2><!-- 下午:看mvvm、mvc、mvp；看一道手写代码题目。三点一十前搞完 --><h1 id="12-5"><a href="#12-5" class="headerlink" title="12.5"></a>12.5</h1><ul><li>投好未来，复习js手写js。复习vue。</li></ul><h2 id="遍历器"><a href="#遍历器" class="headerlink" title="遍历器"></a>遍历器</h2><h2 id="for-in-for-of遍历数组"><a href="#for-in-for-of遍历数组" class="headerlink" title="for in &#x2F; for of遍历数组"></a>for in &#x2F; for of遍历数组</h2><ul><li>for in 是遍历数组键名也就是下标01234。还会遍历原型对象上添加的属性。</li><li>for of 是遍历数组的值。for of是调用遍历器对象。</li></ul><!-- for in遍历对象也是对象的键值，因为数组也是01234为键名，所有for in遍历数组是01234的下标 --><h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><ul><li>就是键为数字的对象，还有个length属性</li></ul><h2 id="手撕：解析url参数"><a href="#手撕：解析url参数" class="headerlink" title="手撕：解析url参数"></a>手撕：解析url参数</h2><h2 id="手撕：如何进入if语句-1"><a href="#手撕：如何进入if语句-1" class="headerlink" title="手撕：如何进入if语句"></a>手撕：如何进入if语句</h2><h2 id="手撕：vue双向数据绑定"><a href="#手撕：vue双向数据绑定" class="headerlink" title="手撕：vue双向数据绑定"></a>手撕：vue双向数据绑定</h2><h2 id="理解双向数据绑定和vue区别"><a href="#理解双向数据绑定和vue区别" class="headerlink" title="理解双向数据绑定和vue区别"></a>理解双向数据绑定和vue区别</h2><h2 id="string的replace方法-10024"><a href="#string的replace方法-10024" class="headerlink" title="string的replace方法 &#10024;"></a>string的replace方法 &#10024;</h2><ul><li><a href="https://blog.csdn.net/qq_46658751/article/details/123390095">https://blog.csdn.net/qq_46658751/article/details/123390095</a></li></ul><ol><li>replace(字符串，字符串)，只能替换一次</li><li>replace（正则&#x2F;g，字符串）多次替换</li><li>replace（正则，函数）核心用法，函数第一个参数是匹配到的子串，第二个是起始索引，第三个是字符串本身。如果有捕获器的值则插入在第二个参数，起始索引变第三个参数，字符串本身变第四个参数。</li></ol><h2 id="捕获器"><a href="#捕获器" class="headerlink" title="捕获器"></a>捕获器</h2><ul><li>在匹配时候将正则表达式匹配的部分内容保留下来，以便后续使用。</li><li>使用 圆括号 () 来定义捕获组。捕获组会将括号内匹配的内容保存起来。</li></ul><h2 id="手撕：模板字符串"><a href="#手撕：模板字符串" class="headerlink" title="手撕：模板字符串"></a>手撕：模板字符串</h2><h2 id="promise任务调度器"><a href="#promise任务调度器" class="headerlink" title="promise任务调度器"></a>promise任务调度器</h2><h1 id="12-6"><a href="#12-6" class="headerlink" title="12.6"></a>12.6</h1><h2 id="垃圾回收机制-10024"><a href="#垃圾回收机制-10024" class="headerlink" title="垃圾回收机制 &#10024;"></a>垃圾回收机制 &#10024;</h2><ul><li><a href="https://juejin.cn/post/7280787122016059426">https://juejin.cn/post/7280787122016059426</a></li></ul><ol><li>js为对象、变量、函数分配内存，当不再使用这些值时候，垃圾回收机制会收回对应的内存。</li><li>全局变量、局部变量，全局变量要等页面卸载才会回收，局部变量等函数执行完毕退出执行栈时候回收；特殊情况：闭包下不会回收函数执行上下文的词法环境。</li><li>引用计数</li><li>标记清除</li><li>分代回收：根据生命周期分为新旧生代，旧生代采用标记清除。新生代有from to两个空间，刚进来变量放在from里，from满之后进行标记清除，剩下的变量放到to中；然后to变成from，from变成to，重复上述过程。</li><li>闲时收集：CPU空闲时候才进行垃圾回收。</li></ol><h2 id="手写并发请求-1"><a href="#手写并发请求-1" class="headerlink" title="手写并发请求"></a>手写并发请求</h2><h2 id="手写进度条"><a href="#手写进度条" class="headerlink" title="手写进度条"></a>手写进度条</h2><h2 id="requestAnimationFrame-10024"><a href="#requestAnimationFrame-10024" class="headerlink" title="requestAnimationFrame &#10024;"></a>requestAnimationFrame &#10024;</h2><ol><li>60HZ &#x3D;&gt; 1s刷新60次 &#x3D;&gt; 1000ms&#x2F;60 &#x3D; 16.67ms 刷新一次</li><li>解决setTimeout时间不稳定情况：是推入到宏任务等待执行，还有微任务同步任务执行时间的误差。</li><li><strong>该api不由js控制，由系统时间间隔控制，时间间隔固定是16.67ms。</strong></li></ol><h2 id="DocumentFragments-10024"><a href="#DocumentFragments-10024" class="headerlink" title="DocumentFragments &#10024;"></a>DocumentFragments &#10024;</h2><ol><li>DocumentFragments 是 DOM 节点。它们不是主 DOM 树的一部分。通常的用例是创建文档片段，元素附加到文档片段，然后将文档片段附加到 DOM 树。</li><li>文档片段存在于内存中，并不在 DOM 树中，所以将子元素插入到文档片段时不会引起页面回流</li></ol><h2 id="渲染万条数据"><a href="#渲染万条数据" class="headerlink" title="渲染万条数据"></a>渲染万条数据</h2><ul><li>文档碎片减少<strong>回流</strong></li><li>动画帧<strong>拆分任务</strong></li><li>将一个大任务拆分成多个小任务，每个小任务是创建文档碎片，将一次性渲染的dom节点添加到文档碎片中，这个小任务在动画帧中执行，也就是每次重绘前执行。优化dom操作：通过文档碎片，减少dom树更改；优化渲染：通过动画帧，每次重绘前将新增的dom节点添加到dom树中。</li></ul><h1 id="12-7"><a href="#12-7" class="headerlink" title="12.7"></a>12.7</h1><h2 id="any和unkown区别"><a href="#any和unkown区别" class="headerlink" title="any和unkown区别"></a>any和unkown区别</h2><h2 id="interface接口和类区别"><a href="#interface接口和类区别" class="headerlink" title="interface接口和类区别"></a>interface接口和类区别</h2><h2 id="js和ts区别"><a href="#js和ts区别" class="headerlink" title="js和ts区别"></a>js和ts区别</h2><ol><li>后缀 执行速度</li><li>ts是超集</li><li>强类型语言，弱类型语言</li><li>编译时检测错误</li><li>泛型、接口、模块化</li></ol><h2 id="枚举类型-1"><a href="#枚举类型-1" class="headerlink" title="枚举类型"></a>枚举类型</h2><h2 id="接口定义函数类型"><a href="#接口定义函数类型" class="headerlink" title="接口定义函数类型"></a>接口定义函数类型</h2><p>interface SeachObj{<br>  (name:string, age: number) &#x3D;&gt; string;<br>}</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h2 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h2><h2 id="函数理解"><a href="#函数理解" class="headerlink" title="函数理解"></a>函数理解</h2><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="高级类型-1"><a href="#高级类型-1" class="headerlink" title="高级类型"></a>高级类型</h2><h2 id="as-const"><a href="#as-const" class="headerlink" title="as const"></a>as const</h2><p>as const 使得对象中的字符串值保持为字面量类型，而不是宽泛的 string 类型，从而能在后续的类型推断中提供更严格的类型信息。</p><h2 id="typeof作用"><a href="#typeof作用" class="headerlink" title="typeof作用"></a>typeof作用</h2><h2 id="returnType-1"><a href="#returnType-1" class="headerlink" title="returnType"></a>returnType</h2><h2 id="parameters"><a href="#parameters" class="headerlink" title="parameters"></a>parameters</h2><h2 id="patical-2"><a href="#patical-2" class="headerlink" title="patical"></a>patical</h2><h2 id="required"><a href="#required" class="headerlink" title="required"></a>required</h2><h2 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h2><h2 id="联合类型的分配"><a href="#联合类型的分配" class="headerlink" title="联合类型的分配"></a>联合类型的分配</h2><ul><li>当条件类型（extends）应用于 联合类型 时，TypeScript 会将联合类型中的每个成员逐个进行判断，而不是一次性地判断整个联合类型。</li></ul><h2 id="exclude-extract"><a href="#exclude-extract" class="headerlink" title="exclude extract"></a>exclude extract</h2><h2 id="omit-pick"><a href="#omit-pick" class="headerlink" title="omit pick"></a>omit pick</h2><h2 id="算法题：最长不重复子串"><a href="#算法题：最长不重复子串" class="headerlink" title="算法题：最长不重复子串"></a>算法题：最长不重复子串</h2><h1 id="12-8"><a href="#12-8" class="headerlink" title="12.8"></a>12.8</h1><h2 id="蓝眼睛问题"><a href="#蓝眼睛问题" class="headerlink" title="蓝眼睛问题"></a>蓝眼睛问题</h2><ol><li>一个蓝眼睛看其他人没有蓝眼睛，第一天离开。</li><li>两个蓝眼睛，看有其他蓝眼睛第一天不离开，第二天发现他没离开说明不止一个蓝眼睛，而自己看其他人都不是蓝眼睛，所以自己离开。</li><li>三个蓝眼睛，第二天过后发现这两个蓝眼睛都没离开，说明不止两个蓝眼睛，看其他人都不是蓝眼睛，所以自己离开。</li><li>以此类推，k个蓝眼睛，第k天全部离开。</li></ol><h2 id="交叉类型冲突"><a href="#交叉类型冲突" class="headerlink" title="交叉类型冲突"></a>交叉类型冲突</h2><ol><li>直接报错</li><li>解决办法：用any，联合类型</li></ol><h2 id="算法题：最长连续序列"><a href="#算法题：最长连续序列" class="headerlink" title="算法题：最长连续序列"></a>算法题：最长连续序列</h2><h2 id="算法题：字母异位词分组"><a href="#算法题：字母异位词分组" class="headerlink" title="算法题：字母异位词分组"></a>算法题：字母异位词分组</h2><h2 id="算法题：数组中第k大的数（还要整理）"><a href="#算法题：数组中第k大的数（还要整理）" class="headerlink" title="算法题：数组中第k大的数（还要整理）"></a>算法题：数组中第k大的数（还要整理）</h2><h2 id="loader、plugin"><a href="#loader、plugin" class="headerlink" title="loader、plugin"></a>loader、plugin</h2><h2 id="webpack功能"><a href="#webpack功能" class="headerlink" title="webpack功能"></a>webpack功能</h2><ol><li>编译代码能力，解析es6，解决浏览器兼容</li><li>模块整合能力，将多个模块整合为一个文件，减少浏览器请求</li><li>万物皆可模块化，支持不同种类的模块类型。</li></ol><h2 id="webpack构建流程-1"><a href="#webpack构建流程-1" class="headerlink" title="webpack构建流程"></a>webpack构建流程</h2><h2 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h2><h2 id="优化webpack打包速度"><a href="#优化webpack打包速度" class="headerlink" title="优化webpack打包速度"></a>优化webpack打包速度</h2><ul><li><a href="https://chatgpt.com/c/675593b5-4a54-800f-944b-f14fabacdd0c">https://chatgpt.com/c/675593b5-4a54-800f-944b-f14fabacdd0c</a></li></ul><ol><li>cache-loader</li><li>terser plugin开启多线程</li><li>loader不作用node-module，excude、include优化loader</li><li>dll plugin 公共模块提取出来，直接引入</li></ol><h1 id="12-9"><a href="#12-9" class="headerlink" title="12.9"></a>12.9</h1><ul><li>上午+下午部分时间：webpack、vite，下午多刷题。</li><li>晚上：开始vue</li></ul><h2 id="loader、plugin-1"><a href="#loader、plugin-1" class="headerlink" title="loader、plugin"></a>loader、plugin</h2><h2 id="webpack构建流程-2"><a href="#webpack构建流程-2" class="headerlink" title="webpack构建流程"></a>webpack构建流程</h2><h2 id="优化webpack构建速度"><a href="#优化webpack构建速度" class="headerlink" title="优化webpack构建速度"></a>优化webpack构建速度</h2><ol><li>cache-loader</li><li>多线程loader</li><li>exclude</li><li>dllplugin</li><li>代码分割</li></ol><h2 id="如何减少打包体积"><a href="#如何减少打包体积" class="headerlink" title="如何减少打包体积"></a>如何减少打包体积</h2><ol><li>tree-shaking：剔除没用的代码部分。</li><li>删除不必要的依赖：开发依赖下载到开发中</li><li>按需引入：组件库对应的插件，不要引入所有组件</li><li>图片压缩：image-webpack-plugin</li><li>js：terser-plugin，webpack5自带，压缩css，删除空格注释，变量名简写</li><li>css压缩</li></ol><h2 id="热模块更新"><a href="#热模块更新" class="headerlink" title="热模块更新"></a>热模块更新</h2><ol><li>客户端和服务端建立websocket连接</li><li>webpack检测到变化后重新编译对应的模块</li><li>通过websocket传递新模块的hash值</li><li>浏览器用hash请求更新的mokuai</li><li>浏览器更新</li></ol><h2 id="vite-和-webpack区别"><a href="#vite-和-webpack区别" class="headerlink" title="vite 和 webpack区别"></a>vite 和 webpack区别</h2><ol><li>快速冷启动：vite启动开发服务器，不会进行打包，利用es模块特性，请求对应的模块才对对应的模块处理为esm格式返回；webpack需要进行完整的打包生命周期。</li><li>热模块更新：vite直接通知浏览器重新请求更新的模块，然后返回对应的模块；webpack需要先重新编译，然后再通知浏览器。</li><li>http2：vite利用http2，请求文件可以为多个小文件，请求速度更快；vite也有强制缓存和协商缓存。</li><li>线程：vite是go编写，可以利用多线程；webpack是nodejs编写，利用多线程需要插件。</li></ol><h2 id="vite核心原理-1"><a href="#vite核心原理-1" class="headerlink" title="vite核心原理"></a>vite核心原理</h2><ul><li>vite直接启动开发服务器，不用进行整个项目的打包编译，按需请求。</li><li>会预处理所有文件为esm格式，利用浏览器对esm的支持，遇到import再去请求对应的模块，vite会在服务器中间拦截处理文件（比如vue编译）</li></ul><h2 id="vite本地开发esbuild，打包rollup"><a href="#vite本地开发esbuild，打包rollup" class="headerlink" title="vite本地开发esbuild，打包rollup"></a>vite本地开发esbuild，打包rollup</h2><h2 id="编写loader-1"><a href="#编写loader-1" class="headerlink" title="编写loader"></a>编写loader</h2><h2 id="编写plugin-1"><a href="#编写plugin-1" class="headerlink" title="编写plugin"></a>编写plugin</h2><h2 id="算法题：移动零"><a href="#算法题：移动零" class="headerlink" title="算法题：移动零"></a>算法题：移动零</h2><h2 id="算法题：盛最多水的容器"><a href="#算法题：盛最多水的容器" class="headerlink" title="算法题：盛最多水的容器"></a>算法题：盛最多水的容器</h2><h2 id="算法题：三树之和"><a href="#算法题：三树之和" class="headerlink" title="算法题：三树之和"></a>算法题：三树之和</h2><h2 id="生成AST语法树"><a href="#生成AST语法树" class="headerlink" title="生成AST语法树"></a>生成AST语法树</h2><ol><li>是一个裁剪开始标签、文本标签、结束标签，直到模板字符串为空。</li><li>根据开始标签创建节点，注意父子节点以及根节点判断。</li><li>全局变量，栈结构，栈末尾就是当前父节点。</li><li>最终生成ast语法树，根开始标签就是根节点，根开始标签下的开始标签就是子节点，以此类推。</li></ol><!-- ## js、ts、webpackvite、 --><h1 id="12-10"><a href="#12-10" class="headerlink" title="12.10"></a>12.10</h1><h2 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h2><ul><li>vue，刷算法</li></ul><h2 id="AST语法树"><a href="#AST语法树" class="headerlink" title="AST语法树"></a>AST语法树</h2><h2 id="AST语法树代码拼接为渲染函数"><a href="#AST语法树代码拼接为渲染函数" class="headerlink" title="AST语法树代码拼接为渲染函数"></a>AST语法树代码拼接为渲染函数</h2><ul><li>将ast语法树对象解析为一个字符串，调用_c创建虚拟标签节点、_v创建虚拟文本节点，with（this），this就是组件实例，上面有响应式的数据。new Function这个字符串，生成渲染函数。</li></ul><h2 id="AST语法树和虚拟DOM区别"><a href="#AST语法树和虚拟DOM区别" class="headerlink" title="AST语法树和虚拟DOM区别"></a>AST语法树和虚拟DOM区别</h2><h2 id="vue2-diff算法"><a href="#vue2-diff算法" class="headerlink" title="vue2 diff算法"></a>vue2 diff算法</h2><h2 id="vue3-diff算法"><a href="#vue3-diff算法" class="headerlink" title="vue3 diff算法"></a>vue3 diff算法</h2><h2 id="响应式原理-1"><a href="#响应式原理-1" class="headerlink" title="响应式原理"></a>响应式原理</h2><ul><li>数据劫持 + 发布订阅</li></ul><h2 id="数组响应式原理-1"><a href="#数组响应式原理-1" class="headerlink" title="数组响应式原理"></a>数组响应式原理</h2><ul><li>除了对象属性会有dep类以外，每个对象本身也会有一个dep类，在__ob__属性上。<br>一是可以根据这个属性判断该对象是否已经处理为响应式；<br>二是数组的变异方法里手动调用dep.notify更新页面。</li></ul><h2 id="vue3响应式原理"><a href="#vue3响应式原理" class="headerlink" title="vue3响应式原理"></a>vue3响应式原理</h2><ol><li>使用proxy代替Object.defineProperty，完整的代理，数组下标修改、对象的新增删除都能检测到。</li><li>set、map数据结构的方法重写，也能触发响应式。</li></ol><h2 id="为什么使用reflect-API"><a href="#为什么使用reflect-API" class="headerlink" title="为什么使用reflect API"></a>为什么使用reflect API</h2><ol><li>提供一种 一致、可靠、简洁易懂的方式去完成js的底层操作</li><li>如果对象本身有个get属性的数据，get c 返回是this.a，this.b，这个this会指向对象本身，而不是代理；在vue中代理其实就是经过响应式处理的对象，this不走代理就无法触发依赖的收集。如果a、b变了，依赖c的组件不会更新。</li></ol><h2 id="监听器原理"><a href="#监听器原理" class="headerlink" title="监听器原理"></a>监听器原理</h2><ul><li>监听器也是对应一个watcher，在watcher里默认把数据读一遍，让数据的dep类收集这个watcher，当数据改变时候触发dep.notify，通知依赖该数据的页面watcher和监听器watcher更新。</li></ul><h2 id="computed原理"><a href="#computed原理" class="headerlink" title="computed原理"></a>computed原理</h2><ol><li>lazy，默认不计算，只有访问这个计算属性时候才会计算。</li><li>dirty，对计算结果缓存，如果依赖的数据没变则不会重新计算，复用之前的计算结果。</li><li>本身也是一个watcher，只有计算属性依赖的数据改变触发dep.notify，会把计算属性watcher的dirty变为true，true则需要重新计算值，不能走缓存。</li></ol><h2 id="nextTick-2"><a href="#nextTick-2" class="headerlink" title="nextTick"></a>nextTick</h2><ul><li>js事件循环的应用</li><li>任务队列缓冲一次同步任务中的数据更改</li><li>优雅降级方式触发watcher对应的函数，Promise.then、MutationObserver、setTimeout</li></ul><h1 id="12-11"><a href="#12-11" class="headerlink" title="12.11"></a>12.11</h1><!--  --><h2 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h2><ul><li>渲染函数执行完后生成虚拟DOM树</li></ul><h2 id="组件渲染过程-1"><a href="#组件渲染过程-1" class="headerlink" title="组件渲染过程"></a>组件渲染过程</h2><ul><li>父组件执行render渲染函数生成虚拟DOM树时候，在生成子组件虚拟DOM时候会从父组件上拿到子组件的构造函数放到子组件虚拟节点属性上；当执行patch方法将虚拟DOM转换为真实DOM时候，子组件虚拟节点会调用构造函数构造函数返回子组件真实DOM渲染。</li></ul><h2 id="props原理-1"><a href="#props原理-1" class="headerlink" title="props原理"></a>props原理</h2><ul><li>父组件在创建子组件虚拟DOM时候，会从子组件配置中拿到申明的props，在虚拟DOM上的属性上一一查看，因为我们props写法与属性类似，从属性列表中删除申明的props，props的变了单独放在子组件虚拟DOM的componentOptions。</li><li>子组件初始化实例时候，通过数据代理把props值放到组件实例上，并经过响应式的处理。</li></ul><h2 id="事件的原理"><a href="#事件的原理" class="headerlink" title="事件的原理"></a>事件的原理</h2><ul><li>父组件在创建子组件虚拟DOM时候，会把属性中的事件单独拿出来放到componentOptions上。</li><li>子组件实例化时候会通过<code>$on</code>把事件绑定到组件实例的__event上，我们调用$emit就是去组件实例上的event查找事件执行。</li></ul><h2 id="插槽的原理"><a href="#插槽的原理" class="headerlink" title="插槽的原理"></a>插槽的原理</h2><h2 id="keep-alive-1"><a href="#keep-alive-1" class="headerlink" title="keep-alive"></a>keep-alive</h2><h2 id="provide-inject-1"><a href="#provide-inject-1" class="headerlink" title="provide inject"></a>provide inject</h2><h2 id="attrs-、-listeners"><a href="#attrs-、-listeners" class="headerlink" title="$attrs 、$listeners"></a>$attrs 、$listeners</h2><h2 id="v-if和v-for的优先级"><a href="#v-if和v-for的优先级" class="headerlink" title="v-if和v-for的优先级"></a>v-if和v-for的优先级</h2><h2 id="v-if-和-v-show区别"><a href="#v-if-和-v-show区别" class="headerlink" title="v-if 和 v-show区别"></a>v-if 和 v-show区别</h2><h2 id="visibility、opacity、display"><a href="#visibility、opacity、display" class="headerlink" title="visibility、opacity、display"></a>visibility、opacity、display</h2><h2 id="v-model原理-1"><a href="#v-model原理-1" class="headerlink" title="v-model原理"></a>v-model原理</h2><ul><li>本质是一个语法糖，在输入框时候 ＝ v-bind：value    +    @input，<br>在checkedbox   ＝  v-bind checked  +   @change</li><li>在组件上的时候是 props+事件绑定的语法糖</li></ul><h2 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h2><ul><li>前端发送http请求携带url，后端根据url进行逻辑处理返回对应的html页面。优点是SEO优化好，适合多页面应用。缺点是服务端压力大。</li></ul><h2 id="前端路由、后端路由"><a href="#前端路由、后端路由" class="headerlink" title="前端路由、后端路由"></a>前端路由、后端路由</h2><h2 id="vuex和pinia区别-10024-2"><a href="#vuex和pinia区别-10024-2" class="headerlink" title="vuex和pinia区别? &#10024;"></a>vuex和pinia区别? &#10024;</h2><ol><li>pinia是用 ts编写,类型支持更友好.</li><li>去除mutations. state,getters,actions.</li><li>vuex树结构,读取数据不方便.都会定义到根模块,覆盖根模块状态.只能创建一个,单例模式. pinia定义多个store,store之间互相引用,扁平化结构.</li></ol><h2 id="actions和mutations区别-2"><a href="#actions和mutations区别-2" class="headerlink" title="actions和mutations区别"></a>actions和mutations区别</h2><ol><li>作用:mutation修改状态,action处理业务代码和异步请求,提交到commit.</li><li>同异步:mutation同步执行,action是异步执行</li></ol><h1 id="12-12"><a href="#12-12" class="headerlink" title="12.12"></a>12.12</h1><!-- 一切都说不准,只能说坚持下来 --><h2 id="vuex和pinia区别"><a href="#vuex和pinia区别" class="headerlink" title="vuex和pinia区别"></a>vuex和pinia区别</h2><ol><li>单例模式，树形结构，嵌套；扁平化，多个实例。</li><li>ts</li><li>mutations</li><li>选项式api；组合式api</li></ol><h2 id="mutations和actions区别"><a href="#mutations和actions区别" class="headerlink" title="mutations和actions区别"></a>mutations和actions区别</h2><ol><li>业务逻辑、异步请求数据；直接修改数据</li><li>异步；同步</li></ol><h2 id="Array-prototype-splice-方法-1"><a href="#Array-prototype-splice-方法-1" class="headerlink" title="Array.prototype.splice()方法"></a>Array.prototype.splice()方法</h2><ul><li>第一个参数：开始操作数组的起始位置</li><li>第二个参数：删除的元素个数，不传的话后面所有元素都会删除。</li><li>第三个参数：插入&#x2F;替换的元素。</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>.splice(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) //[‘<span class="hljs-number">1</span>’,‘<span class="hljs-number">4</span>’]<br><span class="hljs-attribute">arr</span>.splice(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,&#x27;x&#x27;,<span class="hljs-string">&quot;x&quot;</span>) // 两个元素被替换成一个x/两个x。<br><span class="hljs-attribute">arr</span>.splice(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;x&quot;</span>) // 插入一个x<br></code></pre></td></tr></table></figure><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><ul><li>一定要异步执行，如果是同步的话，任务还没推进来就开始执行了。</li><li>如何等五秒后执行下一个任务?我们用setTimeout,在他的外层再用promise包装,五秒后才调用promise的resolve方法.</li></ul><h2 id="MVC、MVP、MVVM"><a href="#MVC、MVP、MVVM" class="headerlink" title="MVC、MVP、MVVM"></a>MVC、MVP、MVVM</h2><ul><li>MVC：</li></ul><h1 id="12-13"><a href="#12-13" class="headerlink" title="12.13"></a>12.13</h1><!-- 摆烂了一天，查看虾皮内推进度是offer已审批，有希望吗 --><h1 id="12-14"><a href="#12-14" class="headerlink" title="12.14"></a>12.14</h1><!-- 摆烂一天 --><h2 id="复习源码"><a href="#复习源码" class="headerlink" title="复习源码"></a>复习源码</h2><h2 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h2><ul><li>props、emits</li><li>provide、inject</li><li>事件总线</li><li>vuex</li><li>ref</li><li>localStorage</li><li>attrs</li></ul><h2 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h2><ol><li>beforeCreated：组件实例初始化时候立即调用，无法访问响应式数据、计算属性等等</li><li>created：初始化完成，可以访问响应式数据和计算属性</li><li>beforeMounted：render函数被调用，但页面还没挂载。</li><li>mounted：页面挂载。</li><li>beforeUpdated：数据已经发生变化，但页面视图未更新</li><li>updated：视图更新。</li><li>beforeUnmount：卸载前，还能使用组件所有功能。</li><li>unmounted：卸载完毕，清除定时器、DOM监听器等等。</li></ol><h1 id="12-15"><a href="#12-15" class="headerlink" title="12.15"></a>12.15</h1><!--你不能在已经赢的时候才自信，那不是自信，是对结果的复读。 --><h2 id="keep-alive有哪些生命周期"><a href="#keep-alive有哪些生命周期" class="headerlink" title="keep-alive有哪些生命周期"></a>keep-alive有哪些生命周期</h2><ul><li>activated、deactivated</li></ul><h2 id="vue父子组件执行顺序"><a href="#vue父子组件执行顺序" class="headerlink" title="vue父子组件执行顺序"></a>vue父子组件执行顺序</h2><ul><li>父先开始，子先结束</li></ul><h2 id="created和mounted哪里发请求"><a href="#created和mounted哪里发请求" class="headerlink" title="created和mounted哪里发请求"></a>created和mounted哪里发请求</h2><ul><li>created，渲染函数未执行，DOM结构未挂载，但响应式数据已经初始化。</li><li>mounted：适合要操作DOM的请求，会导致页面重新渲染。</li></ul><h2 id="MVC、MVP、MVVM-1"><a href="#MVC、MVP、MVVM-1" class="headerlink" title="MVC、MVP、MVVM"></a>MVC、MVP、MVVM</h2><ul><li>MVC：观察者模式、策略模式</li><li>MVP：进一步解耦，view暴露接口给presenter</li><li>MVVM：操作自动化，降低代码复杂度</li></ul><h2 id="事件模型-3"><a href="#事件模型-3" class="headerlink" title="事件模型"></a>事件模型</h2><ol><li>DOM0：没有事件流，只有本身触发</li><li>IE事件模型：事件处理 + 事件冒泡</li><li>DOM2：事件捕获 + 事件处理 + 事件冒泡</li></ol><h2 id="vue默认事件机制"><a href="#vue默认事件机制" class="headerlink" title="vue默认事件机制"></a>vue默认事件机制</h2><ul><li>事件冒泡模型</li></ul><h2 id="常见的事件修饰符"><a href="#常见的事件修饰符" class="headerlink" title="常见的事件修饰符"></a>常见的事件修饰符</h2><ol><li>stop，阻止事件冒泡</li><li>prevent，阻止默认行为</li><li>capture: 让事件在捕获时候触发</li><li>once：触发一次</li><li>self：只触发本身</li></ol><h2 id="data为什么是函数而不是对象"><a href="#data为什么是函数而不是对象" class="headerlink" title="data为什么是函数而不是对象"></a>data为什么是函数而不是对象</h2><ul><li>创建组件的子构造函数本身会保留配置项，相同组件会调用同一个构造函数，会访问相同的构造函数上的配置项，到达复用的效果。</li><li>对象是引用值，一个实例修改其他实例也会更改。</li></ul><h2 id="TCP握手不能两次"><a href="#TCP握手不能两次" class="headerlink" title="TCP握手不能两次"></a>TCP握手不能两次</h2><ol><li><strong>避免历史连接</strong>：如果上一次SYN请求滞留在网络中；这时候开启新的TCP握手，但旧SYN先到达，服务器会建立连接。两次握手没有中间状态来拒绝服务端的连接。服务端返回第二次握手后会直接发送数据，导致资源的浪费。</li><li><strong>同步双方序列号</strong>：服务端发送序列号过去后需要客户端ACK应答。</li></ol><h2 id="单页面和多页面-2"><a href="#单页面和多页面-2" class="headerlink" title="单页面和多页面"></a>单页面和多页面</h2><ol><li>资源加载：单页面一次性加载资源,多页面多次加载</li><li>路由:单页面应用:history,hash.多页面应用通过路径跳转.</li><li>数据传递:单页面vuex.多页面cookie,localStorage,sessionStorage,接口保存.</li><li>页面跳转：单页面局部更新,切换速度快.多页面全局更新,切换速度慢.</li></ol><h2 id="对SPA单页面应用的理解-1"><a href="#对SPA单页面应用的理解-1" class="headerlink" title="对SPA单页面应用的理解?"></a>对SPA单页面应用的理解?</h2><ul><li>优点:</li></ul><ol><li>一次性获取所有js,css,html文件,减少服务端压力.</li><li>内容改动无需重新加载整个页面,局部更新页面.</li><li>前后端分离,前端负责图层,后端负责数据层.</li></ol><ul><li>缺点:</li></ul><ol><li>首屏加载速度慢</li><li>客户端占用更多内存和cpu资源.</li><li>前端手动实现路由,管理浏览器前进后退功能.</li></ol><h2 id="vue初始化页面闪动问题-1"><a href="#vue初始化页面闪动问题-1" class="headerlink" title="vue初始化页面闪动问题"></a>vue初始化页面闪动问题</h2><ul><li>数据异步获取,页面先渲染完出现闪动情况.</li><li>解决方法:[v-cloak]:{display:none}</li></ul><h2 id="react和vue区别-1"><a href="#react和vue区别-1" class="headerlink" title="react和vue区别"></a>react和vue区别</h2><ol><li>核心思想：vue是双向数据绑定；53是模块化、单向数据流：数据在父组件中，传递给子组件渲染。</li><li>模板编写：vue模板语法，react是jsx写法：把html、css写入到js中。</li><li>逻辑复用：一个组件对应一个函数，高阶组件接受一个组件添加功能逻辑，再返回一个组件；vue mixin、组合式API。</li></ol><h2 id="vue优点"><a href="#vue优点" class="headerlink" title="vue优点"></a>vue优点</h2><ol><li><em><strong>声明式框架</strong></em>：响应式原理</li><li><em><strong>虚拟DOM</strong></em>：第一：diff算法。第二：支持跨平台，服务端渲染、浏览器渲染，将虚拟DOM转换为真实HTML元素。</li><li><em><strong>区分编译时和运行时</strong></em>：<br>编译时：将<strong>模板</strong>变成js语法渲染函数生成的<strong>虚拟DOM</strong>；<br>运行时：上线时只走运行时。</li><li><em><strong>拥抱Ts</strong></em></li></ol><h2 id="assets和static区别-1"><a href="#assets和static区别-1" class="headerlink" title="assets和static区别"></a>assets和static区别</h2><ul><li>assets资源会打包压缩后放到static里面上传到服务器</li><li>static资源会避免打包压缩流程直接上传到服务器，提高效率，但体积更大。</li></ul><h2 id="vue性能优化"><a href="#vue性能优化" class="headerlink" title="vue性能优化"></a>vue性能优化</h2><ol><li>防抖节流</li><li>虚拟列表</li><li>webworker</li><li>公共组件抽离</li><li>强制缓存、协商缓存</li><li>v-if、v-show</li><li>异步组件</li><li>打包体积优化</li><li>构建速度优化</li></ol><h2 id="vue上"><a href="#vue上" class="headerlink" title="vue上"></a>vue上</h2><h1 id="12-16"><a href="#12-16" class="headerlink" title="12.16"></a>12.16</h1><h2 id="vue上-1"><a href="#vue上-1" class="headerlink" title="vue上"></a>vue上</h2><h2 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h2><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><ol><li>vue component：与用户交互触发事件，dispatch触发action</li><li>action里处理业务逻辑和异步请求，会经过promise封装。</li><li>action处理完后dispatch交给mutations里去修改数据。</li><li>state变化后通知vue组件更新</li><li>getters计算属性，响应式原理和getters原理都是借助了vue组件去创建响应式数据和计算属性。</li></ol><h2 id="actions和mutations区别-3"><a href="#actions和mutations区别-3" class="headerlink" title="actions和mutations区别"></a>actions和mutations区别</h2><ol><li>actions处理业务逻辑、请求数据；mutations中直接修改数据</li><li>异步；同步</li><li>一般是组件触发actions，再去触发mutations。</li></ol><h2 id="vuex和localStorage区别-1"><a href="#vuex和localStorage区别-1" class="headerlink" title="vuex和localStorage区别"></a>vuex和localStorage区别</h2><ol><li>vuex存在内存中，localStorage存在本地磁盘文件中</li><li>刷新vuex清空，localStorage不会</li><li>vuex是响应式数据，localStorage</li></ol><h2 id="代码输出题"><a href="#代码输出题" class="headerlink" title="代码输出题"></a>代码输出题</h2><ol><li>没有var、let、const声明的变量就是全局，会在window上。</li></ol><h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h2><ul><li>不能有比我小1的数，找比我大1的数</li></ul><h2 id="移动0"><a href="#移动0" class="headerlink" title="移动0"></a>移动0</h2><h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><h2 id="重复最多的数"><a href="#重复最多的数" class="headerlink" title="重复最多的数"></a>重复最多的数</h2><h2 id="找数组中的值find、findIndex、indexOf"><a href="#找数组中的值find、findIndex、indexOf" class="headerlink" title="找数组中的值find、findIndex、indexOf"></a>找数组中的值find、findIndex、indexOf</h2><ul><li>前两个是要函数，后一个是元素</li></ul><ol><li>find：arr.find((value)&#x3D;&gt; value &gt; 10) 返回第一个大于10的数</li><li>findIndex，同find用法，但返回的是下标</li><li><strong>indexOf</strong>：arr.indexOf(‘cc’)，数组中第一个出现给定元素的下标。</li></ol><h2 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h2><ul><li>传参parseInt(转换的数,多少进制)；</li></ul><h2 id="RGB转换"><a href="#RGB转换" class="headerlink" title="RGB转换"></a>RGB转换</h2><h2 id="千分位隔开"><a href="#千分位隔开" class="headerlink" title="千分位隔开"></a>千分位隔开</h2><h2 id="微前端网课一半"><a href="#微前端网课一半" class="headerlink" title="微前端网课一半"></a>微前端网课一半</h2><h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><ul><li>当拿当前这家和不拿当前这家的钱是一样的时候，不拿当前这家，这样可以拿更少的文章。</li></ul><h1 id="12-17"><a href="#12-17" class="headerlink" title="12.17"></a>12.17</h1><h2 id="接雨水动态规划"><a href="#接雨水动态规划" class="headerlink" title="接雨水动态规划"></a>接雨水动态规划</h2><ul><li>核心思路：当前格子能接的雨水是 ：两边最大值中的小值减去当前格子的高度。</li></ul><h2 id="接雨水-双指针"><a href="#接雨水-双指针" class="headerlink" title="接雨水 双指针"></a>接雨水 双指针</h2><ul><li>不需要找到两边的最大值，如果我AA边的最大值比BB边其中一个值小，那我就可以计算A边一个格子的能接的雨水量。</li></ul><h2 id="无重复字符的最长子串-1"><a href="#无重复字符的最长子串-1" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><ul><li>！考虑right在末尾超出边界的情况！</li></ul><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><ul><li>都是content、padding、border、margin</li></ul><ol><li>IE盒子模型：width、height包括content、padding、border</li></ol><h2 id="px、em、rem区别"><a href="#px、em、rem区别" class="headerlink" title="px、em、rem区别"></a>px、em、rem区别</h2><ol><li>px是固定像素</li><li>em、rem是相对长度，em是相对父元素的字体大小。rem是相对根元素html的大小。</li></ol><h2 id="animation和transition"><a href="#animation和transition" class="headerlink" title="animation和transition"></a>animation和transition</h2><ol><li>transition：强调过度，他的实现需要一个事件触发（鼠标移上去，点击），只有一个开始帧和结束帧。 属性有：transition-property、transition-duration、transition-function、transition-delay</li><li>animation：实现不需要触发，设定时间后自动触发，且可以循环动画，通过@keyframe设置多个关键帧。</li></ol><h2 id="vue2、vue3区别"><a href="#vue2、vue3区别" class="headerlink" title="vue2、vue3区别"></a>vue2、vue3区别</h2><ul><li>响应式原理、diff算法、</li></ul><ol><li>响应式核心思想没变，数据劫持 + 发布订阅，Object.definProperty&#x3D;》proxy，数组可以监听到。对象新增删除也能监听。</li><li>diff算法</li></ol><!-- 3. 模板解析器，vue2是正则匹配，vue3基于状态机。 --><ol start="3"><li>选项式API &#x3D;》组合式API</li><li>v-if、v-for优先级变化</li><li>对ts支持更友好</li><li>生命周期</li></ol><h2 id="实现继承的方法"><a href="#实现继承的方法" class="headerlink" title="实现继承的方法"></a>实现继承的方法</h2><h2 id="get、post区别"><a href="#get、post区别" class="headerlink" title="get、post区别"></a>get、post区别</h2><ol><li>本质：获取资源、增删改资源</li><li>缓存：get可以强制缓存、协商缓存</li><li>幂等：get是幂等的、post不是</li><li>请求体：get请求有长度限制，编码只能是url编码；post请求可以放在请求体，编码格式多种。</li></ol><h2 id="call、apply、bind区别"><a href="#call、apply、bind区别" class="headerlink" title="call、apply、bind区别"></a>call、apply、bind区别</h2><h1 id="12-18"><a href="#12-18" class="headerlink" title="12.18"></a>12.18</h1><h2 id="returnType、parameters"><a href="#returnType、parameters" class="headerlink" title="returnType、parameters"></a>returnType、parameters</h2><h2 id="Required、Patical、Readonly"><a href="#Required、Patical、Readonly" class="headerlink" title="Required、Patical、Readonly"></a>Required、Patical、Readonly</h2><h2 id="Pick、Omit"><a href="#Pick、Omit" class="headerlink" title="Pick、Omit"></a>Pick、Omit</h2><h2 id="exclude、extract"><a href="#exclude、extract" class="headerlink" title="exclude、extract"></a>exclude、extract</h2><h2 id="XSS-、CSRF攻击"><a href="#XSS-、CSRF攻击" class="headerlink" title="XSS 、CSRF攻击"></a>XSS 、CSRF攻击</h2><ul><li>XSS浏览器无法识别恶意js代码，都会执行。<br>破坏DOM、读取cookie、localSessionStorage<br>解决方案：http-only、csp白名单</li><li>CSRF攻击，跨站请求伪造，利用cookie同源请求会发送的性质，cookie里存储了session信息。<br>解决方案：samesite，token，双认证，origin、referer。</li></ul><h2 id="XSS攻击三种类型"><a href="#XSS攻击三种类型" class="headerlink" title="XSS攻击三种类型"></a>XSS攻击三种类型</h2><ol><li>存储型：恶意代码在服务端，论坛评论了恶意代码，其他用户访问论坛评论。</li><li>反射型：访问恶意url，请求发送到服务端，服务端响应带有恶意代码的页面。</li><li>DOM型：是前端从url拿取恶意代码执行。innerHTML、eval函数。</li></ol><h2 id="set-cookie"><a href="#set-cookie" class="headerlink" title="set-cookie"></a>set-cookie</h2><ul><li>服务端响应头返回的字段，可以设置cookie的内容</li></ul><h2 id="中间人攻击-1"><a href="#中间人攻击-1" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><ul><li>tls握手中，需要三个随机数完成会话密钥的协商，第一次握手拿到第一个随机数。第二次服务端返回数字证书和第二个随机数，中间人服务器拦截服务端数字证书，将自己的数字证书发送给客户端，客户端如果信任了就会出问题，用中间人的公钥加密第三个随机数，中间人私钥解密拿到三个随机数生成会话密钥。同时用服务端的公钥加密第三个随机数给服务端。</li></ul><h2 id="强制缓存、协商缓存"><a href="#强制缓存、协商缓存" class="headerlink" title="强制缓存、协商缓存"></a>强制缓存、协商缓存</h2><ul><li>cache-control&#x2F;expires</li><li>last-modifed&#x2F;if-modifed-since；etag&#x2F;if-none-match</li></ul><!-- 晚上休息前搞完渲染原理、本地存储、同源策略 晚上项目 --><h2 id="浏览器渲染原理-2"><a href="#浏览器渲染原理-2" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><ul><li><a href="https://segmentfault.com/a/1190000042909353">https://segmentfault.com/a/1190000042909353</a></li></ul><ol><li>解析html文档,生成DOM树,由html元素和属性节点组成.</li><li>解析css,生成css树.</li><li>根据DOM树和CSS树构建渲染树</li><li>布局(回流):渲染树进行布局计算每个渲染节点的位置和大小.</li><li>绘制(重绘):将渲染树的节点绘制到页面上.</li><li>复合: 浏览器的绘制是绘制到多层,每一层单独渲染,最后合成到一起形成页面.</li><li>重绘:重绘不会带来重新布局,一般是修改背景颜色,边框阴影等属性.</li><li>回流:消耗性能,改变元素位置,DOM结构发生变化.</li></ol><h2 id="如何优化浏览器渲染"><a href="#如何优化浏览器渲染" class="headerlink" title="如何优化浏览器渲染"></a>如何优化浏览器渲染</h2><ol><li>js：async、defer、写在后面。js线程和渲染线程是冲突的。</li><li>css：link、@import、style。</li><li>减少回流重绘</li></ol><h2 id="减少回流、重绘"><a href="#减少回流、重绘" class="headerlink" title="减少回流、重绘"></a>减少回流、重绘</h2><ol><li>浏览器任务队列机制。</li><li>脱离文档流，减少对其他元素的影响。</li><li>操作低层次dom。</li><li>利用GPU加速渲染，单独抽离出合成层。</li><li>documentFragment文档碎片，不在DOM中，操作其不会触发回流重绘。</li></ol><h2 id="浏览器的本地存储-2"><a href="#浏览器的本地存储-2" class="headerlink" title="浏览器的本地存储"></a>浏览器的本地存储</h2><h3 id="cookie-2"><a href="#cookie-2" class="headerlink" title="cookie"></a>cookie</h3><ol><li>大小限制4kb,不能跨域.</li><li>主要和seesion配合,存储sessionid,发送请求时候可以携带cookie,服务器识别sessionid来识别身份.</li></ol><h3 id="localStorage-2"><a href="#localStorage-2" class="headerlink" title="localStorage"></a>localStorage</h3><ol><li>大小5MB,存储在本地,请求不会携带.</li><li>除非主动删除,否则不会消失.</li><li>同源多个标签可以共享数据.</li></ol><h3 id="sessionStorage-2"><a href="#sessionStorage-2" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><ol><li>同.</li><li>关闭窗口后会消失</li><li>同源多个标签不可以共享数据.</li></ol><h2 id="cookie字段-2"><a href="#cookie字段-2" class="headerlink" title="cookie字段"></a>cookie字段</h2><ol><li>domain:可以访问该cookie的域名</li><li>path:域名下的哪些路径可以访问该cookie</li><li>Expires:cookie过期时间,注意这个是cookie的expires!和缓存的不一样,缓存的是在请求头中!</li><li>name,value,size.</li></ol><ul><li>服务端在响应头可以用set-cookie来配置cookie信息.http-only限制cookie不能被js脚本读取.也有domain,path,expires.<br>(不要把缓存的六个字段和cookie的搞混了,缓存的是在请求头和响应头中)</li></ul><h2 id="indexDB-2"><a href="#indexDB-2" class="headerlink" title="indexDB"></a>indexDB</h2><ol><li>键值对存储,异步,支持事务(不会出现只修改部分数据情况),存储空间大(250MB+)</li></ol><h2 id="同源策略-1"><a href="#同源策略-1" class="headerlink" title="同源策略"></a>同源策略</h2><ol><li>安全机制,隔离恶意文件.要求协议域名端口号都相同.</li><li>限制cookie,localstorage,indexDB&#x2F;DOM&#x2F;跨域请求.</li></ol><h2 id="如何解决跨域"><a href="#如何解决跨域" class="headerlink" title="如何解决跨域"></a>如何解决跨域</h2><ol><li>CORS：简单请求、非简单请求。</li><li>JSONP：利用script标签没有跨域限制。</li><li>postmessage：多窗口之间通信。</li><li>nginx</li><li>代理服务器</li></ol><h2 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h2><ol><li>第一个、最后一个交换，第二个和倒数第二个交换……时间复杂度On，空间O1</li><li>新数组，旧数组从后往前遍历，拿一个放一个，拿一个放一个。时间复杂度On，空间On。</li></ol><h1 id="12-19"><a href="#12-19" class="headerlink" title="12.19"></a>12.19</h1><h2 id="TCP、UDP区别"><a href="#TCP、UDP区别" class="headerlink" title="TCP、UDP区别"></a>TCP、UDP区别</h2><ol><li>连接</li><li>服务对象</li><li>可靠、不可靠</li><li>拥塞控制、流量控制</li><li>传输：字节流：tcp的数据包可以按字节大小拆分成多个数据包，udp每次一个包一个包完整的发送。</li></ol><h2 id="浏览器渲染原理-3"><a href="#浏览器渲染原理-3" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><h2 id="浏览器渲染优化-3"><a href="#浏览器渲染优化-3" class="headerlink" title="浏览器渲染优化"></a>浏览器渲染优化</h2><h2 id="减少回流重绘"><a href="#减少回流重绘" class="headerlink" title="减少回流重绘"></a>减少回流重绘</h2><h2 id="cookie、local、sessionStorage区别"><a href="#cookie、local、sessionStorage区别" class="headerlink" title="cookie、local、sessionStorage区别"></a>cookie、local、sessionStorage区别</h2><h2 id="cookie字段-3"><a href="#cookie字段-3" class="headerlink" title="cookie字段"></a>cookie字段</h2><h2 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h2><h2 id="跨域-1"><a href="#跨域-1" class="headerlink" title="跨域"></a>跨域</h2><ol><li>CORS：简单请求、非简单请求。预检请求，options缓存。</li><li>JSONP：传入回调函数名为参数，返回的脚本代码调用回调函数传入参数。</li><li>代理服务器</li><li>postmessage，多窗口之间跨域。</li></ol><h2 id="事件模型-4"><a href="#事件模型-4" class="headerlink" title="事件模型"></a>事件模型</h2><ol><li>DOM0 事件触发</li><li>IE 事件触发，事件冒泡</li><li>DOM2 事件捕获 事件触发 事件冒泡</li></ol><h2 id="事件委托-2"><a href="#事件委托-2" class="headerlink" title="事件委托"></a>事件委托</h2><ol><li>利用事件冒泡的机制，子元素的监听事件绑定到父元素上，父元素集中处理子元素的事件</li><li>减少内存消耗、动态事件绑定</li><li>缺点：focus事件没有冒泡机制、DOM层数深不建议消耗性能。</li></ol><h1 id="12-20"><a href="#12-20" class="headerlink" title="12.20"></a>12.20</h1><!-- go big or go home --><h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><ul><li>两者都是CS架构</li></ul><ol><li>正向代理：是客户端这边设置的代理，隐藏客户端身份。</li><li>反向代理：是服务端这边设置，将请求分散到多个服务器，减少服务端压力，隐藏服务端身份。</li></ol><h2 id="事件循环-2"><a href="#事件循环-2" class="headerlink" title="事件循环"></a>事件循环</h2><h2 id="内存泄漏-1"><a href="#内存泄漏-1" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><ol><li>未关闭的定时器setInterval</li><li>未使用的全局变量</li><li>不恰当的闭包使用</li><li>DOM元素的引用</li></ol><h2 id="浏览器进程-2"><a href="#浏览器进程-2" class="headerlink" title="浏览器进程"></a>浏览器进程</h2><ol><li>主进程</li><li>插件进程</li><li>GPU进程</li><li>渲染进程（内核）：渲染线程、js线程</li></ol><h2 id="浏览器组成部分"><a href="#浏览器组成部分" class="headerlink" title="浏览器组成部分"></a>浏览器组成部分</h2><!-- 微前端网课 --><h2 id="externals优化"><a href="#externals优化" class="headerlink" title="externals优化"></a>externals优化</h2><ul><li>部分资源不会打包到输出目录中，而是作为外部依赖通过script标签引入。</li><li>减少打包体积也能提高构建速度。</li></ul><h2 id="string的replace方法-10024-1"><a href="#string的replace方法-10024-1" class="headerlink" title="string的replace方法 &#10024;"></a>string的replace方法 &#10024;</h2><ul><li><a href="https://blog.csdn.net/qq_46658751/article/details/123390095">https://blog.csdn.net/qq_46658751/article/details/123390095</a></li></ul><ol><li>replace(字符串，字符串)，只能替换一次</li><li>replace（正则，字符串）多次替换</li><li>replace（正则，函数）核心用法，函数第一个参数是匹配到的子串，第二个是起始索引，第三个是字符串本身。如果有捕获器的值则插入在第二个参数，起始索引变第三个参数，字符串本身变第四个参数。</li></ol><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">templat.replace(<span class="hljs-regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/g</span>,<span class="hljs-function"><span class="hljs-params">(match,key)</span>=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> data[key];<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="字符串没有splice"><a href="#字符串没有splice" class="headerlink" title="字符串没有splice"></a>字符串没有splice</h2><ul><li>splice是数组方法</li></ul><h2 id="比较含退格的字符串"><a href="#比较含退格的字符串" class="headerlink" title="比较含退格的字符串"></a>比较含退格的字符串</h2><ul><li><a href="https://leetcode.cn/problems/backspace-string-compare/description/">https://leetcode.cn/problems/backspace-string-compare/description/</a></li></ul><h1 id="12-21"><a href="#12-21" class="headerlink" title="12.21"></a>12.21</h1><h2 id="模块加载对window影响"><a href="#模块加载对window影响" class="headerlink" title="模块加载对window影响"></a>模块加载对window影响</h2><ul><li>不管是react、还是vue加载都会在window对象上创建属性。比如window.React、window.ReactDom</li></ul><h2 id="systemJS"><a href="#systemJS" class="headerlink" title="systemJS"></a>systemJS</h2><ul><li>是一个模块规范，类似commonjs、esmodule</li></ul><ol><li>systemjs的模块规范，主要分为三个部分。<br>第一个是script标签里写上外部依赖的映射表（这些外部依赖不会打包，而是通过cdn引入），<br>第二个是system.import(‘打包后的项目index.js’)，<br>第三个是打包后项目文件里system.register([‘react’,’react-dom’],function(){<br> return {<br>  setters:[<br> function，function &#x2F;&#x2F; 这里的function是把window上的依赖给到webpack<br>  ],<br>  execute:{</li></ol><p>  }<br> }<br>}).<br>2. 封装一个loader方法：创建script标签，设置script标签的src属性，添加到页面中。 这个方法可以加载对应文件。<br>4. register方法就是获取传入的参数。<br>5. import方法：获取页面中script标签中的映射，然后promise.then拼接import要加载的页面路径，然后promise.then调用loader方法去加载打包的项目index.js，在register中获取传入的参数。然后promise.then去加载依赖的外部组件，外部组件加载完后会调用register的第二个参数中的setters中的方法，将外部依赖放到webpack上。这样webpack在加载模块时候可以使用。<br>3. getter里面是传入window上新增的属性 &#x3D; 依赖，将这个依赖放到wbpack上，wbpack模块解析时候会使用到。</p><!-- 他们以为击败我的会是终结，而我必将归来将之改写 --><h1 id="12-23"><a href="#12-23" class="headerlink" title="12.23"></a>12.23</h1><h2 id="vue生命周期unmounted时候事件监听器是如何移除的？"><a href="#vue生命周期unmounted时候事件监听器是如何移除的？" class="headerlink" title="vue生命周期unmounted时候事件监听器是如何移除的？"></a>vue生命周期unmounted时候事件监听器是如何移除的？</h2><ul><li>两种情况，$on绑定和原生的addListeners绑定；前者原理是在组件实例对象的event属性数组上添加元素，会随组件对象卸载自动卸载；如果是后者则需要用户自己删除。</li></ul><h2 id="微前端网课"><a href="#微前端网课" class="headerlink" title="微前端网课"></a>微前端网课</h2><h1 id="12-24"><a href="#12-24" class="headerlink" title="12.24"></a>12.24</h1><h2 id="手写reduce"><a href="#手写reduce" class="headerlink" title="手写reduce"></a>手写reduce</h2><h2 id="如何提高webpack构建速度-1"><a href="#如何提高webpack构建速度-1" class="headerlink" title="如何提高webpack构建速度"></a>如何提高webpack构建速度</h2><ol><li>cache-loader</li><li>thread-loader：babel-loader支持多线程执行。</li><li>dllplugin</li><li>exclude loader的作用范围不包括node_modules</li><li>代码分割，动态加载，加载资源速度更快。</li></ol><h2 id="如何减小打包体积"><a href="#如何减小打包体积" class="headerlink" title="如何减小打包体积"></a>如何减小打包体积</h2><ol><li>tree-shaking</li><li>js代码压缩：空格、注释、log、变量名</li><li>css压缩：空格、注释</li><li>图片压缩</li><li>组件库按需加载</li><li>下载到开发依赖</li><li>externals不把某些依赖打包到项目中，而是通过cdn引入。</li></ol><h2 id="externals优化-1"><a href="#externals优化-1" class="headerlink" title="externals优化"></a>externals优化</h2><ul><li>部分资源不会打包到输出目录中，而是作为外部依赖通过script标签引入。</li><li>减少打包体积也能提高构建速度。</li></ul><h2 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h2><ol><li>时间空间都为On</li><li>时间为On2，空间O1</li><li>时间On，空间O1</li></ol><h2 id="微前端知识"><a href="#微前端知识" class="headerlink" title="微前端知识"></a>微前端知识</h2><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li>虚拟列表</li><li>webworker</li><li>代码分割，路由动态加载</li></ol><h2 id="虚拟DOM相比真实DOM的优点？"><a href="#虚拟DOM相比真实DOM的优点？" class="headerlink" title="虚拟DOM相比真实DOM的优点？"></a>虚拟DOM相比真实DOM的优点？</h2><ol><li><strong>异步批量更新</strong>（watch队列，nextTick的缓冲队列），减少频繁的DOM操作。</li><li><strong>最小化DOM操作</strong>：通过diff算法对比两次虚拟DOM树的区别，尽可能复用现有的真实DOM，减少DOM操作。</li><li><strong>跨平台渲染</strong>：浏览器渲染，服务端渲染。</li></ol><h2 id="虚拟DOM一定比真实DOM更快吗？"><a href="#虚拟DOM一定比真实DOM更快吗？" class="headerlink" title="虚拟DOM一定比真实DOM更快吗？"></a>虚拟DOM一定比真实DOM更快吗？</h2><ol><li>不一定。解析模板、ast语法树、渲染函数、虚拟DOM创建、diff对比、真实DOM创建都是要消耗性能的。如果是简单的页面，直接操作真实DOM效率更高。</li><li>也增加了内存消耗。</li></ol><h1 id="12-25"><a href="#12-25" class="headerlink" title="12.25"></a>12.25</h1><h2 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h2><h2 id="最长重复子数组-1"><a href="#最长重复子数组-1" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2><ul><li>二维dp数组去表示状态，</li></ul><h2 id="diffjs"><a href="#diffjs" class="headerlink" title="diffjs"></a>diffjs</h2><ul><li>采用最长公共子序列方法</li></ul><h2 id="最长公共子序列-1"><a href="#最长公共子序列-1" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h2 id="为什么采用diffjs而不是其他比如json-diff"><a href="#为什么采用diffjs而不是其他比如json-diff" class="headerlink" title="为什么采用diffjs而不是其他比如json-diff"></a>为什么采用diffjs而不是其他比如json-diff</h2><ul><li>diffjs使用方便，只有三种状态added，removed，value表示没修改的。</li><li>json-diff复杂，数组比完后返回一个数组，数组里面还套了数组，很难获取数据。</li><li>其次我们需要个性化的展示，符合用户需求，数据转换为字符串，字符串对比更适合使用diffjs。</li></ul><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><h2 id="虚拟列表-1"><a href="#虚拟列表-1" class="headerlink" title="虚拟列表"></a>虚拟列表</h2><h2 id="git-merge-git-rebase区别"><a href="#git-merge-git-rebase区别" class="headerlink" title="git merge&#x2F;git rebase区别"></a>git merge&#x2F;git rebase区别</h2><h2 id="盒马电话二面"><a href="#盒马电话二面" class="headerlink" title="盒马电话二面"></a>盒马电话二面</h2><h1 id="12-26"><a href="#12-26" class="headerlink" title="12.26"></a>12.26</h1><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><ul><li><a href="https://blog.csdn.net/leman314/article/details/111936863">https://blog.csdn.net/leman314/article/details/111936863</a></li></ul><ol><li>布局视口：文档对象的逻辑尺寸，pc端和浏览器窗口大小差不多。移动端远大于手机尺寸。</li><li>理想视口：是布局视口的理想尺寸，和设备宽度相同。</li><li>视觉视口：用户在网页看到的区域。理想视口尺寸&#x2F;缩放比例。</li></ol><h2 id="只设置initial-scale，不设置width可以吗？"><a href="#只设置initial-scale，不设置width可以吗？" class="headerlink" title="只设置initial-scale，不设置width可以吗？"></a>只设置initial-scale，不设置width可以吗？</h2><ol><li>问题：initial-scale是理想&#x2F;视觉，如果不设置width，那么布局也等于视觉（这是一条定律），布局＝视觉＝理想不就可以了吗？</li><li>IE浏览器使用横屏时候，布局会等于竖屏的理想视口。</li></ol><h2 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h2><ol><li>使用视口配置，width定义布局视口大小等于理想视口，initial-scale设置理想视口和视觉视口比例。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span> = <span class="hljs-string">&quot;width = device-width ,initial-scale = 1.0&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>媒体查询</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span> :<span class="hljs-number">1024px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>:<span class="hljs-number">768px</span>)&#123;<br>  <span class="hljs-selector-tag">html</span> : &#123;<br>    <span class="hljs-attribute">font-size</span>:<span class="hljs-number">18px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>百分比布局</li></ol><ul><li>使用%、em、rem相对单位，不要用px绝对单位。</li></ul><ol start="4"><li>弹性盒子flex</li></ol><ul><li>flex：主轴、侧轴、排列方式（align-items、justify-content）</li></ul><ol start="5"><li><p>组件库vant</p></li><li><p>设计稿匹配</p></li></ol><ul><li>主流设备的375px（iphone6&#x2F;7&#x2F;8）</li></ul><h1 id="12-27"><a href="#12-27" class="headerlink" title="12.27"></a>12.27</h1><h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><h2 id="查询数组中元素出现的位置"><a href="#查询数组中元素出现的位置" class="headerlink" title="查询数组中元素出现的位置"></a>查询数组中元素出现的位置</h2><h2 id="手写single-spa-1-3"><a href="#手写single-spa-1-3" class="headerlink" title="手写single-spa 1&#x2F;3"></a>手写single-spa 1&#x2F;3</h2><h1 id="12-30"><a href="#12-30" class="headerlink" title="12.30"></a>12.30</h1><h2 id="旋转数组的最小值-I-II"><a href="#旋转数组的最小值-I-II" class="headerlink" title="旋转数组的最小值 I &#x2F; II"></a>旋转数组的最小值 I &#x2F; II</h2><ul><li>二分法</li></ul><h2 id="单词搜索-1"><a href="#单词搜索-1" class="headerlink" title="单词搜索"></a>单词搜索</h2><ul><li>回溯</li></ul><h2 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h2><h1 id="12-31"><a href="#12-31" class="headerlink" title="12.31"></a>12.31</h1><h2 id="parseInt-值，进制"><a href="#parseInt-值，进制" class="headerlink" title="parseInt(值，进制);"></a>parseInt(值，进制);</h2><ul><li>是把 值 按 进制解析后，返回十进制结果。</li></ul><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h3 id="JavaScript-的数值表示"><a href="#JavaScript-的数值表示" class="headerlink" title="JavaScript 的数值表示"></a>JavaScript 的数值表示</h3><p>JavaScript 使用 64位标准双精度浮点数 来表示数字，但实际计算时，整数是 32位带符号整数（对于大多数常规运算）。<br>32位带符号整数的范围为 -2的31次幂到2的31次幂 - 1， 即从 -2147483648 到 2147483647。</p><h3 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h3><ul><li>当数值超出范围时（如负数 -2147483648 转为正数），JavaScript 会 自动将其转换为无符号整数，这会导致在某些运算中产生意料之外的结果。</li></ul><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><p>算术移位：右移补1.<br>逻辑移位：补0.</p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><ul><li>时间复杂度降到logn，递归。</li><li>问题：-2147483648 转为正数2147483648，变为无符号位，但如果算术右移以为还是符号位，补1导致错误。</li></ul><h2 id="window-addListeners"><a href="#window-addListeners" class="headerlink" title="window.addListeners"></a>window.addListeners</h2><ul><li>window.addEventListener 本身并不决定事件的同步或异步性质，具体取决于事件的触发方式：</li></ul><ol><li>使用 dispatchEvent 显式触发时，事件处理函数可能同步执行。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Event triggered&#x27;</span>);<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;customEvent&#x27;</span>, handler);<br><br><span class="hljs-comment">// 同步触发</span><br><span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Event</span>(<span class="hljs-string">&#x27;customEvent&#x27;</span>);<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">dispatchEvent</span>(event);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;End of script&#x27;</span>);<br><br></code></pre></td></tr></table></figure><p>由浏览器环境触发的事件(比如点击、滚动、hashchange)通常是在宏任务任务队列中异步执行。</p><h1 id="2025-1-1"><a href="#2025-1-1" class="headerlink" title="2025.1.1"></a>2025.1.1</h1><h2 id="pushstate、popstate、replacestate"><a href="#pushstate、popstate、replacestate" class="headerlink" title="pushstate、popstate、replacestate"></a>pushstate、popstate、replacestate</h2><ol><li>pushstate：向浏览器历史记录栈添加新的条目，不会刷新页面加载资源，需要手动更新（前端js实现路由切换）</li><li>replacestate：替换当前的条目。</li><li>popstate：<strong>只有</strong>浏览器的前进和后退会触发popstate（replace改变记录不会触发）</li></ol><h2 id="a标签跳转"><a href="#a标签跳转" class="headerlink" title="a标签跳转"></a>a标签跳转</h2><ol><li>情况一： <code>&lt;a href=&quot;#/a&quot;&gt;a应用&lt;/a&gt;</code>hash跳转，触发hashchange</li><li>情况二：<code>&lt;a href=&quot;/a&quot;&gt;a应用&lt;/a&gt;</code> 页面会刷新，向服务器发送请求。</li></ol><h2 id="single-spa手写完毕"><a href="#single-spa手写完毕" class="headerlink" title="single-spa手写完毕"></a>single-spa手写完毕</h2><h1 id="2025-1-2"><a href="#2025-1-2" class="headerlink" title="2025.1.2"></a>2025.1.2</h1><h2 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h2><h2 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h2><h2 id="调整数组顺序"><a href="#调整数组顺序" class="headerlink" title="调整数组顺序"></a>调整数组顺序</h2><h2 id="链表中倒数第K个节点"><a href="#链表中倒数第K个节点" class="headerlink" title="链表中倒数第K个节点"></a>链表中倒数第K个节点</h2><h1 id="2025-1-3"><a href="#2025-1-3" class="headerlink" title="2025.1.3"></a>2025.1.3</h1><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h2 id="合并两个排序链表"><a href="#合并两个排序链表" class="headerlink" title="合并两个排序链表"></a>合并两个排序链表</h2><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><h2 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h2><h2 id="翻转二叉树-1"><a href="#翻转二叉树-1" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><h2 id="qiankun基本使用"><a href="#qiankun基本使用" class="headerlink" title="qiankun基本使用"></a>qiankun基本使用</h2><h1 id="2025-1-4"><a href="#2025-1-4" class="headerlink" title="2025.1.4"></a>2025.1.4</h1><h2 id="对称二叉树-1"><a href="#对称二叉树-1" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><h2 id="栈的压入压出"><a href="#栈的压入压出" class="headerlink" title="栈的压入压出"></a>栈的压入压出</h2><h1 id="2025-1-5"><a href="#2025-1-5" class="headerlink" title="2025.1.5"></a>2025.1.5</h1><h2 id="最小栈（重复添加"><a href="#最小栈（重复添加" class="headerlink" title="最小栈（重复添加"></a>最小栈（重复添加</h2><h2 id="层序遍历-1-2-3"><a href="#层序遍历-1-2-3" class="headerlink" title="层序遍历 1.2.3"></a>层序遍历 1.2.3</h2><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><ul><li>左边<strong>都</strong>根小，右边<strong>都</strong>比根大</li></ul><h2 id="二叉搜索树的后序遍历顺序"><a href="#二叉搜索树的后序遍历顺序" class="headerlink" title="二叉搜索树的后序遍历顺序"></a>二叉搜索树的后序遍历顺序</h2><h2 id="路径总和-1-2"><a href="#路径总和-1-2" class="headerlink" title="路径总和 1.2"></a>路径总和 1.2</h2><ul><li>与常规递归思路区别：不要遍历到空节点再判断</li></ul><h2 id="qiankun的使用注意事项"><a href="#qiankun的使用注意事项" class="headerlink" title="qiankun的使用注意事项"></a>qiankun的使用注意事项</h2><h3 id="public-path"><a href="#public-path" class="headerlink" title="public-path"></a>public-path</h3><ul><li>解决子应用资源路径无法加载的问题</li></ul><h3 id="qiankun打包格式为umd"><a href="#qiankun打包格式为umd" class="headerlink" title="qiankun打包格式为umd"></a>qiankun打包格式为umd</h3><h3 id="容器挂载"><a href="#容器挂载" class="headerlink" title="容器挂载"></a>容器挂载</h3><ul><li>container里面的root，而不是根root</li></ul><h3 id="qiankun全局标识"><a href="#qiankun全局标识" class="headerlink" title="qiankun全局标识"></a>qiankun全局标识</h3><ul><li>qiankun提供了标识，用于当前应用是否在父应用中被引用<br><code>if(!window.__POWERED_BY_QIANKUN__)</code></li></ul><h1 id="2025-1-6"><a href="#2025-1-6" class="headerlink" title="2025.1.6"></a>2025.1.6</h1><h2 id="链表的复制"><a href="#链表的复制" class="headerlink" title="链表的复制"></a>链表的复制</h2><h2 id="二叉搜索树第k大的节点"><a href="#二叉搜索树第k大的节点" class="headerlink" title="二叉搜索树第k大的节点"></a>二叉搜索树第k大的节点</h2><h2 id="字符串全排列"><a href="#字符串全排列" class="headerlink" title="字符串全排列"></a>字符串全排列</h2><h2 id="数组中出现次数超过一半的值"><a href="#数组中出现次数超过一半的值" class="headerlink" title="数组中出现次数超过一半的值"></a>数组中出现次数超过一半的值</h2><h2 id="二叉搜索树-9997"><a href="#二叉搜索树-9997" class="headerlink" title="二叉搜索树 &#9997;"></a>二叉搜索树 &#9997;</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li>左边都比根小，右边都比根大</li><li>子树也是二叉搜索树</li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ol><li>比当前节点小去左子树，比当前节点大去右子树</li><li>最大值一直往右，最小值一直往左</li></ol><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul><li>一定会插入到叶子节点</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ol><li>情况一：叶子（没有子节点）节点，直接删除即可。</li><li>情况二：一个子节点，直接替换即可。</li><li>情况三：两个子节点，找左边最大值，或者右边最小值，保持二叉搜索树规律（左小，右大）。</li></ol><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p><code>div[data-qiankun=&quot;reactApp&quot;]</code>,div元素data-qiankun属性为reactApp时候样式才生效。</p><h1 id="2025-1-7"><a href="#2025-1-7" class="headerlink" title="2025.1.7"></a>2025.1.7</h1><h2 id="二叉树转换为双向链表"><a href="#二叉树转换为双向链表" class="headerlink" title="二叉树转换为双向链表"></a>二叉树转换为双向链表</h2><h2 id="连续子数组最大值"><a href="#连续子数组最大值" class="headerlink" title="连续子数组最大值"></a>连续子数组最大值</h2><h2 id="堆基础知识"><a href="#堆基础知识" class="headerlink" title="堆基础知识"></a>堆基础知识</h2><h1 id="2025-1-8"><a href="#2025-1-8" class="headerlink" title="2025.1.8"></a>2025.1.8</h1><h2 id="qiankun源码"><a href="#qiankun源码" class="headerlink" title="qiankun源码"></a>qiankun源码</h2><h1 id="2025-1-9"><a href="#2025-1-9" class="headerlink" title="2025.1.9"></a>2025.1.9</h1><h2 id="01背包问题基础"><a href="#01背包问题基础" class="headerlink" title="01背包问题基础"></a>01背包问题基础</h2><ol><li>二维：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + weight[i]);<br></code></pre></td></tr></table></figure><ol start="2"><li>一维：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dp[j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[j],dp[j - weight[i]] + weight[i]);<br></code></pre></td></tr></table></figure><h2 id="数组翻译成字符串"><a href="#数组翻译成字符串" class="headerlink" title="数组翻译成字符串"></a>数组翻译成字符串</h2><h2 id="礼物得最大价值"><a href="#礼物得最大价值" class="headerlink" title="礼物得最大价值"></a>礼物得最大价值</h2><h2 id="丑数1"><a href="#丑数1" class="headerlink" title="丑数1"></a>丑数1</h2><h1 id="2025-1-10"><a href="#2025-1-10" class="headerlink" title="2025.1.10"></a>2025.1.10</h1><h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><h2 id="第一次只出现一次的数字"><a href="#第一次只出现一次的数字" class="headerlink" title="第一次只出现一次的数字"></a>第一次只出现一次的数字</h2><ul><li>lastIndexOf、 indexOf</li></ul><h2 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="两个链表的公共节点"><a href="#两个链表的公共节点" class="headerlink" title="两个链表的公共节点"></a>两个链表的公共节点</h2><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h2 id="single-spa进行了总结"><a href="#single-spa进行了总结" class="headerlink" title="single-spa进行了总结"></a>single-spa进行了总结</h2><h2 id="qiankun使用"><a href="#qiankun使用" class="headerlink" title="qiankun使用"></a>qiankun使用</h2><ol><li>主应用注册子应用</li><li>子应用暴露接口协议</li><li>public-path.js：改变静态资源路径为子应用ip地址，默认会是父应用ip地址导致静态资源无法加载。</li><li>挂载位置：子应用挂载到app，根应用也是app的div，这时候需要限制查找范围。props参数有个container属性是dom元素。主应用的html下面有一个container div，container div上挂载子应用的html，子应用html有app。</li><li>webpack打包格式为umd格式</li><li>除了微前端启动，还有正常启动，qiankun会在window放个全局属性powerbyqiankun没有的话直接调render函数就好。</li></ol><h2 id="js沙箱"><a href="#js沙箱" class="headerlink" title="js沙箱"></a>js沙箱</h2><ol><li>快照沙箱</li><li>单实例</li><li>多实例沙箱</li></ol><h2 id="css样式隔离-1"><a href="#css样式隔离-1" class="headerlink" title="css样式隔离"></a>css样式隔离</h2><h1 id="1-11"><a href="#1-11" class="headerlink" title="1.11"></a>1.11</h1><h2 id="异或两道题"><a href="#异或两道题" class="headerlink" title="异或两道题"></a>异或两道题</h2><h2 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h2><h2 id="和为s的连续数字"><a href="#和为s的连续数字" class="headerlink" title="和为s的连续数字"></a>和为s的连续数字</h2><h2 id="双指针总结"><a href="#双指针总结" class="headerlink" title="双指针总结"></a>双指针总结</h2><ul><li>双指针有两种类型，一种是left &#x3D; 0;right &#x3D; arr.length; while(left &lt; right)</li><li>另一种是： left &#x3D; 0, right &#x3D; 1; while(right &lt; arr.length)</li></ul><h2 id="字符串trim方法"><a href="#字符串trim方法" class="headerlink" title="字符串trim方法"></a>字符串trim方法</h2><ul><li>去除前后的空格</li></ul><h2 id="qiankun源码-1"><a href="#qiankun源码-1" class="headerlink" title="qiankun源码"></a>qiankun源码</h2><h2 id="import-html-entry"><a href="#import-html-entry" class="headerlink" title="import-html-entry"></a>import-html-entry</h2><h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>八股汇总</title>
    <link href="/2025/04/05/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%85%AB%E8%82%A1%E6%B1%87%E6%80%BB/"/>
    <url>/2025/04/05/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%85%AB%E8%82%A1%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="八股总结"><a href="#八股总结" class="headerlink" title="八股总结"></a>八股总结</h1><h2 id="git-9889"><a href="#git-9889" class="headerlink" title="git &#9889;"></a>git &#9889;</h2><ol><li>git常用的命令 </li><li>发现之前提交的代码有问题，怎么实现回退 </li><li>git如何处理冲突 </li><li>git rebase和git merge区别</li></ol><h2 id="css-9889"><a href="#css-9889" class="headerlink" title="css &#9889;"></a>css &#9889;</h2><ol><li>选择器优先级</li><li>可继承和不可继承的属性</li><li>display属性</li><li>隐藏元素的方法，三者区别</li><li>link和@import区别</li><li>transition和animation区别</li><li>伪元素和伪类的区别</li><li>requestAnimationFrame的理解</li><li>对盒模型的理解（IE、标准盒子模型，如何设置）</li><li>为什么用transition改变元素位置</li><li>CSS3的新特性</li><li>css处理器</li><li>单行多行文本溢出</li><li>媒体查询</li><li>z-index什么时候失效</li><li>浮动元素的特点和缺点</li><li>BFC</li><li>clearfix</li><li>定位</li><li>元素层叠顺序</li><li>层叠上下文</li><li>比较两个元素谁在上、谁在下</li><li>css单位</li><li>两栏布局</li><li>三栏布局</li><li>垂直居中</li><li>flex布局</li></ol><h2 id="TS-1天-9889"><a href="#TS-1天-9889" class="headerlink" title="TS 1天 &#9889;"></a>TS 1天 &#9889;</h2><ol><li>ts和js区别 </li><li>枚举类型 </li><li>接口和类区别 </li><li>ts函数的理解 </li><li>泛型理解 </li><li>interface和type区别 </li><li>any和unkown区别 </li><li>高级类型：交叉类型、联合类型、类型别名、类型索引、typeof、infer </li><li>returnType、parameters </li><li>patical、required、readonly。</li><li>&#10024; Exclude、Include、Pick、Omit </li><li>讲讲ts是怎么转化为js的？使用什么工具</li></ol><h2 id="vue-4-5天"><a href="#vue-4-5天" class="headerlink" title="vue 4-5天"></a>vue 4-5天</h2><ol><li>AST语法树的生成过程 &#9889;</li><li>AST语法树代码拼接成渲染函数 &#9889;</li><li>AST语法树和虚拟DOM区别</li><li>npm run build后发生什么</li><li>vue2 和 vue3 diff算法 &#9889;</li><li>Object.defineProperty 和 proxy的区别</li><li>响应式原理 &#9889;</li><li>数组响应式原理</li><li>vue2响应式原理缺点</li><li>vue3响应式原理优化</li><li>响应式为什么用reflectAPI</li><li>watch原理</li><li>computed原理</li><li>nextTick原理</li><li>为什么data是函数</li><li>组件渲染过程</li><li>Vue.set原理</li><li>异步组件</li><li>props原理</li><li>emit原理</li><li>插槽原理</li><li>keep-alive原理</li><li>provide和inject原理</li><li>属性透传</li><li>v-if和v-for优先级哪个更高</li><li>v-if和v-show区别</li><li>v-model原理</li><li>前端路由和后端路由</li><li>hash模式和history模式</li><li>vuex和localStorage区别</li><li>vuex为什么有mutations而pinia没有</li><li>vuex和pinia区别</li></ol><h2 id="微前端-2天-9889"><a href="#微前端-2天-9889" class="headerlink" title="微前端 2天 &#9889;"></a>微前端 2天 &#9889;</h2><ol><li>微前端解决了什么问题</li><li>微前端的缺点</li><li>qiankun和iframe区别</li><li>子应用如何接入qiankun框架？ &#9889;</li><li>start时候qiankun干了什么？</li><li>父子应用通信</li><li>js沙箱机制</li><li>css样式隔离</li><li>父子应用路由</li><li>qiankun和single-spa区别</li><li>预加载</li><li>import-html-entry</li><li>为什么qiankun要用umd格式</li></ol><h2 id="wepack、vite-2天-9889"><a href="#wepack、vite-2天-9889" class="headerlink" title="wepack、vite 2天 &#9889;"></a>wepack、vite 2天 &#9889;</h2><ol><li>loader</li><li>plugin</li><li>如何编写loader、plugin</li><li>webpack构建流程</li><li>如何加快webpack构建速度</li><li>如何减少webpack打包体积</li><li>webpack热模块更新</li><li>webpack和vite的区别</li><li>vite的构建原理 &#9889;</li><li>vite开始使用esbuild，打包使用rollup原因</li><li>babel原理是什么</li></ol><h2 id="计算机网络-3天-9889"><a href="#计算机网络-3天-9889" class="headerlink" title="计算机网络 3天 &#9889;"></a>计算机网络 3天 &#9889;</h2><ol><li>状态码</li><li>&#10024; 301、302状态码浏览器处理</li><li>头部字段 </li><li>get、post区别</li><li>http1.1和1.0区别 </li><li>https </li><li>tls握手 </li><li>1.1如何优化 </li><li>https如何优化 </li><li>&#10024; RSA、ECDHE </li><li>http2.0 </li><li>http3.0 </li><li>&#10024; quic协议如何确保可靠性 </li><li>tcp、udp区别 </li><li>三次握手 </li><li>握手丢失 </li><li>两次握手、四次握手问题 </li><li>四次挥手 </li><li>挥手丢失 </li><li>三次挥手问题 </li><li>为什么要等待2MSL </li><li>滑动窗口 </li><li>流量控制 </li><li>拥塞控制 </li><li>&#10024; 输入url后发生什么 </li><li>&#10024; TCP&#x2F;IP五层模型 </li><li>quic协议 <a href="https://xiaolincoding.com/network/3_tcp/quic.html#quic-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84">https://xiaolincoding.com/network/3_tcp/quic.html#quic-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84</a></li><li>TCP协议一定不会丢包吗</li></ol><h2 id="操作系统-2天-9889"><a href="#操作系统-2天-9889" class="headerlink" title="操作系统 2天 &#9889;"></a>操作系统 2天 &#9889;</h2><ol><li>进程 </li><li>线程 </li><li>进程和线程区别 </li><li>进程调度算法 </li><li>进程通信方式 </li><li>死锁 </li><li>锁的分类 </li><li>浏览器进程 </li><li>浏览器为什么有请求次数限制 </li><li>如何解决浏览器请求限制 </li><li>虚拟内存  </li><li>内存分段、分页 </li><li>TLB、段页式存储  </li><li>&#10024; 磁盘调度算法</li><li>页面置换算法</li></ol><h2 id="浏览器原理-2天-9889"><a href="#浏览器原理-2天-9889" class="headerlink" title="浏览器原理 2天 &#9889;"></a>浏览器原理 2天 &#9889;</h2><ol><li>xss攻击和csrf攻击，以及如何解决 &#9889;</li><li>浏览器缓存 &#9889;</li><li>cache-control字段 &#9889;</li><li>浏览器组成 &#9889;</li><li>浏览器渲染过程 &#9889;</li><li>浏览器渲染过程中的两个生命周期钩子 &#9889;</li><li>如何优化浏览器渲染过程 &#9889;</li><li>如何减少回流重绘 &#9889;</li><li>DocumentFragments &#9889;</li><li>cookie、localStorage、SessionStorage区别 &#9889;</li><li>cookie字段 &#9889;</li><li>cookie特性 &#9889;</li><li>indexedDB &#9889;</li><li>同源策略 &#9889;</li><li>如何解决跨域 &#9889;</li><li>事件模型 &#9889;</li><li>阻止事件冒泡 &#9889;</li><li>事件委托 &#9889;</li><li>事件循环，宏任务，微任务 &#9889;</li><li>&#10024; 为什么有宏任务队列和微任务队列两个？&#9889;</li></ol><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><ol><li>replaceState、popState、pushState</li><li>纯文本内容修改，vue可以监督吗</li><li>在vue-router里面，用pushState、replaceState而不是vue的push能触发页面路由切换吗</li><li>内存泄露的原因</li><li>如何查看是否内存泄漏</li><li>如何定位到泄露的位置</li><li>从A页面到B页面的优化</li><li>如果接手一个项目，如何处理？</li><li>前端如何debug？没有代码时候如何处理？</li><li>封装组件和正常写组件区别</li><li>如何封装一个组件</li><li>如何设计一个微前端框架</li><li>性能优化</li><li>JWT鉴权机制，JWT和传统token有什么区别</li><li>传统token和session区别</li><li>如果让你实现一个打包工具怎么实现</li><li>i18n如何实现的国际化有了解吗？</li><li>JSON实现深拷贝的缺点，如何解决</li><li>虚拟DOM相比真实DOM的优点？</li><li>虚拟DOM一定比真实DOM更快吗？</li><li>vue的优点</li><li>webpack5模块联邦实现微前端</li></ol><h1 id="其它知识点"><a href="#其它知识点" class="headerlink" title="其它知识点"></a>其它知识点</h1><h2 id="pushstate、popstate、replacestate"><a href="#pushstate、popstate、replacestate" class="headerlink" title="pushstate、popstate、replacestate"></a>pushstate、popstate、replacestate</h2><ul><li>只有postate是事件，其他两个只是方法不能被监听。</li></ul><ol><li>pushstate：向浏览器历史记录栈添加新的条目，<strong>当前地址栏变成指定url</strong>，但不会刷新页面加载资源， 需要手动更新 &#x3D;》前端js实现路由切换</li><li>replacestate：浏览器<strong>地址栏更新为指定 URL</strong>，但不加载页面，仅替换当前历史记录。</li><li>popstate：<strong>只有</strong>浏览器的前进和后退和history.back、history.forward、history.go会触发popstate（push、replace改变记录不会触发）<br>前两个方法相等于只会更改历史记录（不会触发popstate事件），最后一个是事件一般用来监听实现路由或子应用切换。<br>那对于前两个事件，qiankun是对其进行了重写，vue-router是对其封装了一层用router.push。</li></ol><h2 id="在vue-router里面，用pushState、replaceState而不是vue的push能触发页面路由切换吗"><a href="#在vue-router里面，用pushState、replaceState而不是vue的push能触发页面路由切换吗" class="headerlink" title="在vue-router里面，用pushState、replaceState而不是vue的push能触发页面路由切换吗"></a>在vue-router里面，用pushState、replaceState而不是vue的push能触发页面路由切换吗</h2><ul><li>不能，vue的router.push(‘&#x2F;new-url’);router.replace(‘&#x2F;new-url’)方法会触发导航守卫、渲染组件，再调用pushstate、replacestate更改url，<strong>router.push方法相当于在pushstate做了一层封装</strong>，直接使用replace、push没有js切换页面的逻辑。</li></ul><h2 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h2><ul><li><a href="https://juejin.cn/post/6984188410659340324?searchId=2025031315545535021E8FF05054738485#heading-2">https://juejin.cn/post/6984188410659340324?searchId=2025031315545535021E8FF05054738485#heading-2</a></li></ul><ol><li>不恰当的闭包</li><li>全局变量</li><li>DOM引用：父元素删除了，但对子元素还有引用。</li><li>未关闭的定时器</li><li>事件监听：组件卸载要关闭。监听者模式：全局总线，组件绑定事件，组件卸载要解绑事件。</li><li>未清理的console.log，如果log是打印对象，也不会垃圾回收。</li><li>map、set：这两个是强引用，如果对象被这两个存储了，即使删除了对象，对象也还在。</li></ol><h2 id="如何查看是否有内存泄露"><a href="#如何查看是否有内存泄露" class="headerlink" title="如何查看是否有内存泄露"></a>如何查看是否有内存泄露</h2><ol><li>性能performance面板，开始记录，开始时候清空一次垃圾。</li><li>然后进行操作，操作到一半再清空一次垃圾（能回收就没有泄漏）。</li><li>操作完，结束记录。如果查看中间清空的时候 js堆内存没有减少，就是有内存泄漏。</li></ol><h2 id="如何定位到泄露的位置"><a href="#如何定位到泄露的位置" class="headerlink" title="如何定位到泄露的位置"></a>如何定位到泄露的位置</h2><ol><li>内存面板，可以生成堆快照。</li><li>进行一次GC，操作，生成快照。</li><li>进行一次GC，操作，生成快照。</li><li>对比前后堆快照的区别，它会标明是代码执行到哪一行新增了堆，新增的就是泄露的内存。</li></ol><h2 id="从A页面到B页面的优化"><a href="#从A页面到B页面的优化" class="headerlink" title="从A页面到B页面的优化"></a>从A页面到B页面的优化</h2><ol><li>link标签，preload预加载资源，当页面使用该资源时候可以更快响应，也避免了资源加载和解析html冲突；prefetch未来可能用到的资源，网络线程空闲时候可以加载；dns-prefetch，提前解析域名(一是B页面写，二三是A页面写)。B页面 script标签的async defer</li><li>B页面http2.0，服务端主动推送</li><li>浏览器缓存</li><li>单页面应用，全局状态管理共享数据。</li><li>webpack代码分割</li><li>web worker 处理复杂操作</li></ol><h2 id="性能优化（所有能想到的点）"><a href="#性能优化（所有能想到的点）" class="headerlink" title="性能优化（所有能想到的点）"></a>性能优化（所有能想到的点）</h2><ol><li>html：减少回流重绘。</li><li>css用link开启线程去加载外联css，@import会让GUI渲染线程停止当前渲染去加载。</li><li>js：defer、async、写到脚本末尾。</li><li>vue：虚拟DOM，diff对比，更快操作DOM。</li><li>网络：http2.0主动推送、并发传输。</li><li>浏览器：缓存。</li><li>按需请求、虚拟列表。</li><li>webpack：代码分割、代码压缩。</li><li>事件委托。</li></ol><h2 id="JWT鉴权机制，JWT和传统token有什么区别"><a href="#JWT鉴权机制，JWT和传统token有什么区别" class="headerlink" title="JWT鉴权机制，JWT和传统token有什么区别"></a>JWT鉴权机制，JWT和传统token有什么区别</h2><ul><li>jwt三部分组成，第三部分会用密钥加密签名，因为签名不可破解，服务端不用存储额外用户信息而是存到jwt中，将用户信息存到客户端。服务端只需用密钥解密认证即可。</li><li>传统token（就是session）是随机字符串，不能存放信息，用户信息存到服务端</li></ul><h2 id="传统token和session区别"><a href="#传统token和session区别" class="headerlink" title="传统token和session区别"></a>传统token和session区别</h2><ul><li>sessionid对应一个用户信息</li><li>传统token只是在后端有一个白名单列表（是轻量级session）</li></ul><h2 id="如果让你实现一个打包工具怎么实现"><a href="#如果让你实现一个打包工具怎么实现" class="headerlink" title="如果让你实现一个打包工具怎么实现"></a>如果让你实现一个打包工具怎么实现</h2><ul><li>打包工具是什么？打包工具是把多个模块整合成一个或多个优化后的文件，解决模块化和浏览器兼容的问题。</li></ul><ol><li>找到入口文件，生成AST语法树，识别模块导入语句。</li><li>将模块转换，AST语法树转换成浏览器可以识别的文件。</li><li>最后输出：做tree-shaking，代码压缩等优化。</li></ol><h2 id="i18n如何实现的国际化有了解吗？"><a href="#i18n如何实现的国际化有了解吗？" class="headerlink" title="i18n如何实现的国际化有了解吗？"></a>i18n如何实现的国际化有了解吗？</h2><ul><li>根据入参：当前是哪个地区，有键值对映射关系转换。</li><li>高级转换：复数、时间转换</li></ul><h2 id="JSON实现深拷贝的缺点，如何解决"><a href="#JSON实现深拷贝的缺点，如何解决" class="headerlink" title="JSON实现深拷贝的缺点，如何解决"></a>JSON实现深拷贝的缺点，如何解决</h2><ul><li>循环引用、原型链不会转换</li><li>函数、symbol、undefined、不可遍历属性不会转换，NaN转换为null。</li><li>解决：自己实现，特判。</li></ul><h2 id="虚拟DOM相比真实DOM的优点？"><a href="#虚拟DOM相比真实DOM的优点？" class="headerlink" title="虚拟DOM相比真实DOM的优点？"></a>虚拟DOM相比真实DOM的优点？</h2><ol><li><strong>异步批量更新</strong>（watch队列，nextTick的缓冲队列），减少频繁的DOM操作。</li><li><strong>最小化DOM操作</strong>：通过diff算法对比两次虚拟DOM树的区别，尽可能复用现有的真实DOM。</li><li><strong>跨平台渲染</strong>：浏览器渲染，服务端渲染。</li></ol><h2 id="虚拟DOM一定比真实DOM更快吗？"><a href="#虚拟DOM一定比真实DOM更快吗？" class="headerlink" title="虚拟DOM一定比真实DOM更快吗？"></a>虚拟DOM一定比真实DOM更快吗？</h2><ol><li>不一定。解析模板、ast语法树、渲染函数、虚拟DOM创建、diff对比、真实DOM创建都是要消耗性能的。如果是简单的页面，直接操作真实DOM效率更高。</li><li>也增加了内存消耗。</li></ol><h2 id="vue优点"><a href="#vue优点" class="headerlink" title="vue优点"></a>vue优点</h2><ol><li><em><strong>声明式框架</strong></em>：响应式原理</li><li><em><strong>虚拟DOM</strong></em>697：第一：diff算法。第二：支持跨平台，服务端渲染、浏览器渲染，将虚拟DOM转换为真实HTML元素。</li><li><em><strong>区分编译时和运行时</strong></em>：<br>编译时：将<strong>模板</strong>变成js语法渲染函数生成的<strong>虚拟DOM</strong>；<br>运行时：上线时只走运行时。</li><li><em><strong>拥抱Ts</strong></em></li></ol><h2 id="webpack5模块联邦实现微前端"><a href="#webpack5模块联邦实现微前端" class="headerlink" title="webpack5模块联邦实现微前端"></a>webpack5模块联邦实现微前端</h2><ul><li>跨应用之间的模块共享。</li></ul><h2 id="微前端实现"><a href="#微前端实现" class="headerlink" title="微前端实现"></a>微前端实现</h2><ol><li>将多个项目域名合并处理，不需要前端改任何代码。比如：a.com b.com c.com合成tencent&#x2F;a tencent&#x2F;b tencent&#x2F;c.(刷新页面)</li><li>qiankun、single-spa、wujie 有个框架基座，来回切换。</li><li>模块联邦：运行时动态加载彼此的模块，从而实现 应用拆分、独立部署、依赖共享。 也是有一个主应用动态加载子应用，公共依赖也可以共享。</li></ol>]]></content>
    
    
    <categories>
      
      <category>其它知识点</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TS八股</title>
    <link href="/2025/04/05/TS/3.%E5%85%AB%E8%82%A1/"/>
    <url>/2025/04/05/TS/3.%E5%85%AB%E8%82%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="any和unknown区别"><a href="#any和unknown区别" class="headerlink" title="any和unknown区别"></a>any和unknown区别</h2><ol><li>unknown类型检测更严格,unknown类型的变量不能赋值给其他类型,可以将任意类型给unknown.类型检查和类型断言前不能对unknown操作.</li><li>any类型的值会绕过ts编译检查.</li></ol><h2 id="interface和type区别"><a href="#interface和type区别" class="headerlink" title="interface和type区别"></a>interface和type区别</h2><ol><li>interface一般用来定义对象、函数、类；type除了可以定义接口类型外，还可以定义常量类型、联合类型、交叉类型以及任何可以手写的类型。</li><li>interface通过extends扩展接口，type通过联合类型 &amp; 扩展。</li><li>interface：支持声明合并。如果多次定义同名接口，TypeScript 会自动合并它们。type：不支持声明合并。如果多次定义同名类型，会报错。</li></ol><h2 id="封装的复杂类"><a href="#封装的复杂类" class="headerlink" title="封装的复杂类"></a>封装的复杂类</h2><ul><li>httpClient，因为我们会请求多个后端cgi，基于axios的二次封装。</li></ul><ol><li>在构造函数里面传入commonOptions，类上定义公共参数的set、get方法：传入baseURL，默认参数。</li><li>构造函数里面声明axios实例，给该实例添加请求拦截器、响应拦截器。</li><li>类中定义请求、响应拦截器成功、失败的函数。请求拦截器添加身份认证、数据类型等参数，类中定义重定向到登录页面，当响应失败时候调用该方法；如果请求失败什么的打印错误日志。</li><li>类中定义get、post、put、delete方法，也就是调用axios实例的这些方法。</li></ol><h2 id="交叉类型-和联合类型"><a href="#交叉类型-和联合类型" class="headerlink" title="交叉类型 &amp; 和联合类型 |"></a>交叉类型 &amp; 和联合类型 |</h2><p>1.<em><strong>交叉类型 &amp;</strong></em> ：把多个类型合并成一个类型.比如两个接口联合,那么那个变量就要有两个接口的所有属性.<br>2. <em><strong>联合类型 |</strong></em> ：一个变量可能是多种类型的时候使用联合类型.number | string</p>]]></content>
    
    
    <categories>
      
      <category>TS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高级类型</title>
    <link href="/2025/04/05/TS/2.%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/"/>
    <url>/2025/04/05/TS/2.%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<ul><li>ts内置工具类：<a href="https://segmentfault.com/a/1190000041910773">https://segmentfault.com/a/1190000041910773</a></li></ul><h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><ol><li><em><strong>交叉类型</strong></em>：将多个类型合并为一个类型,两个接口i合并为一个接口情况.</li><li><em><strong>联合类型 |</strong></em>:表示类型为连接的多个类型中的一个. <strong>number | string</strong>。</li><li><em><strong>类型别名 type</strong></em>:type字段去给一个类型取名,和接口类似可以去描述一个函数或者对象,但它还可以支持交叉联合类型</li><li><em><strong>类型索引 keyof</strong></em>: 太抽象了,就是获取接口的属性的联合类型,是常量的联合. keyof后结果就是常量的联合类型。</li><li><em><strong>类型约束 extends</strong></em>:对泛型的约束,&lt;T,K extends keyof T&gt;(obj:T,key:K) </li><li><em><strong>映射类型 in</strong></em>:遍历联合类型</li><li><em><strong>条件类型</strong></em>：T extends U ? X : Y，如果 T 是 U 的子集，就是类型 X，否则为类型 Y。</li></ol><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><ul><li>在类型层面获取一个值的类型。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-number">1.</span> 基本使用方法<br>（先有的数据，再有的接口）<br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span><br>&#125;;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PersonType</span> = <span class="hljs-keyword">typeof</span> person;<br><span class="hljs-comment">// PersonType 的类型为 &#123; name: string; age: number &#125;</span><br><br><br><span class="hljs-number">2.</span> 配合<span class="hljs-title class_">ReturnType</span>使用<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createUser</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> createUser&gt;;<br><span class="hljs-comment">// User 的类型为 &#123; id: number; name: string &#125;</span><br><br><br><span class="hljs-number">3.</span> 用于函数参数类型<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>. You are <span class="hljs-subst">$&#123;age&#125;</span> years old.`</span>);<br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">GreetParams</span> = <span class="hljs-title class_">Parameters</span>&lt;<span class="hljs-keyword">typeof</span> greet&gt;;<br><span class="hljs-comment">// GreetParams 的类型为 [string, number]</span><br><br><br><span class="hljs-number">4.</span> 用于常量联合类型<br><span class="hljs-keyword">const</span> colors = &#123;<br>  <span class="hljs-attr">red</span>: <span class="hljs-string">&quot;RED&quot;</span>,<br>  <span class="hljs-attr">blue</span>: <span class="hljs-string">&quot;BLUE&quot;</span>,<br>  <span class="hljs-attr">green</span>: <span class="hljs-string">&quot;GREEN&quot;</span><br>&#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Color</span> = <span class="hljs-keyword">typeof</span> colors[keyof <span class="hljs-keyword">typeof</span> colors];<br><span class="hljs-comment">// Color 的类型为 &quot;RED&quot; | &quot;BLUE&quot; | &quot;GREEN&quot;</span><br><br><br></code></pre></td></tr></table></figure><h2 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h2><ul><li>在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用,声明一个变量来承载传入函数签名的返回值类型.</li><li>只能在条件类型的子句extends中才能使用。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-number">1.</span> 推断函数返回值类型<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ReturnType</span>&lt;T&gt; = T <span class="hljs-title function_">extends</span> (<br>  ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]<br>) =&gt; infer R ? R : <span class="hljs-built_in">any</span>;<br><br><span class="hljs-number">2.</span> 推断数组类型<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ElementType</span>&lt;T&gt; = T <span class="hljs-title function_">extends</span> (infer U)[] ? U : T;<br></code></pre></td></tr></table></figure><h2 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h2><ul><li>提取函数的返回类型，传入一个函数的类型（通过typeof获取函数类型（此typeof不是js中的typeof）），返回该函数的返回类型。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span></span>) : <span class="hljs-title function_">number</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-keyword">type</span> foo = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> add&gt;;<br><br><br>原理：<br><span class="hljs-keyword">type</span> returnType&lt;T <span class="hljs-title function_">extends</span> (...args : <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt;<br>= T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[])=&gt;infer R ? R : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><ul><li>提取函数的参数类型，返回是一个元组。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyParameters</span>&lt;T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt;<br>= T <span class="hljs-title function_">extends</span> (...<span class="hljs-attr">args</span>: infer P) =&gt; <span class="hljs-built_in">any</span> ? P : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><h2 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h2><ul><li>将接口类型属性都变成可选属性。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Partial</span>&lt;T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof T]?: T[P];<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h2><ul><li>将接口类型的属性都变成<strong>必选的</strong>。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Required</span>&lt;T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> keyof keyof T]-? : T[P];<br>&#125;<br>&lt;!-- 减去一个问号 --&gt;<br></code></pre></td></tr></table></figure><h2 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h2><ul><li>给接口每一个属性添加readonly</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Readonly</span>&lt;T&gt; = &#123;<br>  <span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]: T[P];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="联合类型的分配"><a href="#联合类型的分配" class="headerlink" title="联合类型的分配"></a>联合类型的分配</h2><ul><li>当条件类型（extends）应用于 联合类型 时，TypeScript 会将联合类型中的每个成员逐个进行判断，而不是一次性地判断整个联合类型。</li></ul><h2 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h2><ul><li>提取联合类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 处理联合类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Test1</span> = <span class="hljs-string">&#x27;1&#x27;</span> | <span class="hljs-string">&#x27;2&#x27;</span> | <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-title class_">Test1</span>, <span class="hljs-string">&#x27;1&#x27;</span> | <span class="hljs-string">&#x27;2&#x27;</span>&gt; = <span class="hljs-string">&#x27;1&#x27;</span>; <span class="hljs-comment">// 1,2 OK 赋值3就会error</span><br><br>&lt;!-- 手写 --&gt;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Extract</span>&lt;T, U&gt; = T <span class="hljs-keyword">extends</span> U ? T : <span class="hljs-built_in">never</span>;<br></code></pre></td></tr></table></figure><h2 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h2><ul><li>排除联合类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 处理联合类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Test1</span> = <span class="hljs-string">&#x27;1&#x27;</span> | <span class="hljs-string">&#x27;2&#x27;</span> | <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-title class_">Test1</span>, <span class="hljs-string">&#x27;1&#x27;</span> | <span class="hljs-string">&#x27;2&#x27;</span>&gt; = <span class="hljs-string">&#x27;3&#x27;</span>; <span class="hljs-comment">// 3 OK 赋值1,2就会error</span><br><br>&lt;!-- 手写 --&gt;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Exclude</span>&lt;T, U&gt; = T <span class="hljs-keyword">extends</span> U ? <span class="hljs-built_in">never</span> : T; <br></code></pre></td></tr></table></figure><h2 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h2><ul><li>采集接口类型中<strong>需要的部分</strong>形成新的类型。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts">tpye <span class="hljs-title class_">Pick</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = &#123;<br>  [P <span class="hljs-keyword">in</span> K] : T[P];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h2><ul><li>剔除接口类型中<strong>不需要的属性</strong>后形成新的类型。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> = <span class="hljs-title class_">Omit</span>&lt;<span class="hljs-title class_">UserObj</span>, <span class="hljs-string">&quot;age&quot;</span> | <span class="hljs-string">&quot;sex&quot;</span>  | <span class="hljs-string">&quot;address&quot;</span> | <span class="hljs-string">&quot;weight&quot;</span>&gt;;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Omit</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = <span class="hljs-title class_">Pick</span>&lt;T, <span class="hljs-title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>TS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS基础</title>
    <link href="/2025/04/05/TS/1.%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/04/05/TS/1.%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="对typescript的理解？与js区别？"><a href="#对typescript的理解？与js区别？" class="headerlink" title="对typescript的理解？与js区别？"></a>对typescript的理解？与js区别？</h2><ol><li><strong>后缀</strong>为.js，.ts&#x2F;.tsx，js执行更快，ts还需要编译成js代码，使浏览器可以理解</li><li>ts可以在<em><strong>编译时</strong></em>发现错误，js只能在<em><strong>运行时</strong></em>候发现错误。</li><li><em><strong>强类型语言</strong></em>：类型检查，类型推断。</li><li>支持 <em><strong>模块、接口、枚举、交叉类型、联合类型</strong></em>等等</li></ol><h2 id="ts数据类型"><a href="#ts数据类型" class="headerlink" title="ts数据类型"></a>ts数据类型</h2><ul><li>boolean，number，string，null，undefined，object</li><li>any，unkonwn；void：方法没有返回值。</li><li>元组tuple：已知元素数量和类型的数组。</li><li>枚举enum：给一组数值赋予友好名字。</li></ul><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><ul><li>给数值常量赋予友好的名字。策略状态：空跑1，上线2，下线3.</li><li>原理：obj [ obj [ 空跑 ] &#x3D; 1 ] &#x3D; “空跑” ？？&#x2F;&#x2F; ts类型体操 enum num{One &#x3D; 1,Two &#x3D; 2} ,type UniNum &#x3D; keyof typeof  num，问UniNum是什么类型 One | Two的联合类型 </li><li>应用：提高代码的可读性</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">DisposalResultStatus</span> &#123;<br>  <span class="hljs-string">&quot;空跑&quot;</span> = <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&quot;上线&quot;</span> = <span class="hljs-number">2</span>,<br>  <span class="hljs-string">&quot;下线&quot;</span> = <span class="hljs-number">3</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口，接口和类区别-10024"><a href="#接口，接口和类区别-10024" class="headerlink" title="接口，接口和类区别 &#10024;"></a>接口，接口和类区别 &#10024;</h2><ul><li><em><strong>接口</strong></em>：对方法和属性的抽象，描述一个对象相关的属性和方法，但不提供创建的该对象的方法。? 可选，readonly只读的。接口之间可以继承。<br><em><strong>类</strong></em>：具体实现创建对象的方法。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts">接口定义函数<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SearchFunc</span> &#123;<br>  (<span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">mySearch</span>: <span class="hljs-title class_">SearchFunc</span>;<br>mySearch = <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-keyword">let</span> result = source.<span class="hljs-title function_">search</span>(subString);<br>  <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>;<br>&#125;<br><br><br>接口定义类<br>类定义为某个接口是 <span class="hljs-keyword">implements</span>！<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClockInterface</span> &#123;<br>    <span class="hljs-attr">currentTime</span>: <span class="hljs-title class_">Date</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClockInterface</span> &#123;<br>    <span class="hljs-attr">currentTime</span>: <span class="hljs-title class_">Date</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">h</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">m</span>: <span class="hljs-built_in">number</span></span>) &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol><li><em><strong>基础</strong></em>：面向对象程序设计中实现信息封装基础，实现具体创建对象的方法。</li><li><em><strong>定义</strong></em><br>字段：对象有的数据。<br>构造函数：类实例化调用，为对象分配内存。<br>方法：对象要执行的操作。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-comment">// 字段</span><br>    <span class="hljs-attr">engine</span>:string; <span class="hljs-comment">// es2022写法，也可以不写，直接在constructor声明</span><br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">engine:string</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">engine</span> = engine<br>    &#125;<br><br>    <span class="hljs-comment">// 方法</span><br>    <span class="hljs-title function_">disp</span>():<span class="hljs-keyword">void</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;发动机为 : &quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">engine</span>)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="3"><li><em><strong>继承</strong></em>：通过extends字段实现继承，继承后可以调用父类的方法；子类可以对父类方法重写；super调用父类构造函数可以传入参数；</li><li><em><strong>修饰符</strong></em>：private，protect，public。</li><li><em><strong>静态属性</strong></em>：static，在类本身上。</li></ol><h2 id="对ts函数的理解"><a href="#对ts函数的理解" class="headerlink" title="对ts函数的理解"></a>对ts函数的理解</h2><ol><li>定义参数类型、个数和返回值类型。</li><li>可选参数，？。</li><li>函数重载：可以声明多个函数名相同但是输入输出个数、类型的函数，具体实现逻辑还得依靠 | 操作符或者 ？操作符。</li></ol><h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><ul><li>类型的变量，使用以后才能确定的类型。</li><li>提供可复用的功能，一个函数接收数字返回数字类型，接收字符串返回字符串类型时候可以使用泛型。</li><li>进行泛型约束，T extends string | number &#10024;</li></ul>]]></content>
    
    
    <categories>
      
      <category>TS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>es和commonjs模块化区别</title>
    <link href="/2025/04/05/nodejs/es%E5%92%8Ccommonjs%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8C%BA%E5%88%AB/"/>
    <url>/2025/04/05/nodejs/es%E5%92%8Ccommonjs%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="ESM和CJS区别"><a href="#ESM和CJS区别" class="headerlink" title="ESM和CJS区别"></a>ESM和CJS区别</h2><ol><li><strong>用什么加载</strong>:es是使用import和export，commonjs是require和module.exports对象。</li><li><strong>同步和异步</strong>：es的import是异步时加载,有一个独立的模块依赖解析阶段,commonjs的require是同步加载.</li><li><strong>编译时加载、运行时加载</strong>：es模块化是编译时加载,commonjs是运行时加载.编译时加载可以做静态分析来确定依赖关系,tree-shaking去除没用的代码。运行时加载是在代码执行时候才能加载.因为编译时加载,所以import要放在代码顶层作用域.</li><li><strong>值的处理</strong>：commonjs模块引入是对值的浅拷贝(引用值会实时取值),会进行缓存;es模块引入是动态引入,不会缓存,会实时变化,但是是只读的.</li></ol><p>参考:</p><ol><li><a href="https://juejin.cn/post/6996675932710764558">https://juejin.cn/post/6996675932710764558</a></li><li><a href="https://es6.ruanyifeng.com/#docs/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82">https://es6.ruanyifeng.com/#docs/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>nodejs</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>代码输出题总结</title>
    <link href="/2025/04/05/JS/%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2025/04/05/JS/%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span> promise状态最终没落定或者<span class="hljs-keyword">await</span>后面的函数未落定，不会把微任务<br>推到任务队列中。<br><br><span class="hljs-number">2.</span> <span class="hljs-built_in">Promise</span>.all、<span class="hljs-built_in">Promise</span>.race结果确定后，不会影响其他promise的执行。 <br></code></pre></td></tr></table></figure><h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><ol><li><p><strong>对象调用的函数this指向对象,其他指向window.尤其喜欢考对象调用的函数里面再调用函数,其实就是指向window.</strong></p></li><li><p><strong>箭头函数里的this看自己定义所在的全局&#x2F;函数执行上下文,跟随对应的this.跟随函数时候看函数是被对象调用还是全局调用,this指向对象或全局window.</strong></p></li><li><p>fun.call(null), 里面this指向window</p></li><li><p>函数从不属于某一个对象,this的指向取决于在哪调用.</p></li><li><p>匿名函数,立即执行函数就是window调用</p></li><li><p>arguments调用</p></li><li><p>var申明不影响obj的属性,别搞混了!</p></li></ol><h1 id="作用域-变量提升-闭包"><a href="#作用域-变量提升-闭包" class="headerlink" title="作用域,变量提升,闭包"></a>作用域,变量提升,闭包</h1><ul><li>var的变量提升、闭包、词法作用域</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-number">1</span>: 从右往左执行,先执行y=<span class="hljs-number">1</span>,y没用<span class="hljs-keyword">var</span>声明,所以y是全局变量,x是局部变量<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> x = y = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-number">2</span>: 注意如果函数或全局有<span class="hljs-keyword">if</span>等其他大括号包含的<span class="hljs-keyword">var</span>申明,也会提升到函数和全局.<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x); <span class="hljs-comment">// undefined;</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">var</span> x;<br>    &#125;<br>&#125;<br><br><span class="hljs-number">3.</span> 函数声明会提升,函数赋值不会<br><br><span class="hljs-number">4.</span> js中变量的作用域链与定义时的环境有关，与执行时无关<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> temp = <span class="hljs-number">10</span>;<br>    b();<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(temp); <span class="hljs-comment">// 报错 Uncaught ReferenceError: temp is not defined</span><br>&#125;<br>a();<br><br></code></pre></td></tr></table></figure><h1 id="原型-继承"><a href="#原型-继承" class="headerlink" title="原型 &amp; 继承"></a>原型 &amp; 继承</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 所有套路<br><span class="hljs-bullet">1.</span> 构造函数prototype指向原型对象,<br><span class="hljs-bullet">2.</span> 原型对象contructor指向构造函数,<br><span class="hljs-bullet">3.</span> 构造函数创建的实例的<span class="hljs-strong">__proto__</span>指向原型对象.<br><span class="hljs-bullet">4.</span> 构造函数的<span class="hljs-strong">__proto__</span>指向Function.prototype.<br><span class="hljs-bullet">5.</span> Function,Object的<span class="hljs-strong">__proto__</span>也指向Function.prototype.<br><span class="hljs-bullet">6.</span> 原型对象的<span class="hljs-strong">__proto__</span>指向Object.prototype,再proto指向null.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>迭代器</title>
    <link href="/2025/04/05/JS/8.%E9%81%8D%E5%8E%86%E5%99%A8/"/>
    <url>/2025/04/05/JS/8.%E9%81%8D%E5%8E%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol><li>一个接口，为不同数据结构提供统一的遍历访问机制，一般是给for…of消费。</li><li>遍历过程：遍历器本身是一个指针对象，有一个next方法，调用一次返回数据结构<br>{value:xxx，done:xxx}，done表示数据结构是否遍历完。</li></ol><h2 id="默认的Iterator"><a href="#默认的Iterator" class="headerlink" title="默认的Iterator"></a>默认的Iterator</h2><ol><li>默认在数据结构的[Symbol.iterator]属性上，该属性本身是一个遍历器生成函数，调用该函数生成遍历器。</li><li>Array、set、map、string、arguments类数组。</li></ol><h2 id="调用iterator的场合"><a href="#调用iterator的场合" class="headerlink" title="调用iterator的场合"></a>调用iterator的场合</h2><ol><li>解构赋值</li><li>扩展运算符</li><li>for of</li><li>遍历set、map</li></ol><h2 id="遍历器对象的return-和throw"><a href="#遍历器对象的return-和throw" class="headerlink" title="遍历器对象的return()和throw()"></a>遍历器对象的return()和throw()</h2><ol><li>return：for of提前退出，比如<strong>break</strong>或者<strong>抛出错误</strong>时候，会调用return方法。</li><li>throw()方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Set、Map</title>
    <link href="/2025/04/05/JS/7.Set%E3%80%81Map/"/>
    <url>/2025/04/05/JS/7.Set%E3%80%81Map/</url>
    
    <content type="html"><![CDATA[<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol><li>new Set(arr);传入一个数组或者其他<strong>有iterable接口</strong>的其他数据结构。他的成员都是<strong>唯一值，没有重复值。</strong></li></ol><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">let</span> <span class="hljs-keyword">set</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);<br><span class="hljs-keyword">let</span> arr1 = [...<span class="hljs-keyword">set</span>];<br><span class="hljs-keyword">let</span> arr2 = []<br><br></code></pre></td></tr></table></figure><h2 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h2><ol><li>size：个数，不是函数。</li><li>add(value)：返回set本身，可以链式调用。</li><li>delete(value)：返回布尔值，是否删除成功。</li><li>clear()：清空。</li><li>has(value)：返回布尔值。</li></ol><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ol><li><strong>Set.prototype.keys() &#x3D; Set.prototype.values()、Set.prototype.entries()</strong>，返回遍历器对象，其实默认也是返回遍历器对象。</li></ol><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lasso">for(<span class="hljs-keyword">let</span> i of <span class="hljs-built_in">set</span>.values())&#123;<br>    console.<span class="hljs-keyword">log</span>(i);<br>&#125;<br><br>for(<span class="hljs-keyword">let</span> i of <span class="hljs-built_in">set</span>)&#123;<br>    console.<span class="hljs-keyword">log</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>forEach(key,value)</strong>：等同于values，set的key和value值是一样的。</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">set.forEach(<span class="hljs-function"><span class="hljs-params">(key,value)</span>=&gt;</span>&#123;&#125;);<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>扩展运算符（</strong>…<strong>）</strong>：</li></ol><ul><li>扩展运算符内部调用for of。</li></ul><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cos">let arr = [.<span class="hljs-built_in">..set</span>]<span class="hljs-comment">;</span><br><br>let <span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Set</span>([.<span class="hljs-built_in">..set</span>].map((<span class="hljs-keyword">x</span>)=&gt;<span class="hljs-keyword">x</span>*<span class="hljs-number">2</span>))<span class="hljs-comment">;</span><br><br><span class="hljs-comment">// 并集</span><br><span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Set</span>([.<span class="hljs-built_in">..set</span>1,.<span class="hljs-built_in">..set</span>2])<span class="hljs-comment">;</span><br><br><span class="hljs-comment">// 交集</span><br><span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Set</span>([.<span class="hljs-built_in">..set</span>1].filter((<span class="hljs-keyword">x</span>)=&gt;set2.has(<span class="hljs-keyword">x</span>)))<span class="hljs-comment">;</span><br><br><span class="hljs-comment">// 差集</span><br><span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Set</span>([.<span class="hljs-built_in">..set</span>1].filter((<span class="hljs-keyword">x</span>)=&gt; !set2.has(<span class="hljs-keyword">x</span>)))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h1 id="weakSet"><a href="#weakSet" class="headerlink" title="weakSet"></a>weakSet</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><ol><li>成员只能是对象或symbol值，都是弱引用，即垃圾回收机制不会考虑weakSet对该对象的引用，如果其他对象都不对该对象引用，垃圾回收机制会自动回收该对象的内存。</li></ol><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><h2 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h2><ol><li>更完整的键值对，object只是<code>字符串 - 值</code></li></ol><h2 id="属性和方法-1"><a href="#属性和方法-1" class="headerlink" title="属性和方法"></a>属性和方法</h2><ol><li>size</li><li>Map.prototype.set(key,value)</li><li>Map.prototype.get(key)</li><li>Map.prototype.has(key)</li><li>Map.prototype.delete(key)</li><li>Map.prototype.clear()</li></ol><h2 id="遍历方法（遍历顺序是插入顺序）"><a href="#遍历方法（遍历顺序是插入顺序）" class="headerlink" title="遍历方法（遍历顺序是插入顺序）"></a>遍历方法（遍历顺序是插入顺序）</h2><ol><li><strong>Map.prototype.keys()、Map.prototype.values()、Map.prototype.entries()</strong></li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(let i of map.keys()</span></span>)<br><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(let i of map.values()</span></span>)<br><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(let [key,value] of map.entries()</span></span>)<br><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(let [key,value] of map)</span></span> <span class="hljs-comment">// 默认是entries</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li>forEach</li></ol>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>worker</title>
    <link href="/2025/04/05/JS/6.worker/"/>
    <url>/2025/04/05/JS/6.worker/</url>
    
    <content type="html"><![CDATA[<h1 id="webWorker"><a href="#webWorker" class="headerlink" title="webWorker"></a>webWorker</h1><ul><li><a href="https://juejin.cn/post/7139718200177983524?searchId=20241014225402B164DD668FBB1DDDC2C5#heading-0">https://juejin.cn/post/7139718200177983524?searchId=20241014225402B164DD668FBB1DDDC2C5#heading-0</a></li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol><li>在js主线程外开辟一个worker线程，让js有执行多线程的能力。在里面执行一段耗时的js代码，在worker线程执行完后将结果返回给主线程。主线程专注处理业务逻辑。</li><li>注意：webworker和当前页面上下文不同，无法访问window对象。无法操作dom，无法访问document对象。存在一个顶级对象self。</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>创建：let worker &#x3D; new Worker(path,{type:module});module类型是用import，export来引入导出。</li><li>主线程和worker线程都是监听message收取数据，postmessage发送数据。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.js（主线程）</span><br><br><span class="hljs-keyword">const</span> myWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;/worker.js&#x27;</span>); <span class="hljs-comment">// 创建worker</span><br><br>myWorker.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123; <span class="hljs-comment">// 接收消息</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>); <span class="hljs-comment">// Greeting from Worker.js，worker线程发送的消息</span><br>&#125;);<br><br><span class="hljs-comment">// 这种写法也可以</span><br><span class="hljs-comment">// myWorker.onmessage = e =&gt; &#123; // 接收消息</span><br><span class="hljs-comment">//    console.log(e.data);</span><br><span class="hljs-comment">// &#125;;</span><br><br>myWorker.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Greeting from Main.js&#x27;</span>); <span class="hljs-comment">// 向 worker 线程发送消息，对应 worker 线程中的 e.data</span><br><br>---------------<br><br><span class="hljs-comment">// worker.js（worker线程）</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123; <span class="hljs-comment">// 接收到消息</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>); <span class="hljs-comment">// Greeting from Main.js，主线程发送的消息</span><br>    self.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Greeting from Worker.js&#x27;</span>); <span class="hljs-comment">// 向主线程发送消息</span><br>&#125;);<br><br><br></code></pre></td></tr></table></figure><ol start="3"><li>关闭worker线程:<br>主线程关闭：不影响子线程事件循环执行完，但子线程postmessage无法传递数据。<br>子线程关闭：宏任务不会执行。</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><br>worker.terminate()<span class="hljs-comment">;</span><br><br>self.close()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>主线程子线程不能传递的数据？</li></ol><ul><li>error，function对象；dom对象；</li></ul><h1 id="SharedWorker"><a href="#SharedWorker" class="headerlink" title="SharedWorker"></a>SharedWorker</h1>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>settimeout</title>
    <link href="/2025/04/05/JS/5.settimeout/"/>
    <url>/2025/04/05/JS/5.settimeout/</url>
    
    <content type="html"><![CDATA[<h2 id="setTimeout注意事项"><a href="#setTimeout注意事项" class="headerlink" title="setTimeout注意事项"></a>setTimeout注意事项</h2><ul><li>setTimeout的回调相等于全局调用</li></ul><ol><li>setTimeout里面传入一个对象里面的函数,其实就相当于把函数直接写在里面,(函数从不属于某个对象)所以一般要用一个箭头函数包装起来<br>setTimeout(obj.fun,2000) &#x2F;&#x2F; 两秒后执行<br>setTimeout(obj.fun(),2000) &#x2F;&#x2F; 立即执行</li><li><code>不是箭头函数情况</code>:setTimeout是window下 全局定义的函数,setTimeout里面的函数this没赋值往外找就会找到window对象.<br> <code>箭头函数情况</code>:this指向定义箭头函数的this.(箭头函数只是作为参数传给setTimeout,箭头函数还是在所在范围(如对象)里面定义的.)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span>;<br>  <span class="hljs-keyword">var</span> obj = &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>,<br>      <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br>         <span class="hljs-built_in">clearInterval</span>(timer);<br>          timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">//window</span><br>          &#125;, <span class="hljs-number">1000</span>)<br>     &#125;<br> &#125;<br><br><span class="hljs-comment">// 情况1:setTimeout是全局函数,里面的函数是在全局调用,this指向window</span><br><br><br><br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span>;<br>  <span class="hljs-keyword">var</span> obj = &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>,<br>      <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br>         <span class="hljs-built_in">clearInterval</span>(timer);<br>          timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>              <span class="hljs-title function_">fn</span>();  <span class="hljs-comment">//fn里面的this也是window</span><br>          &#125;, <span class="hljs-number">1000</span>)<br>     &#125;<br> &#125;<br><br><span class="hljs-comment">// 情况2(同情况6):setTimeout是全局函数,里面的函数是在全局调用,this指向window</span><br><br><br><br><br><br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span>;<br>        <span class="hljs-keyword">var</span> obj = &#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>,<br>            <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br>                <span class="hljs-built_in">clearInterval</span>(timer);<br>                timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                     <span class="hljs-keyword">let</span>  <span class="hljs-title function_">a</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);   <span class="hljs-comment">//window</span><br>                    &#125;<br>                    <span class="hljs-title function_">a</span>()     <br>                &#125;, <span class="hljs-number">1000</span>)<br>            &#125;<br>        &#125;<br>        obj.<span class="hljs-title function_">fn</span>()<br><br><span class="hljs-comment">// 情况3:箭头函数this是在定义时候往外找,里面function的this是全局</span><br><br><br><br><br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;window&#x27;</span>;<br><br><span class="hljs-keyword">var</span> obj = &#123; <br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>,<br>        <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br>                <span class="hljs-built_in">clearInterval</span>(timer);<br>                timer = <span class="hljs-built_in">setInterval</span>( <span class="hljs-function">() =&gt;</span> &#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);   <span class="hljs-comment">//obj</span><br>                &#125;, <span class="hljs-number">1000</span>)<br>            &#125;<br>        &#125;<br><br><span class="hljs-comment">// 情况4:箭头函数找他定义的地方,注意箭头函数只是作为参数传入到</span><br><span class="hljs-built_in">setTimeout</span>中,定义还是在对象中定义的.<br><br><br><br><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>  <br><span class="hljs-keyword">var</span> obj = &#123;  <br>  <span class="hljs-attr">a</span>: <span class="hljs-number">20</span>,  <br>  <span class="hljs-attr">say</span>:<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)  <br>  &#125;  <br>&#125;  <br>obj.<span class="hljs-title function_">say</span>()   <br><span class="hljs-keyword">var</span> anotherObj=&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">30</span>&#125;   <br>obj.<span class="hljs-property">say</span>.<span class="hljs-title function_">apply</span>(anotherObj)<br><br><span class="hljs-comment">// 情况5:箭头函数定义在全局(注意只有函数执行上下文和全局执行上下文!函数中的this指向的是</span><br>运行时的上下文)<br><br><br><br><br>onInput.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>        &#125;,<span class="hljs-number">1000</span>)<br><br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>            <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span><br>                args = <span class="hljs-variable language_">arguments</span><br>                <span class="hljs-keyword">if</span> (timer) &#123;<br>                    <span class="hljs-built_in">clearTimeout</span>(timer)<br>                &#125;<br>                timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                    <span class="hljs-title function_">fn</span>()<br>                &#125;, wait);<br>            &#125;<br>        &#125;<br><br><span class="hljs-comment">// 情况6:fn是在全局环境下调用，this默认是window</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件</title>
    <link href="/2025/04/05/JS/4.%E6%96%87%E4%BB%B6/"/>
    <url>/2025/04/05/JS/4.%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="https://mp.weixin.qq.com/s/IarZDzv9dLD5suL5zdZNcQ">https://mp.weixin.qq.com/s/IarZDzv9dLD5suL5zdZNcQ</a></li></ul><p><img src="/2025/04/05/JS/4.%E6%96%87%E4%BB%B6/image-2.png" alt="alt text"></p><ul><li>blob可以转换成url</li><li>blob转换成arrayBuffer可以读写操作。</li></ul><h1 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>一个专门的支持文件操作的<em><strong>二进制对象</strong></em>。</li><li>Blob对象无法修改，只能用FileReader读取。</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>URL.createObjectURL(blob)，将二进制对象转换为一个路径<br>内置了slice方法截取部分<br><img src="/2025/04/05/JS/4.%E6%96%87%E4%BB%B6/image.png" alt="alt text"></p><h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><ul><li>blob的特殊类型，只存在于浏览器环境，不在node环境。</li><li>获取方式：input选择，文件拖放操作。</li><li><img src="/2025/04/05/JS/4.%E6%96%87%E4%BB%B6/image-1.png" alt="alt text">size，type是blob的属性，file除此之外还有其他一些属性。</li></ul><h1 id="fileReader"><a href="#fileReader" class="headerlink" title="fileReader"></a>fileReader</h1><h2 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h2><ul><li>提供读取Blob的方法</li></ul><h1 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h1><h2 id="基础-3"><a href="#基础-3" class="headerlink" title="基础"></a>基础</h2><ul><li>ArrayBuffer表示二进制数据的缓冲区，是一个字节数组，不能直接操作该对象，需要通过类型化数组（<em><strong>TypedArray</strong></em>）对象或者DataView对象操作。</li></ul><!-- 类型化数组和DataView区别：前者类似ts的数组（数据都相同类型），后者为js数组（数据可不同类型） --><h1 id="TypedArray"><a href="#TypedArray" class="headerlink" title="TypedArray"></a>TypedArray</h1><h2 id="基础-4"><a href="#基础-4" class="headerlink" title="基础"></a>基础</h2><ul><li>描述了底层二进制数据缓冲区的类数组视图。</li><li>只是一个概念，包含Int8Array，Uint8Array，Int32Array等九个子类，用九个视图对象读取ArrayBuffer。</li><li>Int8Array表示数组每个元素为8位，一个字节。Int32Array表示数组每个元素为32位，4个字节。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>promise.generator.async异步解决方案.md</title>
    <link href="/2025/04/05/JS/3.promise.generator.async%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2025/04/05/JS/3.promise.generator.async%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="期约"><a href="#期约" class="headerlink" title="期约"></a>期约</h2><ol><li>期约本质是一个有状态的对象.<strong>里面保存一个未来才会结束的事件的结果</strong>,创建时候要传入执行器函数.</li><li>异步操作成功,期约状态变为resolved,有对应的值;异步操作失败,期约状态变为rejected,有对应失败的原因.</li><li>三种状态:pending,resolved(fulfilled),rejected.状态一但发生改变则不能再修改.</li><li>创建期约时候会传入一个执行器函数,执行器函数是用来<strong>初始化异步操作</strong>和<strong>改变期约的状态</strong>,执行器函数里面的代码是同步执行.</li><li>缺点:<strong>第一</strong>promise不能中断,<strong>第二</strong>状态处于pending时,无法得知执行的阶段.<strong>第三</strong>不设置回调时,promise内部的错误无法反馈到外部，就是只能被promise.catch捕获，不能被try catch捕获。</li></ol><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><ol><li>实例化一个成功的期约,期约的值为传入的第一个参数.</li></ol><ul><li>传入的参数是一个期约,则幂等性保留传入期约的状态.</li><li>其他情况都会封装为一个成功的期约,包括错误对象.</li></ul><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><ol><li>实例化一个拒绝的期约并抛出错误,该错误不能被try&#x2F;catch捕获,只能通过拒绝处理程序捕获.</li></ol><ul><li>无论传入什么值都会是拒绝的期约.</li></ul><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><ol><li>添加处理程序,接受<strong>两个函数参数</strong>,onResolved和onRejected函数,分别在期约状态变为成功和失败后执行.</li><li>then()会<strong>返回</strong>一个新的期约.</li></ol><ul><li>无论是错误处理程序还是正确处理程序的返回值都会通过Promise.resolve()封装</li><li>若没有返回值则是promise.resolve(undefined)</li><li>若没有处理程序则包装上一个期约的值.</li><li>处理程序抛出错误则返回错误的期约.</li></ul><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><ol><li>语法糖,等同于then(null,onRejected)</li></ol><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><ol><li>无论期约状态变成成功或是失败都会执行.</li><li>也会返回一个期约,与then,catch不同,该方法返回父期约的值.</li><li>只有处理程序返回的是抛出错误,错误的期约,pending状态的期约,该方法才会返回错误期约和pending的期约.</li></ol><h2 id="执行时期"><a href="#执行时期" class="headerlink" title="执行时期"></a>执行时期</h2><ol><li>期约状态落定后,处理程序会进入微任务队列等待执行,不会立即执行.</li><li>处理程序中抛出的错误不会阻塞同步代码,因为是在任务队列中抛出的</li></ol><h2 id="期约连锁"><a href="#期约连锁" class="headerlink" title="期约连锁"></a>期约连锁</h2><ol><li>因为期约的实例方法then,catch,finally都会返回一个新的期约对象,新期约又有自己的实例方法.</li><li>将异步任务串行化,解决<strong>回调地狱</strong>问题.</li></ol><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><ol><li>将多个期约合成一个期约,传入参数是可迭代对象,<strong>返回一个新期约</strong>.</li><li>有一个包含的期约状态为待定,则合成的期约状态为待定;有一个包含的期约状态为拒绝,则合成的期约为拒绝.第一个拒绝的期约会作为合成期约的拒绝值.</li><li>如果所有包含的期约都解决,则合成的期约值就是包含期约值的数组.</li><li>ps:期约值落定后不会影响其他期约正常的拒绝操作.</li></ol><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><ol><li>是一组集合中最先解决或拒绝的期约的镜像,接受的参数为可迭代的对象,返回一个新期约.</li><li>与all不同,不会区别对待pending和rejected状态的期约,只要是第一个落定的期约,race就会包装其解决值或拒绝理由并返回新期约.</li><li>ps:期约值落定后不会影响其他期约正常的拒绝操作.</li></ol><h2 id="场景题-Promise-allSettled"><a href="#场景题-Promise-allSettled" class="headerlink" title="场景题,Promise.allSettled()"></a>场景题,Promise.allSettled()</h2><ul><li>静态方法将一个 Promise 可迭代对象作为输入，并返回一个单独的 Promise。当所有输入的 Promise 都已敲定时（包括传入空的可迭代对象时），返回的 Promise 将被兑现，并带有描述每个 Promise 结果的对象数组。</li></ul><h1 id="async"><a href="#async" class="headerlink" title="async"></a>async</h1><h2 id="异步函数async"><a href="#异步函数async" class="headerlink" title="异步函数async"></a>异步函数async</h2><ol><li>async声明异步函数(函数声明,函数表达式,箭头函数,方法),异步函数始终返回期约对象,返回值会经Promise.Resolve()封装.</li><li>与期约处理程序一样,异步函数中抛出错误会返回拒绝的期约.</li></ol><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><ol><li>await暂定异步函数代码的执行,让出js执行线程.</li><li>await后表达式如果是非期约的值,则经过Promise.resolve()封装,返回的值是期约的值.</li><li>await值可用时,会把异步函数推到任务队列中等待执行.</li></ol><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"> <span class="hljs-attribute">注意点</span><span class="hljs-punctuation">:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">不管await后面等什么,即使是非期约的值,也会将async部分推到微任务队列中</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">一个函数中,如果有异步操作,异步会将回调函数推到任务队列中,该函数同步执行完后就会</span><br>  销毁该函数的执行上下文栈.<br></code></pre></td></tr></table></figure><h1 id="Generator基础"><a href="#Generator基础" class="headerlink" title="Generator基础"></a>Generator基础</h1><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>函数名和function之间有一个*,它是一个状态机,内部封装了多个状态.内部有yield.</p><h2 id="next执行"><a href="#next执行" class="headerlink" title="next执行"></a>next执行</h2><p>generator函数执行不会返回函数执行的结果,而是返_回一个<em><strong>指向内部的指针</strong></em>,也就是遍历器对象.调用遍历器对象的next方法,内部指针就从函数头部或者上次暂定的地方继续执行,直到下一个yeild或者return语句.</p><h2 id="yeild"><a href="#yeild" class="headerlink" title="yeild"></a>yeild</h2><p>遇到yeild语句就会暂定操作,并返回yeild后面的表达式,作为返回对象的value值.</p><h2 id="next传参"><a href="#next传参" class="headerlink" title="next传参"></a>next传参</h2><p>next方法可以带一个参数，该参数就会被当作<em><strong>上一个yield表达式</strong></em>的返回值。</p><blockquote><p>执行到一个yeild,yeild后的值就是这个next的值.下一个next传的值是给上一个yeild,自己往下执行到新的yeild,新yeild返回值给自己.</p></blockquote><h1 id="Generator函数的异步应用"><a href="#Generator函数的异步应用" class="headerlink" title="Generator函数的异步应用"></a>Generator函数的异步应用</h1><h2 id="协程和Generator"><a href="#协程和Generator" class="headerlink" title="协程和Generator"></a>协程和Generator</h2><ol><li>协程是多个线程互相协作，完成异步任务。Generator函数是协程在es6中的实现,整个Generator函数就是一个异步任务,异步暂停的地方会用yield语句标明.</li></ol><h2 id="Generator函数的数据交换和错误处理"><a href="#Generator函数的数据交换和错误处理" class="headerlink" title="Generator函数的数据交换和错误处理"></a>Generator函数的数据交换和错误处理</h2><ol><li>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</li></ol><h2 id="异步任务的封装-前两点是介绍基础-这点开始实操"><a href="#异步任务的封装-前两点是介绍基础-这点开始实操" class="headerlink" title="异步任务的封装(前两点是介绍基础,这点开始实操)"></a>异步任务的封装(前两点是介绍基础,这点开始实操)</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function* <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-string">&#x27;......&#x27;</span><br>    <span class="hljs-keyword">const</span> result = yield fetch(url)<br>    console.log(result)<br>&#125;<br><br><span class="hljs-keyword">const</span> f = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br>f.next().value<br>.then(response =&gt; response.json())<br>.then(<span class="hljs-keyword">data</span> =&gt; f.next(<span class="hljs-keyword">data</span>))<br></code></pre></td></tr></table></figure><ol><li><code>ps</code>:异步操作简单,但流程管理不便.</li></ol><h2 id="面试题总结"><a href="#面试题总结" class="headerlink" title="面试题总结"></a>面试题总结</h2><h3 id="return-Promise-resolve-resolve-Promise-resolve-123"><a href="#return-Promise-resolve-resolve-Promise-resolve-123" class="headerlink" title="return Promise.resolve() &#x2F; resolve(Promise.resolve(123))"></a>return Promise.resolve() &#x2F; resolve(Promise.resolve(123))</h3><ul><li>如果resolve的是一个promise对象(.then回调里返回一个promise对象),<br>&#x2F;&#x2F; 推迟原因：浏览器会创建一个 PromiseResolveThenableJob 去处理这个 Promise 实例，这是一个微任务。<br>&#x2F;&#x2F; 等到下次循环到来这个微任务会执行，也就是PromiseResolveThenableJob 执行中的时候，因为这个Promise 实例是fulfilled状态，所以又会注册一个它的.then()回调<br>&#x2F;&#x2F; 又等一次循环到这个Promise 实例它的.then()回调执行后，才会注册下面的这个.then(),于是就被推迟了两个时序</li></ul><h2 id="await-promise"><a href="#await-promise" class="headerlink" title="await promise"></a>await promise</h2><ul><li>如果promise是pending状态(没有调用resolve或reject),reject状态未被捕获,则await后面的代码不会进入微任务队列中.</li></ul>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>执行上下文、作用域、闭包.md</title>
    <link href="/2025/04/05/JS/2.%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%97%AD%E5%8C%85/"/>
    <url>/2025/04/05/JS/2.%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p><a href="https://fe.ecool.fun/topic/c137050b-10f5-4a4f-9941-820ad7a9894d?orderBy=updateTime&order=desc&titleKey=%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87">https://fe.ecool.fun/topic/c137050b-10f5-4a4f-9941-820ad7a9894d?orderBy=updateTime&amp;order=desc&amp;titleKey=%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87</a></p><ul><li>代码运行环境的抽象概念</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>全局上下文:this的值指向windows对象,代码执行时创建,关闭浏览器是和销毁.</li><li>函数上下文:有多个,函数被调用时候才会创建函数上下文.</li><li>(Eval 函数执行上下文)</li></ol><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><ul><li><em><strong>存储创建的上下文</strong></em></li></ul><ol><li>js引擎执行脚本代码时,会创建<strong>全局上下文</strong>并将其压入栈中.</li><li>每执行一个函数时,会创建<strong>函数上下文</strong>,并将其压入栈中.</li><li>js引擎会执行位于<strong>栈顶</strong>的上下文,执行完毕后的上下文弹出栈,继续执行下一个上下文.</li></ol><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol><li>确定<strong>this</strong>指向.</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">所以<span class="hljs-keyword">this</span>是函数被调用时创建上下文时候才会确定,<br>特殊情况:箭头函数本身没有<span class="hljs-keyword">this</span>,与定义箭头函数<br>的上下文的<span class="hljs-keyword">this</span>指向相同,在定义时候就确定了<span class="hljs-keyword">this</span>指向.<br></code></pre></td></tr></table></figure><ol start="2"><li>创建<strong>词法环境</strong></li></ol><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-number">1</span>. 登记<span class="hljs-keyword">let</span>,const,类但不初始化不赋值,函数声明<br>并初始化并赋值.所以<span class="hljs-keyword">let</span>,const也会变量提升,只是<br>因为暂时性死区,不能在声明之前使用<span class="hljs-keyword">let</span>,const的变量.<br><span class="hljs-number">2</span>. 对重复变量进行处理.<br><span class="hljs-number">3</span>. 确定外部环境的引用.<br><br>ps:函数参数arguments也是在此登记.<br></code></pre></td></tr></table></figure><ol start="3"><li>创建<strong>变量环境</strong>(本质也是词法环境一种)</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">与词法环境创建相同,但只对<span class="hljs-keyword">var</span>声明的变量登记并<br>初始化为<span class="hljs-literal">undefined</span>,但没赋值.<br><br>造成了变量提升<br></code></pre></td></tr></table></figure><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p><a href="https://blog.csdn.net/feral_coder/article/details/106447013">https://blog.csdn.net/feral_coder/article/details/106447013</a></p><ul><li>js引擎遇到块级作用域会在词法环境单独开一个区域,<strong>词法环境内部用栈结构存储</strong>块级作用域里的变量.<code>块级作用域变量会在栈顶</code>,优先访问.<br><img src="/2025/04/05/JS/2.%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%97%AD%E5%8C%85/image-3.png" alt="alt text"></li><li>块级作用域中变量使用完后会从词法环境的栈中弹出.</li></ul><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="作用域-1"><a href="#作用域-1" class="headerlink" title="作用域"></a>作用域</h2><p><a href="https://fe.ecool.fun/topic/fa224d36-147a-4251-8033-dc1462e9527e?orderBy=updateTime&order=desc&titleKey=%E4%BD%9C%E7%94%A8%E5%9F%9F">https://fe.ecool.fun/topic/fa224d36-147a-4251-8033-dc1462e9527e?orderBy=updateTime&amp;order=desc&amp;titleKey=%E4%BD%9C%E7%94%A8%E5%9F%9F</a></p><ol><li>变量和函数能被访问的区域.</li><li>全局作用域:不在函数中或是大括号中声明的变量，都是在全局作用域<br>函数作用域:在函数内部声明的变量<br>块级作用域:大括号内let const声明的变量.</li><li>词法作用域:又称为静态作用域,<strong>变量或函数在创建时候作用域就已经确定,而不是执行时候,但变量的<em>值</em>在执行时候才会确定,对应执行上下文中变量对象(es3说法,es5后就是词法环境)</strong></li></ol><blockquote><p>  作用域和执行上下文区别理解:作用域是变量或函数可访问的区域,是静态的(编写代码时候就已经确定了)<br>  执行上下文是一段代码的抽象环境,是动态的,执行时候才会创建执行上下文,在其中会注册变量并给变量赋值.<br> 词法环境创建时候会确定对外部环境的引用,所以一个变量的作用域涉及到多个执行上下文</p></blockquote><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ol><li>本质:是一个函数,是指引用了另一个函数作用域中的变量的函数,或者说是一个函数与其外部函数词法环境捆绑到一起.</li><li>原理(也是作用域链原理):在<code>定义</code>函数时候,会创建其作用域链,当前作用域链是对外部函数词法环境和全局词法环境的引用,保存在<code>[[scope]]</code>中.调用该函数时候会<em><strong>创建相应的执行上下文,复制<code>[[scope]]</code>值创建作用域链</strong></em>,并把执行上下文的词法环境推到作用域链最前端.<em><strong>闭包就是函数作用域链中有其他函数作用域</strong></em></li><li>作用:</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1.创建私有变量<br><br>2.延长变量的生命周期<br></code></pre></td></tr></table></figure><ol start="3"><li>PS:外部函数词法环境不会被垃圾回收机制回收,因为闭包函数作用域链对其词法环境有引用.</li></ol><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul><li>默认默认默认为window! 对象调用才指向对象!</li><li>箭头函数this往外找时候,是找函数的this或者是全局的this(因为函数执行上下文或者全局执行上下文),主要是看<em><strong>函数是被对象调用,还是全局调用</strong></em>,还是call bind apply调用,还是构造函数调用.</li></ul>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>对象基础、创建、继承</title>
    <link href="/2025/04/05/JS/1.%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E3%80%81%E5%88%9B%E5%BB%BA%E3%80%81%E7%BB%A7%E6%89%BF/"/>
    <url>/2025/04/05/JS/1.%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E3%80%81%E5%88%9B%E5%BB%BA%E3%80%81%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="对象基础"><a href="#对象基础" class="headerlink" title="对象基础"></a>对象基础</h1><h2 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h2><ol><li>数据类型</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> Configurable:该属性是否可被删除,特性是否<br>可被修改<br><span class="hljs-bullet">2.</span> Enumerable:该属性是否可被遍历<br><span class="hljs-bullet">3.</span> writeable:该属性值是否可被修改<br><span class="hljs-bullet">4.</span> value:属性的值.<br></code></pre></td></tr></table></figure><ol start="2"><li>访问器属性</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> Configurable:该属性是否可被删除,特性是否可被修改<br><span class="hljs-bullet">2.</span> Enumerable:该属性是否可被遍历<br><span class="hljs-bullet">3.</span> Get获取函数,读取该属性时候调用<br><span class="hljs-bullet">4.</span> Set设置函数,写入属性时候调用<br></code></pre></td></tr></table></figure><h2 id="修改特性"><a href="#修改特性" class="headerlink" title="修改特性"></a>修改特性</h2><ol><li>Object.defineProperty(对象,属性,{writeable:false,value:123})</li><li>Object.defineProperties(person,{<br> year:{<br> configurable:false<br> value:999<br> },<br> month:{<br> value:123<br> }<br>})</li></ol><h2 id="读取特性"><a href="#读取特性" class="headerlink" title="读取特性"></a>读取特性</h2><ol><li>Object.getOwnPropertyDescriptor(对象,属性名)</li><li>Object.getOwnPropertyDescriptors(对象)</li></ol><h2 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h2><ol><li>Object.assign把源对象的属性复制到目标对象上,源对象本身且可遍历的属性才会复制,为浅拷贝,相同属性后面会覆盖前面.</li><li>Object.assign(person,person1,person2)</li></ol><h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a><code>Object.is</code></h2><ol><li>+0 &#x3D;&#x3D;&#x3D; 0,-0 !&#x3D;&#x3D; 0,-0 !&#x3D;&#x3D; +0,正确的0相等判断</li><li>NaN &#x3D;&#x3D;&#x3D; NaN相等判断</li></ol><h2 id="对象增强语法"><a href="#对象增强语法" class="headerlink" title="对象增强语法"></a>对象增强语法</h2><ol><li>同名属性名简写</li><li>方法简写</li><li>动态属性</li></ol><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span> person =&#123;<br>   <span class="hljs-built_in"> name</span>:<span class="hljs-string">&#x27;cc&#x27;</span>,<br>    age: <span class="hljs-string">&#x27;26&#x27;</span><br>&#125;<br><span class="hljs-number">1</span>. 基础<br><span class="hljs-keyword">let</span>&#123;age<span class="hljs-built_in">,name</span>&#125; = person<br><span class="hljs-number">2</span>. 变量名和属性名不同<br><span class="hljs-keyword">let</span> &#123;age:ageKey<span class="hljs-built_in">,name</span>:nameKey&#125; = person<br><span class="hljs-number">3</span>. 事先未声明的变量要用()来赋值<br>(&#123;age:ageKey<span class="hljs-built_in">,name</span>:nameKey&#125; =person)<br></code></pre></td></tr></table></figure><h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ol><li><strong>创建过程</strong>：函数体内返回一个对象,未解决创建的对象是何种类型.</li></ol><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><ol><li>要使用new操作符</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">new操作符流程<br><span class="hljs-bullet">1.</span> 在内存中创建一个新对象,<br>将这新对象内部的<span class="hljs-strong">__proto__</span>属性赋值为构造函数的原型.<br><span class="hljs-bullet">2.</span> 构造函数内部的this赋值为新对象<br><span class="hljs-bullet">3.</span> 执行构造函数内的代码<br><span class="hljs-bullet">4.</span> 如果函数返回结果是对象,则返回该对象,否则返回新对象.<br></code></pre></td></tr></table></figure><ol start="2"><li>this指向:new绑定优先级 &gt; 显示绑定优先级 &gt; 隐式绑定优先级 &gt; 默认绑定优先级</li><li><strong>创建过程</strong>：new 一个构造函数返回新创建的对象，缺点是在对象本身上放共有方法。</li></ol><h2 id="原型模式-我真的要看吐原型的基础知识了"><a href="#原型模式-我真的要看吐原型的基础知识了" class="headerlink" title="原型模式(我真的要看吐原型的基础知识了)"></a>原型模式(我真的要看吐原型的基础知识了)</h2><ul><li><strong>创建过程</strong>：Object.create一个对象创建出一个新的对象，对象上属性要额外添加。</li></ul><ol><li>一个函数会有prototype指针指向原型对象,原型对象有constructor指针指向构造函数,实例和构造函数没有直接的关系,只有__proto__可以访问构造函数的原型.</li><li>不是所有浏览器都支持__proto__属性.</li></ol><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-number">1.</span> isPrototypeOf会判断 传入的对象的原型 <br>是否是调用isPrototypeOf的这个对象.<br><span class="hljs-number">2.</span> <span class="hljs-type">Object</span>.getPrototypeOf()返回参数的[[prototype]]<br><span class="hljs-number">3.</span> <span class="hljs-type">Object</span>.setPrototypeof()不建议使用,<br>使用<span class="hljs-type">Object</span>.create()将传入的参数作为原型对象并创建新对象返回.<br></code></pre></td></tr></table></figure><ol start="3"><li>原型层级访问:会先从实例本身搜索,没有的话则去原型对象<code>__proto__</code>上搜索.即使实例本身该属性值为null也会搜索成功,除非用delete删除该属性.</li><li><code>判断属性是在原型上还是在实例上</code>:hasOwnProperty()属性在实例上返回true,in属性在原型上,实例上都返回true.</li><li><code>遍历</code>:for in 只要属性可遍历访问的原型实例上都返回.Object.keys(),Object.values(),Object.entries()返回的都是本身属性,值.</li><li>往构造函数上加属性时候容易重写,重写需要注意constructor指回构造函数并且特性是不可枚举的.</li><li><code>创建实例后,实例的原型对象指向不会改变,即使后面构造函数原型对象被修改.</code></li></ol><h2 id="构造函数-原型-模式"><a href="#构造函数-原型-模式" class="headerlink" title="构造函数 + 原型 模式"></a>构造函数 + 原型 模式</h2><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><ol><li>子构造函数原型对象被赋值为父构造函数的实例,因此可以继承父构造函数的公有方法.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">super</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span> = <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sub</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span> = <span class="hljs-literal">false</span><br>&#125;<br>sub.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-variable language_">super</span>()<br>sub.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getproperty</span> = ...... <br><span class="hljs-comment">//子类构造函数的方法要在原型赋值后添加.</span><br></code></pre></td></tr></table></figure><ol start="2"><li>原型链问题:原型对象为父构造函数的实例,实例上的引用值会被共用.<br>     创建子构造函数的实例时候无法传参数给父构造函数.</li></ol><h2 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h2><ol><li>在子构造函数中调用父构造函数,解决原型包含引用值和无法传参给父构造函数的问题.</li></ol><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">function <span class="hljs-function"><span class="hljs-keyword">sub</span></span>()&#123;<br>    super.call(this,...arguments)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>盗用构造函数方法无法访问父类原型上的方法.</li></ol><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><ol><li>结合原型链继承和盗用构造函数的方法.原型链继承原型上的属性和方法,盗用构造函数继承实例属性.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">super</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span> = <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sub</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-variable language_">arguments</span>) <span class="hljs-comment">//获得父类属性,盗用构造函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">//定义子类属性</span><br>&#125;<br>sub.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-variable language_">super</span>() <span class="hljs-comment">//获得父类的方法,原型链继承</span><br>sub.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getproperty</span> = ......<span class="hljs-comment">//定义子类的方法</span><br><br></code></pre></td></tr></table></figure><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><ol><li>前面是构造函数之间的继承,有时只需要对象和对象之间的信息共享,将一个对象作为另一个对象的__proto__.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">object</span>(<span class="hljs-params">o</span>)&#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125;;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>&#125;<br><span class="hljs-keyword">let</span> person1 = <span class="hljs-title function_">object</span>(person)<br><span class="hljs-keyword">let</span> person1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(person)<br></code></pre></td></tr></table></figure><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><ol><li>和原型式继承类似,但是会增强对象.</li></ol><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createAnother</span><span class="hljs-params">(o)</span></span>&#123;<br>    <span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">object</span>(o);<br>    person1.method = ...... <span class="hljs-comment">//这里就是增强对象</span><br>    (一般是增强constructor属性)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="寄生式组合继承-终于来到最终完美的继承方法"><a href="#寄生式组合继承-终于来到最终完美的继承方法" class="headerlink" title="寄生式组合继承(终于来到最终完美的继承方法!)"></a>寄生式组合继承(终于来到最终完美的继承方法!)</h2><ol><li>组合式继承缺点:盗用构造函数和创建子类构造函数时候调用两次父类构造函数,且在原型上重复了一遍父类属性.</li><li>思路:不再调用父构造函数,而是获取他的副本,就是采用寄生式继承来继承父类原型,将返回的对象赋值给子类原型.</li></ol><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl">function inherit(super,<span class="hljs-function"><span class="hljs-keyword">sub</span>)</span>&#123;<br>    <span class="hljs-keyword">prototype</span> = Object.create(super.prototype)<br>    prototype.constructor = <span class="hljs-function"><span class="hljs-keyword">sub</span></span><br><span class="hljs-function">    <span class="hljs-title">sub</span>.<span class="hljs-title">prototype</span> = <span class="hljs-title">prototype</span></span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">再盗用构造函数一波就实现了继承.</span><br></code></pre></td></tr></table></figure><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git submodule</title>
    <link href="/2025/04/05/Git/gitSubmodule/"/>
    <url>/2025/04/05/Git/gitSubmodule/</url>
    
    <content type="html"><![CDATA[<h2 id="gitmodules"><a href="#gitmodules" class="headerlink" title=".gitmodules"></a>.gitmodules</h2><ul><li>配置文件，存储子模块的相关信息。在git submodule add后自动生成。文件也像 .gitignore 文件一样受到（通过）git控制。</li></ul><h2 id="git-config"><a href="#git-config" class="headerlink" title=".git&#x2F;config"></a>.git&#x2F;config</h2><ul><li>.git&#x2F;config 文件是 Git 仓库的本地配置文件，存储了远程仓库、分支、子模块等信息。</li></ul><h2 id="git-submodule（git-子模块）"><a href="#git-submodule（git-子模块）" class="headerlink" title="git submodule（git 子模块）"></a>git submodule（git 子模块）</h2><ul><li>将一个git仓库嵌入到另一个git仓库，适用于代码库共享的场景</li></ul><h3 id="添加-Submodule"><a href="#添加-Submodule" class="headerlink" title="添加 Submodule"></a>添加 Submodule</h3><ul><li>要将一个外部仓库作为子模块添加到你的主仓库中</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">git submodule <span class="hljs-built_in">add</span> <span class="hljs-symbol">&lt;repository_url&gt;</span> <span class="hljs-symbol">&lt;path&gt;</span><br></code></pre></td></tr></table></figure><p>会在你的主仓库中创建一个名为 submodule_path 的目录，并将外部仓库克隆到该目录中。</p><h3 id="初始化和更新-Submodule"><a href="#初始化和更新-Submodule" class="headerlink" title="初始化和更新 Submodule"></a>初始化和更新 Submodule</h3><ul><li>当你克隆一个<strong>包含子模块</strong>的仓库时，子模块的内容不会自动克隆。你需要手动初始化和更新子模块</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">submodule </span>init<br>git <span class="hljs-keyword">submodule </span>update<br></code></pre></td></tr></table></figure><h3 id="递归更新子模块"><a href="#递归更新子模块" class="headerlink" title="递归更新子模块"></a>递归更新子模块</h3><p>如果子模块中还嵌套了子模块，可以使用 –recursive 选项：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">git submodule update</span> <span class="hljs-literal">--</span><span class="hljs-comment">init</span> <span class="hljs-literal">--</span><span class="hljs-comment">recursive</span><br></code></pre></td></tr></table></figure><h3 id="查看子模块状态"><a href="#查看子模块状态" class="headerlink" title="查看子模块状态"></a>查看子模块状态</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git submodule status</span><br></code></pre></td></tr></table></figure><h3 id="更新子模块到最新提交"><a href="#更新子模块到最新提交" class="headerlink" title="更新子模块到最新提交"></a>更新子模块到最新提交</h3><ul><li>父仓库并不直接存储子模块的文件内容，而是存储子模块的当前提交哈希值。Git 会检测到子模块的提交哈希值已经发生了变化。<br>进入子模块目录，拉取最新代码：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">cd <span class="hljs-selector-tag">path</span>/<span class="hljs-selector-tag">to</span>/submodule<br>git pull origin <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure><p>然后返回主项目目录，提交子模块的更新：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">cd ..<br>git <span class="hljs-keyword">add</span> <span class="hljs-type">path</span>/<span class="hljs-keyword">to</span>/submodule<br>git <span class="hljs-keyword">commit</span> -m &quot;更新子模块&quot;<br></code></pre></td></tr></table></figure><h3 id="如何删除子模块"><a href="#如何删除子模块" class="headerlink" title="如何删除子模块"></a>如何删除子模块</h3><p>删除子模块需要手动操作：</p><ol><li>删除子模块目录：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf path/to/submodule<br></code></pre></td></tr></table></figure><ol start="2"><li>删除 .gitmodules 文件中的相关配置。</li><li>删除 .git&#x2F;config 中的子模块配置。</li><li>提交更改：</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">add</span> .gitmodules<br>git rm <span class="hljs-comment">--cached path/to/submodule</span><br>git <span class="hljs-keyword">commit</span> -m &quot;删除子模块&quot;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>八股</title>
    <link href="/2025/04/05/Git/%E5%85%AB%E8%82%A1/"/>
    <url>/2025/04/05/Git/%E5%85%AB%E8%82%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="常见git指令"><a href="#常见git指令" class="headerlink" title="常见git指令"></a>常见git指令</h1><ol><li>git init、 git clone</li><li>git add、 git commit、 git status</li><li>git branch 、 git checkout 、 git merge、 git rebase</li></ol><h1 id="git回滚操作"><a href="#git回滚操作" class="headerlink" title="git回滚操作"></a>git回滚操作</h1><ul><li>git reset和git revert区别<br>reset是回到对应的提交，提交和之前的记录都会保留；<br>revert是生成一个新的提交并撤销掉某次提交，之前的记录会保留。</li></ul><ol><li>本地回滚：git reset回退到指定版本，–hard是放弃当前代码的修改。</li><li>远程回滚：如果是远程库也要修改的话，先在本地reset，再push到远程。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard e377f60e28c8b84158<br>git push -f origin master<br></code></pre></td></tr></table></figure><h1 id="git如何解决冲突"><a href="#git如何解决冲突" class="headerlink" title="git如何解决冲突"></a>git如何解决冲突</h1><ol><li>如果两次提交修改的不同文件不会导致冲突，会自动合并。</li><li>冲突原因：冲突通常发生在合并分支或拉取代码时，Git 无法自动合并文件的更改。</li><li>解决方法：git status查看冲突文件，编辑冲突文件手动解决冲突，保留一方更改或者双方都保留，处理完后commit。如果是拉取代码时候冲突，再将合并后的结果提交到远程。</li></ol><h1 id="git-rebase和git-merge区别"><a href="#git-rebase和git-merge区别" class="headerlink" title="git rebase和git merge区别"></a>git rebase和git merge区别</h1><ol><li>git merge xxx：将指定xxx分支合并到当前分支。</li></ol><ul><li>情况一：如果两个分支没有不同节点，则进行<em><strong>快速线性合并</strong></em>；<br>情况二：否则处理一次冲突形成一个新提交，两个分支最新提交都指向这个提交，<em><strong>merge会保留两个分支所有的历史提交</strong></em>。</li></ul><ol start="2"><li>git rebase xxx</li></ol><ul><li>rebase步骤：<a href="https://blog.csdn.net/tq384998430/article/details/77745888">https://blog.csdn.net/tq384998430/article/details/77745888</a></li><li>Rebase 步骤：首先会产生 xxx 分支的备份，放到（no branch ）临时分支中。再将当前分支的每一次提交修改，以补丁的形式，一个个的重新应用到xxx分支上。<em><strong>这个过程是一个循环应用补丁的过程</strong></em>，如果当前补丁分支在临时分支记录有则跳过，没有则需要合并。直到所有补丁节点合并完。</li><li>将当前分支提交应用到另一个分支，重写了历史，使历史提交更线性，保持干净的历史提交。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>js沙箱的实现</title>
    <link href="/2025/04/04/%E5%BE%AE%E5%89%8D%E7%AB%AF/4.js%E6%B2%99%E7%AE%B1%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/04/04/%E5%BE%AE%E5%89%8D%E7%AB%AF/4.js%E6%B2%99%E7%AE%B1%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 沙箱：防止应用加载时候，对window造成污染 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript">         *  快照沙箱：兼容旧版本；消耗内存、消耗时间。</span></span><br><span class="hljs-comment"><span class="language-javascript">         * 激活时候：遍历window存储一份原始值，再把自己快照放到window上</span></span><br><span class="hljs-comment"><span class="language-javascript">         * 退出时候：遍历window把变化的值放到快照中，再遍历原先存储的window恢复window</span></span><br><span class="hljs-comment"><span class="language-javascript">         * */</span></span><br><span class="language-javascript">        <span class="hljs-keyword">class</span> <span class="hljs-title class_">SnapshotSandbox</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">modifyPropsMap</span> = &#123;&#125;; <span class="hljs-comment">// 存储哪些属性被修改了</span></span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">            <span class="hljs-title function_">active</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">windowSnapShot</span> = &#123;&#125;;</span><br><span class="language-javascript">                <span class="hljs-comment">// 给window拍照</span></span><br><span class="language-javascript">                <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">prop</span> =&gt;</span> &#123;</span><br><span class="language-javascript">                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">windowSnapShot</span>[prop] = <span class="hljs-variable language_">window</span>[prop];</span><br><span class="language-javascript">                &#125;)</span><br><span class="language-javascript">                <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">modifyPropsMap</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">prop</span> =&gt;</span> &#123;</span><br><span class="language-javascript">                    <span class="hljs-variable language_">window</span>[prop] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">modifyPropsMap</span>[prop];</span><br><span class="language-javascript">                &#125;)</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">            <span class="hljs-title function_">inactive</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">modifyPropsMap</span> = &#123;&#125;; <span class="hljs-comment">// 存储哪些属性被修改了</span></span><br><span class="language-javascript">                <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">prop</span> =&gt;</span> &#123;</span><br><span class="language-javascript">                    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>[prop] !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">windowSnapShot</span>[prop]) &#123;</span><br><span class="language-javascript">                        <span class="hljs-variable language_">this</span>.<span class="hljs-property">modifyPropsMap</span>[prop] = <span class="hljs-variable language_">window</span>[prop];</span><br><span class="language-javascript">                        <span class="hljs-variable language_">window</span>[prop] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">windowSnapShot</span>[prop];</span><br><span class="language-javascript">                    &#125;</span><br><span class="language-javascript">                &#125;)</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-comment">// let sandbox = new SnapshotSandbox();</span></span><br><span class="language-javascript">        <span class="hljs-comment">// sandbox.active();</span></span><br><span class="language-javascript">        <span class="hljs-comment">// window.a = 100;</span></span><br><span class="language-javascript">        <span class="hljs-comment">// window.b = 200;</span></span><br><span class="language-javascript">        <span class="hljs-comment">// sandbox.inactive();</span></span><br><span class="language-javascript">        <span class="hljs-comment">// console.log(window.a, window.b);</span></span><br><span class="language-javascript">        <span class="hljs-comment">// sandbox.active();</span></span><br><span class="language-javascript">        <span class="hljs-comment">// console.log(window.a, window.b);</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript">         * 单实例沙箱: 兼容旧版本，比快照效率高；需要支持proxy，还是会污染window对象。</span></span><br><span class="hljs-comment"><span class="language-javascript">         * 三个映射，记录新增的属性的映射，记录修改值前的原始值的映射，快照。</span></span><br><span class="hljs-comment"><span class="language-javascript">         * 会创建一个空对象，对这个空对象进行代理，这个空对象其实是对window的代理，get、set值都是对window操作。</span></span><br><span class="hljs-comment"><span class="language-javascript">         * 这个代理会作为子应用脚本执行时候的window对象，set时候会记录新增、修改、快照。</span></span><br><span class="hljs-comment"><span class="language-javascript">         * </span></span><br><span class="hljs-comment"><span class="language-javascript">         * 激活时候：把自己快照放上去</span></span><br><span class="hljs-comment"><span class="language-javascript">         * 销毁时候：window根据新增映射和修改映射恢复成原状。</span></span><br><span class="hljs-comment"><span class="language-javascript">         * </span></span><br><span class="hljs-comment"><span class="language-javascript">         * */</span> </span><br><span class="language-javascript">        <span class="hljs-keyword">class</span> <span class="hljs-title class_">LegacySandbox</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">modifyPropsMap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">addPropsMap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentPropsMap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();</span><br><span class="language-javascript"></span><br><span class="language-javascript">                <span class="hljs-keyword">const</span> fakeWindow = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);</span><br><span class="language-javascript">                <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(fakeWindow, &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">target, key, receiver</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">                        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>[key];</span><br><span class="language-javascript">                    &#125;,</span><br><span class="language-javascript">                    <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">target, key, value</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">                        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="language-javascript">                            <span class="hljs-variable language_">this</span>.<span class="hljs-property">addPropsMap</span>.<span class="hljs-title function_">set</span>(key, value);</span><br><span class="language-javascript">                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">modifyPropsMap</span>.<span class="hljs-title function_">has</span>(key)) &#123;</span><br><span class="language-javascript">                            <span class="hljs-variable language_">this</span>.<span class="hljs-property">modifyPropsMap</span>.<span class="hljs-title function_">set</span>(key, <span class="hljs-variable language_">window</span>[key]);</span><br><span class="language-javascript">                        &#125;</span><br><span class="language-javascript">                        <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentPropsMap</span>.<span class="hljs-title function_">set</span>(key, value);</span><br><span class="language-javascript">                        <span class="hljs-variable language_">window</span>[key] = value;</span><br><span class="language-javascript">                    &#125;</span><br><span class="language-javascript">                &#125;)</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">proxy</span> = proxy;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-title function_">setWindowProp</span>(<span class="hljs-params">key, value</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">undefined</span>) &#123;</span><br><span class="language-javascript">                    <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">window</span>[key];</span><br><span class="language-javascript">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">                    <span class="hljs-variable language_">window</span>[key] = value;</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-title function_">active</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentPropsMap</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">                    <span class="hljs-variable language_">window</span>[key] = value;</span><br><span class="language-javascript">                &#125;)</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-title function_">inactive</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">addPropsMap</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">                    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setWindowProp</span>(key, <span class="hljs-literal">undefined</span>);</span><br><span class="language-javascript">                &#125;)</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">modifyPropsMap</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">                    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setWindowProp</span>(key, value);</span><br><span class="language-javascript">                &#125;)</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-comment">// let sandbox = new LegacySandbox();</span></span><br><span class="language-javascript">        <span class="hljs-comment">// sandbox.active();</span></span><br><span class="language-javascript">        <span class="hljs-comment">// sandbox.proxy.a = 100;</span></span><br><span class="language-javascript">        <span class="hljs-comment">// sandbox.proxy.b = 200;</span></span><br><span class="language-javascript">        <span class="hljs-comment">// console.log(window.a, window.b);</span></span><br><span class="language-javascript">        <span class="hljs-comment">// sandbox.inactive();</span></span><br><span class="language-javascript">        <span class="hljs-comment">// console.log(window.a, window.b);</span></span><br><span class="language-javascript">        <span class="hljs-comment">// sandbox.active();</span></span><br><span class="language-javascript">        <span class="hljs-comment">// console.log(window.a, window.b);</span></span><br><span class="language-javascript">        <span class="hljs-comment">// (function(window)&#123;</span></span><br><span class="language-javascript">        <span class="hljs-comment">//     window.a = 100;</span></span><br><span class="language-javascript">        <span class="hljs-comment">// &#125;)(sandbox.proxy);</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript">         * 多实例沙箱：支持多个子应用加载；需要proxy支持。</span></span><br><span class="hljs-comment"><span class="language-javascript">         * 每个子应用有自己的沙箱，读取值时候先去沙箱上读取，没有的话再去window。</span></span><br><span class="hljs-comment"><span class="language-javascript">         * */</span> </span><br><span class="language-javascript">        <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxySandbox</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">running</span> = <span class="hljs-literal">false</span>;</span><br><span class="language-javascript">                <span class="hljs-keyword">const</span> fakeWindow = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">proxy</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(fakeWindow, &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">target, key</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">                        <span class="hljs-keyword">return</span> key <span class="hljs-keyword">in</span> target ? target[key] : <span class="hljs-variable language_">window</span>[key];</span><br><span class="language-javascript">                    &#125;,</span><br><span class="language-javascript">                    <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">target, key, value</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">                        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">running</span>) &#123;</span><br><span class="language-javascript">                            target[key] = value;</span><br><span class="language-javascript">                        &#125;</span><br><span class="language-javascript">                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">                    &#125;</span><br><span class="language-javascript">                &#125;)</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">            <span class="hljs-title function_">active</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">running</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">running</span> = <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">            <span class="hljs-title function_">inactive</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">running</span> = <span class="hljs-literal">false</span>;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> sandbox1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxySandbox</span>();</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> sandbox2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxySandbox</span>();</span><br><span class="language-javascript">        <span class="hljs-comment">// 缺点：要重写一些方法，获取值时候要返回代理（因为值可能在代理上）</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>qiankun源码</title>
    <link href="/2025/04/04/%E5%BE%AE%E5%89%8D%E7%AB%AF/3.qiankun%E6%BA%90%E7%A0%81/"/>
    <url>/2025/04/04/%E5%BE%AE%E5%89%8D%E7%AB%AF/3.qiankun%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="注册应用"><a href="#注册应用" class="headerlink" title="注册应用"></a>注册应用</h2><ul><li>因为register这个方法可能被重复调用，在已经注册应用列表中查找是否有当前这个需要注册的应用，通过name判断，如果已经有一个相同的name则直接返回不注册。</li><li>底层还是调用single-spa的registerApplication.<br><img src="/2025/04/04/%E5%BE%AE%E5%89%8D%E7%AB%AF/3.qiankun%E6%BA%90%E7%A0%81/image-7.png" alt="alt text"></li></ul><h2 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h2><ul><li>增加了prefetch<strong>预加载功能</strong>、<strong>沙箱功能</strong>。</li><li>底层也还是调用single-spa的start方法<br><img src="/2025/04/04/%E5%BE%AE%E5%89%8D%E7%AB%AF/3.qiankun%E6%BA%90%E7%A0%81/image-8.png" alt="alt text"></li></ul><h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><ul><li><a href="https://juejin.cn/post/6844903848981577735#heading-7">https://juejin.cn/post/6844903848981577735#heading-7</a></li><li><a href="https://juejin.cn/post/6844904081463443463">https://juejin.cn/post/6844904081463443463</a></li></ul><ol><li><strong>派发事件</strong>：第一个应用加载完毕后会派发一个事件，预加载会监听这个事件（也就是等应用加载完毕后）然后开始后面其他应用的预加载。<br><img src="/2025/04/04/%E5%BE%AE%E5%89%8D%E7%AB%AF/3.qiankun%E6%BA%90%E7%A0%81/image-9.png" alt="alt text"></li><li>用import-html-entry方法执行预加载，<strong>requestIdleCallback</strong>：浏览器一帧结束还有空闲时间的时候调用回调函数。<br><img src="/2025/04/04/%E5%BE%AE%E5%89%8D%E7%AB%AF/3.qiankun%E6%BA%90%E7%A0%81/image-10.png" alt="alt text"></li></ol><h2 id="import-html-entry"><a href="#import-html-entry" class="headerlink" title="import-html-entry"></a>import-html-entry</h2><!-- 可以直接问gpt：import-html-entry原理 --><ul><li><a href="https://blog.csdn.net/qq_41800366/article/details/122093720">https://blog.csdn.net/qq_41800366/article/details/122093720</a></li></ul><ol><li><strong>fetch拉取html文件</strong>：通过fetch获取url对应的html内容。</li><li><strong>html正则处理</strong>： html里面js（外联、页内）都被注释掉并保存起来；css页面内的style不动，外联css注释掉保存起来；</li><li><strong>拉取css，style插入</strong>：fetch获取外联css，通过style标签加入到html中。</li><li><strong>拉取js并在沙箱执行</strong>：拉取外联js、页面js直接返回，jscode包裹在一个函数中，做沙箱隔离。并且执行。</li><li><strong>返回html和js</strong>：返回 <em>template：html模板</em> 和 <em>execScripts：执行所有js的函数</em></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 最后由主应用把模板挂载到容器中，在挂载完后执行js。</span><br><span class="hljs-title function_">importEntry</span>(<span class="hljs-string">&#x27;https://example.com/child-app&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123; template, execScripts &#125;</span>) =&gt;</span> &#123;<br>  container.<span class="hljs-property">innerHTML</span> = template;  <span class="hljs-comment">// 渲染 HTML</span><br>  <span class="hljs-title function_">execScripts</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">appExports</span> =&gt;</span> &#123;<br>    appExports.<span class="hljs-title function_">bootstrap</span>();  <span class="hljs-comment">// 执行子应用的启动逻辑（如 qiankun 使用）</span><br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>single-spa源码</title>
    <link href="/2025/04/04/%E5%BE%AE%E5%89%8D%E7%AB%AF/2.single-spa%E6%BA%90%E7%A0%81/"/>
    <url>/2025/04/04/%E5%BE%AE%E5%89%8D%E7%AB%AF/2.single-spa%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="single-spa微前端框架"><a href="#single-spa微前端框架" class="headerlink" title="single-spa微前端框架"></a>single-spa微前端框架</h1><h2 id="辅助"><a href="#辅助" class="headerlink" title="辅助"></a>辅助</h2><ul><li>辅助方法：app.helpers.js中定义了子应用的状态：加载、启动、挂载、卸载。</li><li>并有一个<strong>分类函数</strong>根据状态对各个子应用分类&#x3D;》哪些要加载、哪些要挂载、哪些要卸载。</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>核心两个函数，registerApplication和start，在single-spa.js中对外暴露。</li></ul><ol><li>register注册应用时候，如果路径匹配，会加载对应的应用；不匹配则不会加载。</li><li>start启动后，会加载路径匹配的应用 &#x3D;》 启动对应的应用 &#x3D;》确保卸载完应用 &#x3D;》 挂载应用。</li></ol><!-- start的加载应用是因为注册时候可能没加载当前路径的应用，那就再加载一次。    比如注册应用时候是路径/a，会加载a应用，但不会加载b应用。    启动时候是b应用，这时候需要加载b应用。 --><h2 id="registerApplication"><a href="#registerApplication" class="headerlink" title="registerApplication"></a>registerApplication</h2><ol><li>app.js中暴露此方法，接受应用注册的数据，所有子应用统一放到apps；</li><li>每注册一个应用，调用一次reroute方法。</li></ol><h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><ol><li>started全局变量，确保只加载一次。</li><li>调用reroute方法。</li></ol><h2 id="核心：reroute方法"><a href="#核心：reroute方法" class="headerlink" title="核心：reroute方法"></a>核心：<em><strong>reroute</strong></em>方法</h2><!-- 做两件事情，一个是分类函数，另一个是根据是否开启来加载、启动、挂载、卸载应用 --><ol><li>根据应用的state状态区分要加载的应用、要卸载的应用、要挂载的应用。<br>然后根据全局started变量两种情况：</li><li>一种是没有调用start方法，用户注册时候调用reroute方法，只会加载当前路径匹配、对应的应用。</li><li>第二种情况是调用了start方法，用户会卸载应用，<br>加载对应的应用 &#x3D;》 启动对应的应用 &#x3D;》 确保卸载完毕 &#x3D;》 挂载对应的应用。</li></ol><h2 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h2><!-- lifecycles下的四个文件 --><ul><li>加载逻辑：把子应用暴露的接口协议放到子应用实例上。</li><li>启动、挂载、卸载：就是按序调用对应的接口协议。</li></ul><h2 id="路由监听"><a href="#路由监听" class="headerlink" title="路由监听"></a>路由监听</h2><!-- single-spa\navigation\navigation-event.js --><ul><li>single-spa会开启监听hashchange、popstate事件，如果触发了执行reroute函数（也就是 调用分类函数，加载、启动、挂载、卸载的逻辑）。</li><li>子应用也有路由系统（比如：vue-router）监听hashchange、popstate事件，需要在子应用加载完毕后执行。<br>我们要对addEventListener进行重写：如果是hashchange、popstate则不执行，添加到一个任务队列中保存，其他正常执行。在reroute里面，等挂载的promise执行完毕后执行子应用的监听事件。</li></ul><h1 id="面试回答"><a href="#面试回答" class="headerlink" title="面试回答"></a>面试回答</h1><ul><li>辅助文件 &#x3D;》 register、start &#x3D;》 reroute、接入协议 &#x3D;》 路由监听。</li></ul><ol><li><p>首先可以明确几个概念，在一个辅助文件中定义每个子应用状态：加载、启动、挂载、卸载。然后定义一个分类函数：根据子应用状态，分为要加载的数组、要挂载的数组、要卸载的数组。</p></li><li><p>我们在使用框架时候核心是两个函数：register和start方法，这两个方法都会调用reroute方法，reroute方法是整个微前端框架的核心。register还会保留注册的应用数据，start有个全局变量控制只会启动一次qiankun框架。</p></li><li><p>在reroute里，主要做两件事情。第一是会调用我们的分类函数，区分哪些应用要加载、哪些要挂载卸载。第二是根据全局变量判断是否调用了start方法，<br>如果没调用start方法的话，只会加载应用，不走启动挂载流程。<br>如果调用了start方法，则会加载、启动、挂载、卸载整套流程。<br>加载的话其实是我们去加载<strong>子应用的入口文件</strong>，把接入协议放到我们子应用实例上。启动、挂载、卸载就是调用对应接入协议。</p></li><li><p>路由监听：会监听hashchange、popstate两个事件，调用reroute事件。pushstate和replacestate方法进行了重写，也会调用reroute。（push和replace具体逻辑在第四节single-spa实现的1h40min左右）<br>这里有一个重点要考虑，子应用也会有路由系统监听事件比如vue-router，我们需要等子应用加载挂载完毕后再去执行子应用的路由事件。这里会对addEventListener进行重写，如果是hashchange、popstate事件，不会直接执行而是保留到任务队列中，等在reroute里面挂载完毕应用后再去执行。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>微前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础</title>
    <link href="/2025/04/04/%E5%BE%AE%E5%89%8D%E7%AB%AF/1.%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/04/04/%E5%BE%AE%E5%89%8D%E7%AB%AF/1.%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<ul><li>蚂蚁qiankun核心贡献者对qiankun讲解：<a href="https://juejin.cn/post/6846687602439897101?searchId=20241020100002E607ECE10FA25EDC88EF">https://juejin.cn/post/6846687602439897101?searchId=20241020100002E607ECE10FA25EDC88EF</a></li><li>阮一峰的Web Components 入门实例教程：<a href="https://www.ruanyifeng.com/blog/2019/08/web_components.html">https://www.ruanyifeng.com/blog/2019/08/web_components.html</a></li></ul><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="微前端实现"><a href="#微前端实现" class="headerlink" title="微前端实现"></a>微前端实现</h2><ol><li>将多个项目域名合并处理，不需要前端改任何代码。比如：a.com b.com c.com合成tencent&#x2F;a tencent&#x2F;b tencent&#x2F;c.(刷新页面)</li><li>qiankun、single-spa、wujie 有个框架基座，来回切换。</li><li>模块联邦：运行时动态加载彼此的模块，从而实现 应用拆分、独立部署、依赖共享。 也是有一个主应用动态加载子应用，公共依赖也可以共享。</li></ol><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><ol><li>应用可维护：将一个大应用拆分成多个独立、松耦合的小应用，每个模块可以独立的开发测试，每个模块有自己的版本管理，如果出现问题不会影响其他模块运行。</li><li>团队独立性：复杂应用涉及多个团队开发，采用微前端架构可以让各个团队维护自己的部分。</li><li>技术灵活性：每个子应用可以使用不同的技术栈，避免了技术栈不一致的问题。</li><li>增量升级：在原有基础上添加新的子应用。</li></ol><h2 id="带来的新问题"><a href="#带来的新问题" class="headerlink" title="带来的新问题"></a>带来的新问题</h2><ol><li>接入协议：改造项目接入微前端框架。single-spa、qiankun。</li><li>模块拆分困难：如何根据业务去拆分不同的应用，确保后续系统开发可执行性。</li></ol><h2 id="qiankun和iframe区别（为什么不用wujie）"><a href="#qiankun和iframe区别（为什么不用wujie）" class="headerlink" title="qiankun和iframe区别（为什么不用wujie）"></a>qiankun和iframe区别（为什么不用wujie）</h2><ol><li>实现方式：</li></ol><ul><li>iframe每个应用有自己独立的浏览器上下文、window对象，完全隔离了父子应用；</li><li>qiankun父子应用共享父应用的上下文环境和window对象，通过沙箱机制软隔离；</li></ul><ol start="2"><li>数据通信：</li></ol><ul><li>iframe通过postmessage API进行跨域通信</li><li>qiankun通过全局状态管理或者全局事件总线进行通信</li></ul><ol start="3"><li>样式隔离：</li></ol><ul><li>iframe天生就有样式隔离的效果，因为它加载的是单独的页面。</li><li>qiankun提供css模块化、shadowDOM去避免子应用之间的样式污染。</li></ul><ol start="4"><li>使用场景：</li></ol><ul><li>iframe用于强隔离，嵌入第三方系统的场景，适合广告嵌入。</li><li>qiankun适合多个团队开发复杂系统的不同模块时候使用。</li></ul><h2 id="子应用如何接入qiankun框架？"><a href="#子应用如何接入qiankun框架？" class="headerlink" title="子应用如何接入qiankun框架？"></a>子应用如何接入qiankun框架？</h2><ol><li><strong>主应用注册子应用</strong>，包括：<br>name；<br>挂载的元素；<br>激活该应用的路由：有全局监听器去监听hashchange和popstate事件；<br>加载的路径：监听器发现路由匹配后会import-html-entry去加载对应的入口文件。</li><li><strong>子应用暴露接口协议</strong>：import-html-entry如何加载的，css样式隔离、js沙箱初始化、接入协议。</li><li><strong>public-path.js</strong>：改变静态资源路径为子应用ip地址，默认会是父应用ip地址导致静态资源无法加载。<br><img src="/2025/04/04/%E5%BE%AE%E5%89%8D%E7%AB%AF/1.%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/image-11.png" alt="alt text"></li><li><strong>挂载位置</strong>：子应用挂载到app，根应用也是app的div，这时候需要限制查找范围。props参数有个container属性是dom元素。主应用的html下面有一个container div，container div上挂载子应用的html，子应用html有app。</li><li><strong>webpack打包格式</strong>：为umd格式。</li><li><strong>全局变量</strong>：除了微前端启动，还有正常启动，qiankun会在window放个全局属性powerbyqiankun没有的话直接调render函数就好。</li></ol><h2 id="start时候qiankun做了什么？qiankun的原理？"><a href="#start时候qiankun做了什么？qiankun的原理？" class="headerlink" title="start时候qiankun做了什么？qiankun的原理？"></a>start时候qiankun做了什么？qiankun的原理？</h2><ul><li>single-spa原理。</li></ul><h2 id="父子应用通信"><a href="#父子应用通信" class="headerlink" title="父子应用通信"></a>父子应用通信</h2><ul><li>qiankun自己有数据通信的API,但是不好用、有学习成本，后续3.0会移除，调研时候就没用这个方法。</li></ul><ol><li>父&#x3D;&gt;子：在注册子应用时候添加props字段，表示父应用会传递给子应用的数据。在子应用的生命周期mount接收这些数据。<br>子&#x3D;&gt;父：传递事件总线对象，子应用可以绑定事件，主应用触发事件。</li><li>父传子：用户权限节点，用户基本信息，白名单列表等等，父应用集中管理所有子应用会用到的状态。<br>子传父：一个子应用的一个模板同时只能有一个人操作，在解锁这个业务需求下：子应用绑定解锁事件（调用当前子应用的API），在父应用的导航条触发解锁事件。</li></ol><h2 id="js沙箱机制"><a href="#js沙箱机制" class="headerlink" title="js沙箱机制"></a>js沙箱机制</h2><ul><li><a href="https://juejin.cn/post/6920110573418086413#heading-0">https://juejin.cn/post/6920110573418086413#heading-0</a><br>沙箱sandbox：它是一种安全机制，在程序中创建一个独立的运行环境，用于严格控制访问资源，隔离对外部程序影响。<em><strong>qiankun：每个子应用对应一个沙箱，确保微应用之间 全局变量&#x2F;事件 不冲突。</strong></em><br>qiankun有三种沙箱实现机制，快照沙箱支持无proxy的浏览器；单例沙箱和多例沙箱基于proxy。</li></ul><h3 id="SnapshotSandbox"><a href="#SnapshotSandbox" class="headerlink" title="SnapshotSandbox"></a>SnapshotSandbox</h3><p>快照沙箱，基于 diff 方式实现的沙箱，用于不支持 Proxy 的低版本浏览器.将进入前的window的快照信息存到windowSnapshot中，如果modifyPropsMap有值，还需要还原上次的状态；激活期间，可能修改了window的数据；退出沙箱时，将修改过的信息存到modifyPropsMap里面，并且把window还原成初始进入的状态。</p><!--windowSnapshot：存储window默认状态modifyPropsMap：存储每个子应用各自的全局信息  --><blockquote><p>激活时候将全局window缓存，把自己的全局状态放到window上；退出时候将全局window恢复，把window全局变化缓存到自己身上。<br>兼容不支持proxy的浏览器</p></blockquote><h3 id="LegacySandbox"><a href="#LegacySandbox" class="headerlink" title="LegacySandbox"></a>LegacySandbox</h3><p>单实例代理沙箱，对window对象进行proxy代理。legacySandbox设置了三个参数来记录全局变量,分别是: </p><ol><li>记录沙箱新增的全局变量addedPropsMapInSandbox、</li><li>记录沙箱更新的全局变量<code>modifiedPropsOriginalValueMapInSandbox</code>、</li><li>持续记录更新的(新增和修改的)全局变量，用于在任意时刻做snapshot的currentUpdatedPropsValueMap。<br>沙箱激活时，将快照映射（当前沙箱的全局变量和函数）添加到window上，通过代理拦截对window的set操作，新增的的变量记录，修改的变量记录初始化，再把变化统一记录在快照映射上；退出沙箱时，删除新增的变量记录，恢复修改的变量记录。</li></ol><blockquote><p>核心是代理了window对象，记录新增的，记录修改的，有一个快照映射；退出时候去除新增的，恢复修改的。<br>相对快照沙箱优点是不用再遍历window对象，但相对于多实例沙箱缺点是依旧会污染全局window。</p></blockquote><h3 id="ProxySandbox"><a href="#ProxySandbox" class="headerlink" title="ProxySandbox"></a>ProxySandbox</h3><p>多实例代理沙箱，通过对window的拷贝建立多个副本，在沙箱中对建立的副本进行操作，如果副本上没有属性才去window对象上获取。</p><blockquote><p>对window代理建立多个副本，先在副本上获取属性，获取不到再去window对象上获取。<br>不会污染全局window，且能实现同时挂载多个子应用。是最完美的解决方案，但快照沙箱是解决不兼容proxy的浏览器，单实例是对旧版的兼容优化，新版可采用多实例沙箱。</p></blockquote><h3 id="子应用window-a怎么被代理呢？"><a href="#子应用window-a怎么被代理呢？" class="headerlink" title="子应用window.a怎么被代理呢？"></a>子应用window.a怎么被代理呢？</h3><ol><li>子应用的js代码包装到一个函数，传入window参数；</li><li>call改变里面默认this指向；</li><li>with添加作用域改变默认变量的访问；</li></ol><ul><li>子应用脚本会放到沙箱里去执行。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>) &#123;<br>    <span class="hljs-title function_">with</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>) &#123;<br>        <span class="hljs-comment">// 子应用的脚本在这个沙箱内执行</span><br>        <span class="hljs-built_in">eval</span>(<span class="hljs-string">`console.log(a)`</span>); <span class="hljs-comment">// 访问的是沙箱中的 a</span><br>    &#125;<br>&#125;).<span class="hljs-title function_">call</span>(sandbox, sandbox);<br></code></pre></td></tr></table></figure><h2 id="css样式隔离"><a href="#css样式隔离" class="headerlink" title="css样式隔离"></a>css样式隔离</h2><h3 id="动态样式表"><a href="#动态样式表" class="headerlink" title="动态样式表"></a>动态样式表</h3><ul><li>应用A切换到B，卸载A应用样式，挂载B应用样式，<em><strong>以 style 标签的形式插入并做快照</strong></em>。未解决父子应用，只适用于单应用挂载。</li></ul><h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><p><a href="https://blog.csdn.net/qq_38935512/article/details/130317408">https://blog.csdn.net/qq_38935512/article/details/130317408</a><br><a href="https://codeteenager.github.io/Micro-Frontends/guide/qiankun-problem.html#css-%E9%9A%94%E7%A6%BB">https://codeteenager.github.io/Micro-Frontends/guide/qiankun-problem.html#css-%E9%9A%94%E7%A6%BB</a></p><ul><li>通过css预处理器处理，类似vue样式的scoped属性，qiankun会自动为子应用所有的样式选择器添加后缀名。给子应用最外层包一个div，div有个data-qiankun属性，然后style的样式都添加一个属性选择器。<br><img src="/2025/04/04/%E5%BE%AE%E5%89%8D%E7%AB%AF/1.%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/image-5.png" alt=" "></li><li>缺点：弹窗、抽屉因插入到主应用的body中，导致样式丢失或者应用了主应用样式。</li><li>解决方法：antd指定弹窗渲染的范围&#x2F;重写appendChild方法：建立一个白名单比如：弹窗等等，如果添加的元素是白名单中的话，额外添加样式类使其在主应用正常展示，调用原来的appendChild方法。</li></ul><h3 id="shadow-DOM"><a href="#shadow-DOM" class="headerlink" title="shadow DOM"></a>shadow DOM</h3><ul><li>qiankun2新增的严格样式隔离，采用shadow DOM方式。shadow DOM其实是web-component在使用时候希望与外部DOM，样式隔离采用的方案。<br><img src="/2025/04/04/%E5%BE%AE%E5%89%8D%E7%AB%AF/1.%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/image-6.png" alt="alt text"></li><li>shadow DOM也带来一些限制：一些全局样式无法渗透到shadow DOM中。</li></ul><blockquote><p>样式表是开始的方案，但无法解决父子应用样式冲突问题。后续有工程化和shadow DOM解决方案。企业还是BEM规范。</p></blockquote><h2 id="父子应用路由"><a href="#父子应用路由" class="headerlink" title="父子应用路由"></a>父子应用路由</h2><ul><li>全局监听器 &#x3D;&gt; 方法的重写 &#x3D;&gt; 主应用具体怎么写的 &#x3D;&gt; 子应用负责自己的路由。</li></ul><h3 id="主应用路由"><a href="#主应用路由" class="headerlink" title="主应用路由"></a>主应用路由</h3><ul><li>主应用通过路由规则决定何时加载子应用：在主应用入口文件会注册激活子应用的url信息，这里各个子应用的url前缀要各不相同。通过动态路由参数匹配所有的子应用路径，将主应用切换到一个空壳容器组件，子应用都挂载到主应用这个空壳路由组件。</li></ul><h3 id="子应用路由"><a href="#子应用路由" class="headerlink" title="子应用路由"></a>子应用路由</h3><ul><li>子应用加载后执行生命周期bootstrap，mount，unmount，负责子应用内部的路由切换。</li></ul><h3 id="如何同时加载多个子应用？"><a href="#如何同时加载多个子应用？" class="headerlink" title="如何同时加载多个子应用？"></a>如何同时加载多个子应用？</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/355419817">https://zhuanlan.zhihu.com/p/355419817</a></li></ul><ol><li>qiankun 2.0 的发布带来一个全新的 API ：loadMicroApp。</li></ol><h2 id="qiankun和single-spa区别"><a href="#qiankun和single-spa区别" class="headerlink" title="qiankun和single-spa区别"></a>qiankun和single-spa区别</h2><ol><li>预加载</li><li>js沙箱</li><li>css样式隔离</li><li>systemjs、html-import-entry</li></ol>]]></content>
    
    
    <categories>
      
      <category>微前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础</title>
    <link href="/2025/04/04/%E6%89%8B%E5%86%99%E9%A2%98/%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9/0.%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/04/04/%E6%89%8B%E5%86%99%E9%A2%98/%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9/0.%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="并发请求"><a href="#并发请求" class="headerlink" title="并发请求"></a>并发请求</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1. promise题目， return new Promise</span><br><span class="hljs-comment"> * 2. for循环开启多个任务调度</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiRequest</span>(<span class="hljs-params">promises, max</span>) &#123;<br>    <span class="hljs-keyword">let</span> ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(promises.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 全局记录当前运行到哪一个,运行了多少个</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123; <span class="hljs-comment">// 返回promise结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; max; i++) &#123; <span class="hljs-comment">// 开启多个任务</span><br>            <span class="hljs-title function_">request</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur &gt;= promises.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第<span class="hljs-subst">$&#123;cur&#125;</span>个任务开始执行了`</span>);<br>            <span class="hljs-keyword">let</span> temp = cur; <span class="hljs-comment">// 保留当前是运行第几个任务</span><br>            <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[cur++]()).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>                ans[temp] = res;<br>            &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>                ans[temp] = err;<br>            &#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                count++;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第<span class="hljs-subst">$&#123;count&#125;</span>个任务执行完毕了`</span>);<br>                <span class="hljs-keyword">if</span> (count == promises.<span class="hljs-property">length</span>) &#123;<br>                    <span class="hljs-title function_">resolve</span>(ans);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">request</span>();<br>                &#125;<br>            &#125;)<br>        &#125;;<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> tasks = [<br>    <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>); <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>); &#125;, <span class="hljs-number">1000</span>)),<br>    <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>); <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>); &#125;, <span class="hljs-number">1000</span>)),<br>    <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>); <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>); &#125;, <span class="hljs-number">1000</span>)),<br>    <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>); <span class="hljs-title function_">resolve</span>(<span class="hljs-number">4</span>); &#125;, <span class="hljs-number">1000</span>)),<br>    <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>); <span class="hljs-title function_">resolve</span>(<span class="hljs-number">5</span>); &#125;, <span class="hljs-number">1000</span>)),<br>    <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>); <span class="hljs-title function_">resolve</span>(<span class="hljs-number">6</span>); &#125;, <span class="hljs-number">1000</span>)),<br>];<br><span class="hljs-title function_">multiRequest</span>(tasks, <span class="hljs-number">3</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="压缩CSS"><a href="#压缩CSS" class="headerlink" title="压缩CSS"></a>压缩CSS</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1. 闭包思想 计数、map</span><br><span class="hljs-comment"> * 2. String.fromCharCode编码</span><br><span class="hljs-comment"> * */</span> <br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">clourse</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">25</span>;<br>    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) &#123;<br>        <span class="hljs-keyword">let</span> strArr = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">let</span> res = [];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strArr.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(strArr[i])) res.<span class="hljs-title function_">push</span>(map.<span class="hljs-title function_">get</span>(strArr[i]));<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">let</span> tempCount = count;<br>                <span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;&quot;</span>;<br>                <span class="hljs-keyword">while</span> (tempCount &gt;= <span class="hljs-number">26</span>) &#123;<br>                    result = <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>(tempCount % <span class="hljs-number">26</span> + <span class="hljs-number">97</span>) + result;<br>                    tempCount = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(tempCount / <span class="hljs-number">26</span>);<br>                &#125;;<br>                result = <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>(tempCount % <span class="hljs-number">26</span> + <span class="hljs-number">97</span>) + result;<br>                map.<span class="hljs-title function_">set</span>(strArr[i], result);<br>                res.<span class="hljs-title function_">push</span>(result);<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> optim = <span class="hljs-title function_">clourse</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>    <span class="hljs-title function_">optim</span>(<span class="hljs-string">&#x27;class-a&#x27;</span>),<br>    <span class="hljs-title function_">optim</span>(<span class="hljs-string">&#x27;class-aa&#x27;</span>),<br>    <span class="hljs-title function_">optim</span>(<span class="hljs-string">&#x27;class-a&#x27;</span>),<br>    <span class="hljs-title function_">optim</span>(<span class="hljs-string">&#x27;class-a class-aa class-b&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 深拷贝：考虑循环引用和depth和各种类型。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">source, depth = <span class="hljs-literal">Infinity</span>, map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()</span>) &#123;<br>    <span class="hljs-keyword">if</span> (depth &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> source;<br><br>    <span class="hljs-keyword">if</span> (source == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> source;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(source)) <span class="hljs-keyword">return</span> map.<span class="hljs-title function_">get</span>(source); <span class="hljs-comment">// 解决循环引用</span><br><br>    <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123;<br>        <span class="hljs-keyword">let</span> newArr = [];<br>        map.<span class="hljs-title function_">set</span>(source, newArr);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; source.<span class="hljs-property">length</span>; i++) &#123;<br>            newArr.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">deepCopy</span>(source[i], depth - <span class="hljs-number">1</span>, map));<br>        &#125;;<br>        <span class="hljs-keyword">return</span> newArr;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Set</span>) &#123;<br>        <span class="hljs-keyword">let</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>        map.<span class="hljs-title function_">set</span>(source, newSet);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> source) &#123;<br>            newSet.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">deepCopy</span>(value, depth - <span class="hljs-number">1</span>, map));<br>        &#125;;<br>        <span class="hljs-keyword">return</span> newSet;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>) &#123;<br>        <span class="hljs-keyword">let</span> newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>        map.<span class="hljs-title function_">set</span>(source, newMap);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> source) &#123;<br>            newMap.<span class="hljs-title function_">set</span>(<span class="hljs-title function_">deepCopy</span>(key, depth - <span class="hljs-number">1</span>, map), <span class="hljs-title function_">deepCopy</span>(value, depth - <span class="hljs-number">1</span>, map));<br>        &#125;;<br>        <span class="hljs-keyword">return</span> newMap;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> newObj = &#123;&#125;;<br>    map.<span class="hljs-title function_">set</span>(source, newObj);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> source) &#123;<br>        <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>            newObj[key] = <span class="hljs-title function_">deepCopy</span>(source[key], depth - <span class="hljs-number">1</span>, map);<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newObj;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="loadash-get"><a href="#loadash-get" class="headerlink" title="loadash.get"></a>loadash.get</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// console.log(_.get(object, &#x27;a[0].b.c&#x27;)); // 输出: 3</span><br><span class="hljs-comment">// console.log(_.get(object, &#x27;a[0].b.d&#x27;, &#x27;default&#x27;)); // 输出: &#x27;default&#x27;</span><br><span class="hljs-comment">// console.log(_.get(object, [&#x27;a&#x27;, &#x27;0&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])); // 输出: 3</span><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: [&#123; <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125; &#125;] &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myGet</span>(<span class="hljs-params">obj, path, defaultValue = <span class="hljs-literal">undefined</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span> defaultValue;<br>    <span class="hljs-keyword">let</span> pathArr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(path) ? [...path] : path.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>    <span class="hljs-keyword">let</span> result = obj;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> pathArr)&#123;<br>        <span class="hljs-keyword">if</span>(key.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;[&quot;</span>))&#123;<br>            <span class="hljs-keyword">let</span> index = key.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;[&#x27;</span>);<br>            <span class="hljs-keyword">let</span> value = key.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, index);<br>            <span class="hljs-keyword">let</span> arrIndex = key.<span class="hljs-title function_">slice</span>(index + <span class="hljs-number">1</span>, key.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(result.<span class="hljs-title function_">hasOwnProperty</span>(value))&#123;<br>                result = result[value[arrIndex]];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> defaultValue;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(result.<span class="hljs-title function_">hasOwnProperty</span>(key))&#123;<br>                result = result[key];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> defaultValue;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">myGet</span>(obj, <span class="hljs-string">&#x27;a[0].b.d&#x27;</span>, <span class="hljs-string">&#x27;default&#x27;</span>)); <span class="hljs-comment">// 输出: &#x27;default&#x27;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">myGet</span>(obj, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>],<span class="hljs-string">&#x27;123&#x27;</span>));<br><br><br><br><br><br><br><span class="hljs-comment">// function myGet(obj, path, defaultValue) &#123;</span><br><span class="hljs-comment">//     // 将路径统一转换为数组形式</span><br><span class="hljs-comment">//     const pathArray = Array.isArray(path) ? path : path.split(&#x27;.&#x27;);</span><br><br><span class="hljs-comment">//     // 遍历路径数组</span><br><span class="hljs-comment">//     let result = obj;</span><br><span class="hljs-comment">//     for (let key of pathArray) &#123;</span><br><span class="hljs-comment">//         // 处理数组索引的情况，如 &#x27;a[0]&#x27;</span><br><span class="hljs-comment">//         if (key.includes(&#x27;[&#x27;) &amp;&amp; key.endsWith(&#x27;]&#x27;)) &#123;</span><br><span class="hljs-comment">//             const [prop, index] = key.split(&#x27;[&#x27;);</span><br><span class="hljs-comment">//             key = prop; // 属性名</span><br><span class="hljs-comment">//             const arrayIndex = index.slice(0, -1); // 去掉 &#x27;]&#x27;，得到索引</span><br><span class="hljs-comment">//             if (result &amp;&amp; result[key] &amp;&amp; Array.isArray(result[key])) &#123;</span><br><span class="hljs-comment">//                 result = result[key][arrayIndex]; // 访问数组元素</span><br><span class="hljs-comment">//             &#125; else &#123;</span><br><span class="hljs-comment">//                 return defaultValue; // 路径不存在，返回默认值</span><br><span class="hljs-comment">//             &#125;</span><br><span class="hljs-comment">//         &#125; else &#123;</span><br><span class="hljs-comment">//             // 普通属性访问</span><br><span class="hljs-comment">//             if (result &amp;&amp; typeof result === &#x27;object&#x27; &amp;&amp; key in result) &#123;</span><br><span class="hljs-comment">//                 result = result[key];</span><br><span class="hljs-comment">//             &#125; else &#123;</span><br><span class="hljs-comment">//                 return defaultValue; // 路径不存在，返回默认值</span><br><span class="hljs-comment">//             &#125;</span><br><span class="hljs-comment">//         &#125;</span><br><span class="hljs-comment">//     &#125;</span><br><br><span class="hljs-comment">//     return result !== undefined ? result : defaultValue;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><h1 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]], <span class="hljs-number">7</span>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flaten1</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-property">toString</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flaten2</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, next</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> prev.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(next) ? <span class="hljs-title function_">flaten2</span>(next) : next);<br>    &#125;, []);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flaten3</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flaten4</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">let</span> newArr = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr[i]))&#123;<br>            newArr = newArr.<span class="hljs-title function_">concat</span>(<span class="hljs-title function_">flaten4</span>(arr[i]));<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            newArr.<span class="hljs-title function_">push</span>(arr[i]);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flaten5</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">while</span>(arr.<span class="hljs-title function_">some</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property">isArray</span>))&#123;<br>       arr = [].<span class="hljs-title function_">concat</span>(...arr);<br>    &#125;;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flaten5</span>(arr));<br></code></pre></td></tr></table></figure><h1 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">if</span> (timer) &#123;<br>            <span class="hljs-built_in">clearTimeout</span>(timer);<br>            timer = <span class="hljs-literal">null</span>;<br>        &#125;<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn.<span class="hljs-title function_">call</span>(context, ...<span class="hljs-variable language_">arguments</span>);<br>        &#125;, delay);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>    <span class="hljs-keyword">let</span> preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> curTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">if</span> (preTime - curTime &gt;= delay) &#123;<br>            fn.<span class="hljs-title function_">call</span>(context, ...<span class="hljs-variable language_">arguments</span>);<br>            preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="列表转换为树"><a href="#列表转换为树" class="headerlink" title="列表转换为树"></a>列表转换为树</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<br>    &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;部门1&#x27;</span>, <span class="hljs-attr">pid</span>: <span class="hljs-number">0</span> &#125;,<br>    &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;部门2&#x27;</span>, <span class="hljs-attr">pid</span>: <span class="hljs-number">1</span> &#125;,<br>    &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;部门3&#x27;</span>, <span class="hljs-attr">pid</span>: <span class="hljs-number">1</span> &#125;,<br>    &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;部门4&#x27;</span>, <span class="hljs-attr">pid</span>: <span class="hljs-number">3</span> &#125;,<br>    &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;部门5&#x27;</span>, <span class="hljs-attr">pid</span>: <span class="hljs-number">4</span> &#125;,<br>    &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;部门6&#x27;</span>, <span class="hljs-attr">pid</span>: <span class="hljs-number">0</span> &#125;,<br>]<br><span class="hljs-comment">// 时间复杂度 n ； 空间复杂度 n</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">arr2tree</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    <span class="hljs-keyword">let</span> tree = [];<br>    arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        map.<span class="hljs-title function_">set</span>(value.<span class="hljs-property">id</span>, value);<br>    &#125;);<br>    arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(value.<span class="hljs-property">pid</span>)) &#123;<br>            <span class="hljs-keyword">let</span> parentEl = map.<span class="hljs-title function_">get</span>(value.<span class="hljs-property">pid</span>);<br>            <span class="hljs-keyword">if</span> (parentEl.<span class="hljs-property">children</span>) &#123;<br>                parentEl.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(value);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                parentEl.<span class="hljs-property">children</span> = [value]<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> tree.<span class="hljs-title function_">push</span>(value);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> tree;<br>&#125;<br><br><span class="hljs-comment">// 时间复杂度n2，空间复杂度1（双重循环，里层循环去找当前元素的父元素）</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">arr2tree</span>(arr));<br></code></pre></td></tr></table></figure><h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceOf</span>(<span class="hljs-params">obj, Fn</span>)&#123;<br>    <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj);<br>    <span class="hljs-keyword">let</span> prototype = <span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    <span class="hljs-keyword">while</span>(proto)&#123;<br>        <span class="hljs-keyword">if</span>(proto == prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>    &#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="call、apply、bind"><a href="#call、apply、bind" class="headerlink" title="call、apply、bind"></a>call、apply、bind</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-function">(<span class="hljs-params">context</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>    &#125;<br>    <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>,);<br>    context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">let</span> result = context.<span class="hljs-title function_">fn</span>(...args);<br>    <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-function">(<span class="hljs-params">context</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>    &#125;<br>    <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>][<span class="hljs-number">1</span>];<br>    context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">let</span> result = context.<span class="hljs-title function_">fn</span>(...args);<br>    <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-function">(<span class="hljs-params">context</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>    &#125;<br>    context = context || <span class="hljs-variable language_">window</span>;<br>    <span class="hljs-keyword">let</span> fn = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>,);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Fn</span> ?<br>            fn.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, args) :<br>            fn.<span class="hljs-title function_">call</span>(context, args);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="字符串模板引擎"><a href="#字符串模板引擎" class="headerlink" title="字符串模板引擎"></a>字符串模板引擎</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">str, data</span>)&#123;<br>    <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/g</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">match, key</span>)&#123;<br>        <span class="hljs-keyword">return</span> data[key];<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">let</span> template = <span class="hljs-string">&quot;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&quot;</span>;<br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;布兰&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>,<br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;boy&quot;</span>,<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">render</span>(template, person));<br></code></pre></td></tr></table></figure><h1 id="ES5实现继承-寄生组合式继承"><a href="#ES5实现继承-寄生组合式继承" class="headerlink" title="ES5实现继承&#x2F;寄生组合式继承"></a>ES5实现继承&#x2F;寄生组合式继承</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bark</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cat</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Extends</span>(<span class="hljs-params">parent, child</span>) &#123;<br>    <span class="hljs-keyword">let</span> prototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>    prototype.<span class="hljs-property">constructor</span> = child;<br>    child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype;<br>&#125;;<br><span class="hljs-title class_">Extends</span>(<span class="hljs-title class_">Animal</span>, <span class="hljs-title class_">Cat</span>);<br><span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">barkAge</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;;<br><br><br><span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&#x27;cc&#x27;</span>, <span class="hljs-number">21</span>);<br>cat.<span class="hljs-title function_">bark</span>();<br>cat.<span class="hljs-title function_">barkAge</span>();<br></code></pre></td></tr></table></figure><h1 id="lazyMan"><a href="#lazyMan" class="headerlink" title="lazyMan"></a>lazyMan</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lazyman</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span> = [];<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`hi, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>        &#125;)<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 确保同步推入任务</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">run</span>();<br>        &#125;)<br>    &#125;;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>[i]());<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-title function_">sleep</span>(<span class="hljs-params">time</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`after <span class="hljs-subst">$&#123;time * <span class="hljs-number">1000</span>&#125;</span>`</span>);<br>                <span class="hljs-title function_">resolve</span>();<br>            &#125;, time * <span class="hljs-number">1000</span>);<br>        &#125;));<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;;<br><br>    <span class="hljs-title function_">sleepFirst</span>(<span class="hljs-params">time</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">unshift</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`after <span class="hljs-subst">$&#123;time&#125;</span>s`</span>);<br>                <span class="hljs-title function_">resolve</span>();<br>            &#125;, time * <span class="hljs-number">1000</span>);<br>        &#125;));<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;;<br><br>    <span class="hljs-title function_">eat</span>(<span class="hljs-params">thing</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`eat <span class="hljs-subst">$&#123;thing&#125;</span>`</span>);<br>        &#125;);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">LazyMan</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Lazyman</span>(name);<br>&#125;<br><br><span class="hljs-title class_">LazyMan</span>(<span class="hljs-string">&quot;Hank&quot;</span>).<span class="hljs-title function_">sleepFirst</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">eat</span>(<span class="hljs-string">&quot;dinner&quot;</span>).<span class="hljs-title function_">eat</span>(<span class="hljs-string">&quot;supper&quot;</span>);<br></code></pre></td></tr></table></figure><h1 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">urlParams2Obj</span>(<span class="hljs-params">url</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> url !== <span class="hljs-string">&quot;string&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>    <span class="hljs-keyword">let</span> index = url.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;?&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (index == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>    <span class="hljs-keyword">let</span> res = &#123;&#125;;<br>    <span class="hljs-keyword">let</span> paramsArr = url.<span class="hljs-title function_">slice</span>(index + <span class="hljs-number">1</span>,).<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);<br>    paramsArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">param</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> [key, value] = param.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>);<br>        key = <span class="hljs-built_in">decodeURIComponent</span>(key);<br>        value = value == <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">true</span> : <span class="hljs-built_in">decodeURIComponent</span>(value);<br>        <span class="hljs-keyword">if</span> (res[key]) &#123;<br>            <span class="hljs-keyword">let</span> pre = res[key];<br>            res[key] = [];<br>            res[key].<span class="hljs-title function_">push</span>(pre, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res[key] = value;<br>        &#125;;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>    <span class="hljs-title function_">urlParams2Obj</span>(<span class="hljs-string">&quot;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><h1 id="虚拟DOM转换为真实DOM"><a href="#虚拟DOM转换为真实DOM" class="headerlink" title="虚拟DOM转换为真实DOM"></a>虚拟DOM转换为真实DOM</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> vnode = &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;DIV&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">attrs</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;app&#x27;</span></span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            <span class="hljs-attr">children</span>: [&#123;</span><br><span class="language-javascript">                <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;SPAN&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">children</span>: [&#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;A&#x27;</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">children</span>: []</span><br><span class="language-javascript">                &#125;]</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;SPAN&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">children</span>: [&#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;A&#x27;</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">children</span>: []</span><br><span class="language-javascript">                &#125;,</span><br><span class="language-javascript">                &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;A&#x27;</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">children</span>: []</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">                ]</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">            ]</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.container&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// container.appendChild(render(vnode));</span></span><br><span class="language-javascript">        container.<span class="hljs-property">innerHTML</span> = <span class="hljs-title function_">render</span>(vnode);</span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">vnode</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> parent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;vnode.tag&#125;</span>`</span>);</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">attrs</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">let</span> attrsArr = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(vnode.<span class="hljs-property">attrs</span>);</span><br><span class="language-javascript">                attrsArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">                    parent[key] = vnode.<span class="hljs-property">attrs</span>[key];</span><br><span class="language-javascript">                &#125;)</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">            vnode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">                parent.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">render</span>(node));</span><br><span class="language-javascript">            &#125;)            </span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> parent;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>手写题</category>
      
      <category>高频考点</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>setTimeout</title>
    <link href="/2025/04/04/%E6%89%8B%E5%86%99%E9%A2%98/%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9/3.%20setTimeout/"/>
    <url>/2025/04/04/%E6%89%8B%E5%86%99%E9%A2%98/%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9/3.%20setTimeout/</url>
    
    <content type="html"><![CDATA[<h1 id="每隔五秒打印一个数"><a href="#每隔五秒打印一个数" class="headerlink" title="每隔五秒打印一个数"></a>每隔五秒打印一个数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printNum1</span>(<span class="hljs-params"></span>) &#123;<br>    timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">closePrintNum1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">clearInterval</span>(timer);<br>    timer = <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// printNum1();</span><br><br><span class="hljs-comment">// setTimeout(() =&gt; &#123;</span><br><span class="hljs-comment">//     closePrintNum1();</span><br><span class="hljs-comment">// &#125;, 3000);</span><br><br><br><span class="hljs-comment">// ---------------------------------------------------------------------------</span><br><span class="hljs-keyword">let</span> timer2 = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printNum2</span>(<span class="hljs-params"></span>) &#123;<br>    timer2 = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>);<br>        <span class="hljs-title function_">printNum2</span>();<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">closePrintNum2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timer2);<br>&#125;;<br><br><br><span class="hljs-comment">// printNum2();</span><br><span class="hljs-comment">// setTimeout(() =&gt; closePrintNum2(), 3000);</span><br><br><span class="hljs-comment">// ---------------------------------------------------------------------------</span><br><span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">printNum3</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>);<br>            <span class="hljs-title function_">resolve</span>();<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>    <span class="hljs-keyword">if</span> (flag) <span class="hljs-title function_">printNum3</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">closePrintNum3</span>(<span class="hljs-params"></span>) &#123;<br>    flag = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-title function_">printNum3</span>();<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">closePrintNum3</span>();<br>&#125;, <span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><h1 id="每隔一秒打印一个数字"><a href="#每隔一秒打印一个数字" class="headerlink" title="每隔一秒打印一个数字"></a>每隔一秒打印一个数字</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printNum</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span>; i++)&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>        &#125;, i * <span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">printNum</span>();<br></code></pre></td></tr></table></figure><h1 id="循环打印红绿灯"><a href="#循环打印红绿灯" class="headerlink" title="循环打印红绿灯"></a>循环打印红绿灯</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">printRGB</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Red`</span>);<br>            <span class="hljs-title function_">resolve</span>();<br>        &#125;, <span class="hljs-number">3000</span>);<br>    &#125;);<br>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Green`</span>);<br>            <span class="hljs-title function_">resolve</span>();<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Yellow`</span>);<br>            <span class="hljs-title function_">resolve</span>();<br>        &#125;, <span class="hljs-number">2000</span>);<br>    &#125;);<br>    <span class="hljs-title function_">printRGB</span>();<br>&#125;<br><span class="hljs-title function_">printRGB</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>手写题</category>
      
      <category>高频考点</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2025/04/04/%E6%89%8B%E5%86%99%E9%A2%98/%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9/2.%20Promise/"/>
    <url>/2025/04/04/%E6%89%8B%E5%86%99%E9%A2%98/%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9/2.%20Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="promiseRetry"><a href="#promiseRetry" class="headerlink" title="promiseRetry"></a>promiseRetry</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myPromiseRetry</span>(<span class="hljs-params">promise, count = <span class="hljs-number">0</span>, waitTime = <span class="hljs-number">1000</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">retry</span>(count);<br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">retry</span>(<span class="hljs-params">count</span>) &#123;<br>            <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise)<br>                .<span class="hljs-title function_">then</span>(resolve)<br>                .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>                    <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-title function_">reject</span>(err);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;again&#x27;</span>);<br>                            <span class="hljs-title function_">retry</span>(--count);<br>                        &#125;, waitTime);<br>                    &#125;<br>                &#125;)<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-number">123</span>);<br>&#125;);<br><br><span class="hljs-keyword">let</span> asyncFun = <span class="hljs-title function_">myPromiseRetry</span>(promise,<span class="hljs-number">3</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="promiseAny"><a href="#promiseAny" class="headerlink" title="promiseAny"></a>promiseAny</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myPromiseAny</span>(<span class="hljs-params">promises</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promises.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[i])<br>                .<span class="hljs-title function_">then</span>(resolve)<br>                .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>                    count++;<br>                    res[i] = err;<br>                    <span class="hljs-keyword">if</span> (count == promises.<span class="hljs-property">length</span>) <span class="hljs-title function_">reject</span>(res);<br>                &#125;);<br>        &#125;;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// const promise1 = Promise.reject(0);</span><br><span class="hljs-comment">// const promise2 = new Promise((resolve) =&gt; setTimeout(resolve, 100, &quot;quick&quot;));</span><br><span class="hljs-comment">// const promise3 = new Promise((resolve) =&gt; setTimeout(resolve, 500, &quot;slow&quot;));</span><br><br><span class="hljs-comment">// const promises = [promise1, promise2, promise3];</span><br><br><span class="hljs-comment">// myPromiseAny(promises).then((value) =&gt; console.log(value));</span><br></code></pre></td></tr></table></figure><h1 id="promiseSort"><a href="#promiseSort" class="headerlink" title="promiseSort"></a>promiseSort</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseSort</span>(<span class="hljs-params">promises</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promises.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">await</span> promises[i]();<br>    &#125;;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">promise1</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123; <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>); <span class="hljs-title function_">resolve</span>() &#125;, <span class="hljs-number">1000</span>) &#125;);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">promise2</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123; <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">456</span>); <span class="hljs-title function_">resolve</span>() &#125;, <span class="hljs-number">1000</span>) &#125;);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">promise3</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123; <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">789</span>); <span class="hljs-title function_">resolve</span>() &#125;, <span class="hljs-number">1000</span>) &#125;);<br><br><span class="hljs-keyword">const</span> promises = [promise1, promise2, promise3];<br><br><span class="hljs-title function_">promiseSort</span>(promises);<br></code></pre></td></tr></table></figure><h1 id="promiseAll"><a href="#promiseAll" class="headerlink" title="promiseAll"></a>promiseAll</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myPromiseAll</span>(<span class="hljs-params">promises</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> result = [];<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promises.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>                result[i] = res;<br>                count++;<br>                <span class="hljs-keyword">if</span> (count == promises.<span class="hljs-property">length</span>) &#123;<br>                    <span class="hljs-title function_">resolve</span>(result);<br>                &#125;<br>            &#125;).<span class="hljs-title function_">catch</span>(reject);<br>        &#125;;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="promiseRace"><a href="#promiseRace" class="headerlink" title="promiseRace"></a>promiseRace</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myPromiseRace</span>(<span class="hljs-params">promises</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promises.<span class="hljs-property">length</span>; i++)&#123;<br>            <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[i])<br>            .<span class="hljs-title function_">then</span>(resolve)<br>            .<span class="hljs-title function_">catch</span>(reject);<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="请求五秒"><a href="#请求五秒" class="headerlink" title="请求五秒"></a>请求五秒</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">requestFive</span>(<span class="hljs-params">fn</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<span class="hljs-title function_">fn</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;请求失败&#x27;</span>);<br>        &#125;, <span class="hljs-number">5000</span>);<br>    &#125;)]);<br>&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">p1</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;p1&#x27;</span>);<br>    &#125;, <span class="hljs-number">4000</span>);<br>&#125;);<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">p2</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;p2&#x27;</span>);<br>    &#125;, <span class="hljs-number">6000</span>);<br>&#125;);<br><span class="hljs-title function_">requestFive</span>(p1).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err));<br><span class="hljs-title function_">requestFive</span>(p2).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err));<br></code></pre></td></tr></table></figure><h1 id="promisify"><a href="#promisify" class="headerlink" title="promisify"></a>promisify</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 手动实现一个promisify函数的意思是：我们把一个异步请求的函数，封装成一个可以具有 then方法的函数，</span><br><span class="hljs-comment">// 并且在then方法中返回异步方法执行结果的这么一个函数</span><br><br><span class="hljs-comment">// 这个函数是回调地狱的问题</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFn</span>(<span class="hljs-params">a, b, callback</span>) &#123;<br>    <span class="hljs-comment">// 异步操作，使用 setTimeout 模拟</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;异步请求参数&#x27;</span>, a, b)<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">callback</span>(<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;异步请求结果&#x27;</span>)<br>    &#125;, <span class="hljs-number">3000</span>)<br>&#125;<br><span class="hljs-comment">// 我们希望调用的方式是</span><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-title function_">promisify</span>(asyncFn)<br><span class="hljs-title function_">proxy</span>(<span class="hljs-number">11</span>, <span class="hljs-number">22</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;正确&#x27;</span>, res)<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;错误&#x27;</span>, err);<br>&#125;)<br><br><br><span class="hljs-comment">// 用于将异步回调 callback 形式的操作或 API 转换为 promise 形式；</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">promisify</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-title function_">fn</span>(...args, <span class="hljs-function">(<span class="hljs-params">err, result</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (err) &#123;<br>                    <span class="hljs-title function_">reject</span>(err);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">resolve</span>(result);<br>                &#125;<br>            &#125;);<br>        &#125;);<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="a、b顺序渲染"><a href="#a、b顺序渲染" class="headerlink" title="a、b顺序渲染"></a>a、b顺序渲染</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> resultA = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">let</span> resultB = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">let</span> temp = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fnA</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;a渲染完毕&#x27;</span>);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fnB</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;b渲染完毕&#x27;</span>);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> flagA = <span class="hljs-literal">false</span>; <span class="hljs-comment">// a是否渲染完毕</span><br>    <span class="hljs-keyword">let</span> flagB = <span class="hljs-literal">false</span>; <span class="hljs-comment">// b是否渲染完毕</span><br>    <span class="hljs-title function_">fnA</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        resultA = res;<br>        flagA = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(flagB)&#123;<br>            resultB = temp;<br>        &#125;<br>    &#125;)<br><br>    <span class="hljs-title function_">fnB</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(flagA)&#123;<br>            resultB = res;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            temp = res;<br>        &#125;<br>        flagB = <span class="hljs-literal">true</span>;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>手写题</category>
      
      <category>高频考点</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>三栏布局</title>
    <link href="/2025/04/04/%E6%89%8B%E5%86%99%E9%A2%98/CSS%E6%89%8B%E5%86%99/4.%20%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/"/>
    <url>/2025/04/04/%E6%89%8B%E5%86%99%E9%A2%98/CSS%E6%89%8B%E5%86%99/4.%20%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.outer</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.box1</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: tomato;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.box2</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.box3</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#BFA</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="float"><a href="#float" class="headerlink" title="float"></a>float</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.box1</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: tomato;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.box2</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: right;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.box3</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#BFA</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.box1</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: tomato;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.box2</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: right;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.box3</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#BFA</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="position"><a href="#position" class="headerlink" title="position"></a>position</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.outer</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">position</span>:relative;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.box1</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">            <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: tomato;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.box2</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">            <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.box3</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#BFA</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>手写题</category>
      
      <category>CSS手写</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>两栏布局</title>
    <link href="/2025/04/04/%E6%89%8B%E5%86%99%E9%A2%98/CSS%E6%89%8B%E5%86%99/3.%20%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80/"/>
    <url>/2025/04/04/%E6%89%8B%E5%86%99%E9%A2%98/CSS%E6%89%8B%E5%86%99/3.%20%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.fatherBox</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.box1</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.box2</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fatherBox&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="float"><a href="#float" class="headerlink" title="float"></a>float</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.box1</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.box2</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.box1</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.box2</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="position"><a href="#position" class="headerlink" title="position"></a>position</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.fatherBox</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.box1</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.box2</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fatherBox&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="position2"><a href="#position2" class="headerlink" title="position2"></a>position2</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.fatherBox</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.box1</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.box2</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fatherBox&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>手写题</category>
      
      <category>CSS手写</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS手写基础</title>
    <link href="/2025/04/04/%E6%89%8B%E5%86%99%E9%A2%98/CSS%E6%89%8B%E5%86%99/1.%20%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/04/04/%E6%89%8B%E5%86%99%E9%A2%98/CSS%E6%89%8B%E5%86%99/1.%20%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.box1</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;</span><br><span class="language-css">            <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="language-css">            <span class="hljs-attribute">text-overflow</span>: ellipsis;</span><br><span class="language-css">            <span class="hljs-attribute">white-space</span>: nowrap;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.box2</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">            <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="language-css">            <span class="hljs-attribute">text-overflow</span>: ellipsis;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>: -webkit-box;</span><br><span class="language-css">            -webkit-<span class="hljs-attribute">box-orient</span>: vertical;</span><br><span class="language-css">            -webkit-<span class="hljs-selector-tag">line</span>-clamp: <span class="hljs-number">3</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span>22222222222222222222222222222222222222222222222<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span> 这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本<br>        这是一些文本这是一些文本这是一些文本这是一些文本这是一些文本<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>手写题</category>
      
      <category>CSS手写</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>垂直居中</title>
    <link href="/2025/04/04/%E6%89%8B%E5%86%99%E9%A2%98/CSS%E6%89%8B%E5%86%99/2.%20%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    <url>/2025/04/04/%E6%89%8B%E5%86%99%E9%A2%98/CSS%E6%89%8B%E5%86%99/2.%20%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.outer</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;</span><br><span class="language-css">            <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">            <span class="hljs-attribute">justify-content</span>: center;</span><br><span class="language-css">            <span class="hljs-attribute">align-items</span>: center;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.inner</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="position1"><a href="#position1" class="headerlink" title="position1"></a>position1</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html">    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.outer</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;</span><br><span class="language-css">            <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="language-css">        这个方法只适合有宽高的情况</span></span><br><span class="hljs-comment"><span class="language-css">        因为没宽高不会平分给margin而是分给width、height。</span></span><br><span class="hljs-comment"><span class="language-css">         */</span></span><br><span class="language-css">        <span class="hljs-selector-class">.inner</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">            <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: auto;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="position2"><a href="#position2" class="headerlink" title="position2"></a>position2</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.outer</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;</span><br><span class="language-css">            <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.inner</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">            <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: yellow;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>手写题</category>
      
      <category>CSS手写</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>组件</title>
    <link href="/2025/04/04/%E6%89%8B%E5%86%99%E9%A2%98/%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9/1.%20%E7%BB%84%E4%BB%B6/"/>
    <url>/2025/04/04/%E6%89%8B%E5%86%99%E9%A2%98/%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9/1.%20%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="全选"><a href="#全选" class="headerlink" title="全选"></a>全选</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>全选<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.button&#x27;</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><br><span class="language-javascript">        button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            input.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">                node.<span class="hljs-property">checked</span> = !node.<span class="hljs-property">checked</span>;</span><br><span class="language-javascript">            &#125;);</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript">        </span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="todoList"><a href="#todoList" class="headerlink" title="todoList"></a>todoList</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span>a <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span>b <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box3&quot;</span>&gt;</span>c <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;add-input&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;add-button&quot;</span>&gt;</span>新增<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;delete-button&quot;</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.container&#x27;</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> addValue = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.add-input&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> addButton = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.add-button&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> deleteButton = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.delete-button&quot;</span>);</span><br><span class="language-javascript">        addButton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;input&#x27;</span>);</span><br><span class="language-javascript">            input.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;checkbox&#x27;</span>;</span><br><span class="language-javascript">            li.<span class="hljs-property">innerText</span> = addValue.<span class="hljs-property">value</span>;</span><br><span class="language-javascript">            li.<span class="hljs-title function_">appendChild</span>(input);</span><br><span class="language-javascript">            container.<span class="hljs-title function_">appendChild</span>(li);</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript">        deleteButton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> liArr = container.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;li&#x27;</span>);</span><br><span class="language-javascript">            liArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">let</span> checkbox = node.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;input&#x27;</span>);</span><br><span class="language-javascript">                <span class="hljs-keyword">if</span> (checkbox.<span class="hljs-property">checked</span>) &#123;</span><br><span class="language-javascript">                    node.<span class="hljs-title function_">remove</span>();</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;)</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>手写题</category>
      
      <category>高频考点</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>flex</title>
    <link href="/2025/04/03/CSS/4.%20flex/"/>
    <url>/2025/04/03/CSS/4.%20flex/</url>
    
    <content type="html"><![CDATA[<h1 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h1><ul><li><a href="https://blog.csdn.net/MaNqo/article/details/119155041">https://blog.csdn.net/MaNqo/article/details/119155041</a></li><li><a href="https://juejin.cn/post/6844904016439148551">https://juejin.cn/post/6844904016439148551</a></li></ul><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><ol><li><strong>flex-direction</strong> :row column</li><li><strong>flex-wrap</strong>:nowrap wrap换行</li><li><strong>flex-flow</strong>:是flex-direction flex-wrap简写</li><li><em><strong>justify-content</strong></em>:<br>flex-start<br>flex-end<br>center<br>space-between：两端对齐，项目之间的间隔都相等。<br>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li><li><em><strong>align-items</strong></em> 一个轴：前中后、stretch。</li><li><em><strong>align-content</strong></em> 多个轴 stretch轴线占满整个交叉轴</li></ol><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><ol><li>flex-grow</li><li>flex-shrink</li><li>flex-basis:min-width、max-width &gt; flex-basis &gt; width. </li><li>flex</li><li>order</li></ol><h2 id="flex-1-10024"><a href="#flex-1-10024" class="headerlink" title="flex:1 &#10024;"></a>flex:1 &#10024;</h2><ol><li>flex是flex-grow,flex-shrink,flex-basis的缩写</li></ol><ul><li>flex-grow:定义放大的比例,<strong>默认为0</strong>,计算方式是多余的空间 * 自己的grow占所有grow的比例。</li><li>flex-shrink:定义项目缩小的比例.<strong>默认为1</strong>,大于1时候自己宽度 - 溢出空间 * （自己的宽度 &#x2F; 总压缩宽度）。</li><li>flex-basis:项目占据主轴多少的空间.<strong>默认为auto</strong>,即自身宽度.</li></ul><ol start="2"><li>flex：1 就是 flex-grow:1,flex-shrink:1,flex-basis: 0;如果每个子元素都设置了flex：1，则各个元素平分父元素剩下的区域。</li></ol><h3 id="display-flex后发生什么"><a href="#display-flex后发生什么" class="headerlink" title="display:flex后发生什么"></a>display:flex后发生什么</h3><ul><li>justify-content默认值是flex-start，align-items默认值是stretch。</li></ul><ol><li>水平排列</li><li>默认不换行</li><li>默认高度会拉伸</li></ol>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>定位</title>
    <link href="/2025/04/03/CSS/3.%20%E5%AE%9A%E4%BD%8D/"/>
    <url>/2025/04/03/CSS/3.%20%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="定位position"><a href="#定位position" class="headerlink" title="定位position"></a>定位position</h1><!-- position:static // 未开启定位 --><h2 id="定位基础"><a href="#定位基础" class="headerlink" title="定位基础"></a>定位基础</h2><ol><li><strong>偏移量left、top</strong>：元素开启定位后可以用偏移量offset设置元素的位置.top越大越往下(类似margin-top),left越大越往右(类似margin-left),一般水平或垂直方向只用一个属性.<br>偏移量只移动自己,不影响其他元素.top bottom left right</li><li><strong>z-index元素层级</strong>：开启定位的元素可通过z-index属性来指定元素的层级,z-index值越大层级越高越优先展示.相同则优先显示后面的元素,祖先元素不会盖住后代.</li></ol><h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><!-- 灵魂出窍,肉体占原来位置 --><p>position:<em><strong>relative</strong></em></p><ol><li>相对定位偏移量使相对他<em><strong>原本在文档流</strong></em>中的位置。</li><li>相对定位会提升元素的层级,但不会脱离文档流。</li></ol><h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><p>position:<em><strong>absolute</strong></em></p><ol><li>绝对定位偏移量是相对其包含块(离他最近的开启定位的祖先元素,都没则相当于根元素html)的位置</li><li>绝对定位会使元素从文档流中脱离.会改变元素性质:行内变为块.块由宽高撑开</li><li>绝对定位会提升元素的层级</li></ol><h2 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h2><p>position:<em><strong>fixed</strong></em></p><!-- 绝对定位特殊情况 --><ol><li>也会脱离文档流,也会提升元素层级</li><li>区别就是:偏移量永远相当于浏览器视口(可见范围)</li></ol><h2 id="粘滞定位"><a href="#粘滞定位" class="headerlink" title="粘滞定位"></a>粘滞定位</h2><p>position:sticky</p><ol><li>粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;</li><li>必须设置left、right、top、bottom才会生效。</li></ol><h1 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h1><ul><li><a href="https://juejin.cn/post/6844903667175260174?searchId=20250120195441FF6C0F5FBC8B925AC516#heading-0">https://juejin.cn/post/6844903667175260174?searchId=20250120195441FF6C0F5FBC8B925AC516#heading-0</a></li></ul><h2 id="元素的层叠顺序"><a href="#元素的层叠顺序" class="headerlink" title="元素的层叠顺序"></a>元素的层叠顺序</h2><ul><li>background、z-index负数、块级、浮动元素、inline、z-index为0、z-index为正。</li></ul><h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><ol><li>根层叠上下文（html）</li><li>定位属性的元素，设置了z-index可以设置层叠上下文</li><li>css3新属性设置层叠上下文</li></ol><h2 id="比较两个元素谁在上谁在下？"><a href="#比较两个元素谁在上谁在下？" class="headerlink" title="比较两个元素谁在上谁在下？"></a>比较两个元素谁在上谁在下？</h2><ol><li>先比较层叠上下文，层叠上下文高的在上。</li><li>如果在同一个层叠上下文，才考虑元素的层叠顺序规则。</li><li>都相等的情况下，后面的元素层叠更高。</li></ol><!-- 如果不在同一个层叠上下文，一个z-index为9999也不一定有另一个元素层叠级别高 -->]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浮动</title>
    <link href="/2025/04/03/CSS/2.%20%E6%B5%AE%E5%8A%A8/"/>
    <url>/2025/04/03/CSS/2.%20%E6%B5%AE%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h1><h2 id="浮动后元素特点"><a href="#浮动后元素特点" class="headerlink" title="浮动后元素特点"></a>浮动后元素特点</h2><ol><li>脱离文档流,不影响其他块元素布局，后面的元素往前补</li><li>不再独占一行（宽度不会占一行）,可以水平方向布局,往<strong>父元素</strong>左侧或右侧移动(不会超出父元素).直到遇到另一个浮动元素或者遇到它外边缘的包含框.</li><li>文字不会覆盖浮动,围绕浮动周围</li></ol><h2 id="浮动缺点"><a href="#浮动缺点" class="headerlink" title="浮动缺点"></a>浮动缺点</h2><ol><li>子元素需要水平排列,  开启浮动,父元素高度默认由子元素撑开,因为脱离文档流,<em><strong>父元素高度塌陷</strong></em>.<br>解决方法: 直接给父元素加固定高度,父元素开启BFC,伪元素方法(clearfix)</li><li>前面的元素浮动脱离文档流，后面的元素往前<em><strong>被浮动的元素覆盖</strong></em>。<br>解决办法：clear,BFC，被覆盖的是父元素（用clearfix）。</li></ol><h2 id="BFC块级格式化上下文"><a href="#BFC块级格式化上下文" class="headerlink" title="BFC块级格式化上下文"></a>BFC块级格式化上下文</h2><ol><li>BFC是隐藏的属性,可以给一个元素开启BFC,该元素就会变成一个独立的块级区域,不受外部影响.</li><li>开启BFC后特点:</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 开启BFC元素不会被浮动元素覆盖,不会发生重叠.<br>(浮动元素还是浮动的,所以后面元素会直接往上,但又不覆盖,所以在浮动元素旁边,可用于双栏布局,相反clear是类似&quot;清除&quot;了浮动的影响,相当于是个块元素,后面元素不能往上)<br><span class="hljs-bullet">2.</span> 开启BFC的父元素和子元素垂直方向外边距不会重叠<br>(父元素变一个独立的区域)<br><span class="hljs-bullet">3.</span> 开启BFC的元素可以包含浮动的子元素(解决高度塌陷)<br></code></pre></td></tr></table></figure><ol start="3"><li>开启BFC方式</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-number">1.</span> <span class="hljs-type">float</span>:left,但会从文档流中脱离,宽度没了.<br><span class="hljs-number">2.</span> position：absolute<br><span class="hljs-number">2.</span> display设置属性,行内块元素,但也是宽度没了<br><span class="hljs-number">3.</span> overflow:hidden <span class="hljs-comment">// 之前推荐这种开启BFC.</span><br><span class="hljs-number">4.</span> **display: flow-root**, 设置为块级元素，并开启这个元素的BFC。 <span class="hljs-comment">//推荐！</span><br></code></pre></td></tr></table></figure><h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><ul><li>可以通过clear属性清除左边或者右边浮动元素对当前元素所产生的影响.<br>clear: left || right || both(清除较大影响的)</li><li>原理:为元素添加外边距.</li></ul><h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><ol><li>在高度塌陷的父元素添加伪元素</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">::after</span>&#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    clear:both, // 清除浮动的影响,这样after会放到浮动元素之后.<br>    display: block, // after元素他是行内元素不会独占一行,需要转换为块元素<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="clearfix"><a href="#clearfix" class="headerlink" title="clearfix"></a>clearfix</h2><ol><li>after,content,display,clear解决高度塌陷<br> before content display解决外边距重叠</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>,<br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::before</span>&#123;<br>    <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>    display:table, //block会独占一行<br>    clear:both<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础</title>
    <link href="/2025/04/03/CSS/1.%20%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/04/03/CSS/1.%20%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h1><ol><li>！important</li><li>内联样式：style&#x3D; “color: red”</li><li>id选择器：#</li><li>类、伪类、属性选择器</li><li>元素（标签）、伪元素选择器。</li><li>通配符、子代后代选择器</li></ol><ul><li>额外点：</li></ul><ol><li>优先级高的生效，优先级相同时候，后定义的生效。</li><li>内联样式 》 内部样式 》 外部样式 》 浏览器默认样式</li></ol><h1 id="可继承和不可继承属性"><a href="#可继承和不可继承属性" class="headerlink" title="可继承和不可继承属性"></a>可继承和不可继承属性</h1><ol><li>可：font-size、font-weight、font-family、文本color、visibility</li><li>不可：盒子模型、display、background、定位。</li></ol><h1 id="display"><a href="#display" class="headerlink" title="display"></a>display</h1><ul><li>none：元素不显示，从文档流移除。</li><li>block：块元素，默认宽为父元素宽，可以设置宽高，换行显示。</li><li>inline：行内元素，宽默认为元素宽。不换行。</li><li>inline-block：行内块元素，宽默认为元素宽，可以设置宽高。</li><li>inherit：从父元素继承。</li></ul><h1 id="隐藏元素方法"><a href="#隐藏元素方法" class="headerlink" title="隐藏元素方法"></a>隐藏元素方法</h1><ol><li>display：none。</li><li>visibility：hidden。</li><li>opacity：0。</li><li>z-index：被覆盖</li></ol><h1 id="伪元素和伪类的区别"><a href="#伪元素和伪类的区别" class="headerlink" title="伪元素和伪类的区别"></a>伪元素和伪类的区别</h1><!-- - 伪类一个：，伪元素两个：：。 --><ul><li>伪元素：元素的特定一部分，<strong>这部分不是元素，不存在</strong>，比如：某一个元素的前面后面插入内容、第一行。</li><li>伪类：作用于特定状态的<strong>元素</strong>，比如：鼠标悬停、结构状态第一个孩子。</li></ul><!-- # requestAnimationframe请求动画帧 --><!-- -  --><h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><ul><li>margin，border，padding，content</li><li>box-sizing改变盒子类型</li></ul><ol><li>标准盒子模型</li></ol><ul><li>width、height只包括content</li></ul><ol start="2"><li>IE盒子模型</li></ol><ul><li>width、height包括border，padding，content</li></ul><h1 id="用transform：translate改变位置而不是position？"><a href="#用transform：translate改变位置而不是position？" class="headerlink" title="用transform：translate改变位置而不是position？"></a>用transform：translate改变位置而不是position？</h1><ul><li>transform和opcity不会触发回流重绘，只会触发复合。这两个属性会为元素单独抽离一个GPU合成层，利用GPU加速渲染。position还是利用CPU。</li></ul><h1 id="css3新特性"><a href="#css3新特性" class="headerlink" title="css3新特性"></a>css3新特性</h1><ol><li>媒体查询</li><li>伪元素、伪类</li><li>transition、animation</li><li>flex弹性布局、em、rem</li><li>box-shadow盒子阴影、border-radius圆角</li></ol><h1 id="Less预处理器"><a href="#Less预处理器" class="headerlink" title="Less预处理器"></a>Less预处理器</h1><ul><li>是css的预处理器，在css上抽象出一层，是一种特殊的语法便于开发，最终会通过比如webpack的工具转换为css。</li></ul><ol><li>变量：给颜色，字体，背景色等设置名称，达到复用的作用。</li><li>嵌套：支持css选择器的嵌套，方便读取和维护。</li><li>函数和运算：支持运算比如：变量*2，提供内置函数执行。</li><li>导入：模块化管理</li></ol><h1 id="单行，多行溢出情况？"><a href="#单行，多行溢出情况？" class="headerlink" title="单行，多行溢出情况？"></a>单行，多行溢出情况？</h1><p>单行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>:hidden; // 元素溢出如何处理：隐藏<br><span class="hljs-attribute">text-overflow</span>:ellipsis; // 如何隐藏溢出的内容：省略号<br><span class="hljs-attribute">white-space</span>:nowrap; // 空白字符是否合并，是否换行：不换行<br></code></pre></td></tr></table></figure><p>多行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>:hidden;<br><span class="hljs-attribute">text-overflow</span>:ellipsis;<br><span class="hljs-attribute">display</span>:-webkit-box;<br>-webkit-<span class="hljs-attribute">box-orient</span>:vertical;<br>-webkit-<span class="hljs-selector-tag">line</span>-clamp:<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h1 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h1><ul><li>@media 媒体类型 and{条件} and {条件}，针对不同屏幕尺寸应用不同的样式，因此可以用来设计响应式页面。</li></ul><!-- 媒体类型：all，screen，print --><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">常用例子：<br>@media screen <span class="hljs-keyword">and</span>&#123;max—width：<span class="hljs-number">400</span>px&#125; <span class="hljs-keyword">and</span> &#123;min-width：<span class="hljs-number">200</span>px&#125;<br></code></pre></td></tr></table></figure><h1 id="如何判断元素是否到达可视区域？"><a href="#如何判断元素是否到达可视区域？" class="headerlink" title="如何判断元素是否到达可视区域？"></a>如何判断元素是否到达可视区域？</h1><ul><li>scrollTop滚过的高度，innerHeight浏览器可视区域高度，offsetTop元素到文档顶部的距离。</li></ul><h1 id="z-index失效？"><a href="#z-index失效？" class="headerlink" title="z-index失效？"></a>z-index失效？</h1><ol><li>父元素是relative定位</li><li>元素position属性为static属性</li><li>元素设置z-index时候还设置了浮动float</li></ol>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础</title>
    <link href="/2025/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/04/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>设计模式：大量的项目实践总结出来的对某种业务场景下的程序编写最佳实践。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>保证一个类只有一个实例，全局提供一个访问点，解决一个频繁使用的类创建和销毁。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>登录窗口（全局唯一，频繁使用），vuex，qiankun的start启动，jquery。</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>减少内存消耗</li><li>避免资源多重占用</li></ol><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><ul><li>由两部分组成，利用<em><strong>组合-委托</strong></em>思想避免冗余的if-else。</li></ul><ol><li>策略类：策略类负责封装不同策略，提高代码复用性、可扩展性、可维护性。</li><li>环境类：根据参数委托对应的策略执行。</li></ol><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>确认策略规则对象,编写好对应的函数,比如表单检验时候的长度判断函数,不为空函数.</li><li>提交表单时候，校验参数通过环境类委托对应的策略执行。</li></ol><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h2><ul><li>给对象添加了一个代理层，由代理对象控制对原对象的引用。处理和过滤之后再交给原对象，以减轻本体对象的负担。</li></ul><h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>axios封装：添加通用请求头、身份认证信息等等；异常状态码（跳转到统一认证登录）。</li><li>Vue中数据代理： 定义为响应式的数据会被代理到组件实例上，在生成渲染函数的时候通过with添加了组件实例作用域，需要从组件实例上获取数据，触发get函数。</li><li>cache-loader代理</li></ol><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="基础-3"><a href="#基础-3" class="headerlink" title="基础"></a>基础</h2><ul><li>观察者模式由具体目标调度，没有信道中介。</li></ul><h2 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>DOM事件监听机制：DOM（目标）触发特定事件后监听器执行。</li></ul><h1 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h1><h2 id="基础-4"><a href="#基础-4" class="headerlink" title="基础"></a>基础</h2><ul><li>定义程序对象之间一种一对多的关系，当一个对象的状态变化时，所有依赖的对象都会都会得到通知并执行对应的操作。基于观察者模式进行<em><strong>通用化设计，松散耦合，灵活度更高</strong></em></li><li><em><strong>发布者</strong></em>：事件发布者将发布的事件传递给信道中介。<br> <em><strong>信道中介</strong></em>：缓存事件对应的订阅者，发布者发布时候遍历订阅者列表进行通知。<br> <em><strong>订阅者</strong></em>：定义事件发布后的操作，向信道中介发起订阅。</li></ul><h2 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>vue响应式原理：数据（发布者）发布，订阅者（watcher）调用虚拟DOM更新组件视图。</li></ul><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础</title>
    <link href="/2025/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="冯诺依曼体系结构-10024"><a href="#冯诺依曼体系结构-10024" class="headerlink" title="冯诺依曼体系结构 &#10024;"></a>冯诺依曼体系结构 &#10024;</h2><ol><li>以<em><strong>运算器</strong></em>为中心。现代计算机以<em><strong>存储器</strong></em>为中心。</li><li>五种结构：运算器，控制器，存储器，输入设备，输出设备。</li></ol><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><ul><li>由地址寄存器（MAR），数据寄存器（MDR），存储体组成。</li><li>分为内存和外存，cpu处理数据只能处理内存，外存的数据被处理要先放到内存中。</li></ul><!-- 读取：读取的地址放到地址寄存器，存储体找到后放到数据寄存器，然后CPU读取。     写入：写入的地址放到地址寄存器，写入的数据放到数据寄存器，然后写入到存储体。 --><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><ul><li>进行算术运算和逻辑运算，核心是通过ALU算术逻辑但愿进行运算。</li></ul><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><ul><li>取指令、翻译指令、分析指令，然后向有关部件发送命令，协调指挥整个计算机操作。控制器和运算器共同共同组成CPU。</li></ul><h3 id="输入设备，输出设备"><a href="#输入设备，输出设备" class="headerlink" title="输入设备，输出设备"></a>输入设备，输出设备</h3><ul><li>入：键盘，鼠标。</li><li>出：显示屏，打印机。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>加密算法</title>
    <link href="/2025/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%20%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <url>/2025/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%20%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="RSA加密算法：公钥加密算法"><a href="#RSA加密算法：公钥加密算法" class="headerlink" title="RSA加密算法：公钥加密算法"></a>RSA加密算法：公钥加密算法</h1><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><ul><li><strong>定义</strong>：小于n的正整数中，与n互质的数的个数。</li><li>如果n为质数，欧拉n &#x3D; n - 1；</li><li>如果n可以分解为两个<strong>互质</strong>的整数之积，那么n的欧拉函数等于这两个因子的欧拉函数之积。n &#x3D; p * q，且p、q互质，则n的欧拉函数  &#x3D; （p - 1）*（q - 1）。</li></ul><!-- 互质：公约数只有1的两个整数质数：除了1和本身不再有其他因数的自然数。 --><h2 id="模反元素"><a href="#模反元素" class="headerlink" title="模反元素"></a>模反元素</h2><ul><li>如果两个正整数e和m互质，那么一定能找到一个整数d，使得ed - 1被 m 整除，或者说ed 除以 m 所得余数为1.</li><li>此时，d就叫做e的模反元素。</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>RSA算法与三个随机数的关系是：RSA确保预主密钥（也就是第三个随机数）的安全传输，而三个随机数共同参与会话密钥的生成。</li><li><strong>基于大整数分解</strong>的复杂难题：计算私钥靠模反函数，模反函数依赖欧拉函数m，m是一个大整数，很难分解为两个质数。<br>（攻击者知道p、q的乘积，不知道怎么拆分成p、q，也就无法计算这个大整数的欧拉函数）</li></ul><ol><li>选择两个不相等且足够大的质数p、q。</li><li>计算p、q的乘积，n &#x3D; p * q。</li><li>计算n的欧拉函数m &#x3D; （p - 1）*（q - 1）。</li><li>选一个与m互质的整数e。1 &lt; e &lt; m。 <strong>公钥（e,n）</strong></li><li>计算出e对于m的模反元素d：<strong>私钥(d,n)</strong>。</li></ol><p><img src="/2025/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%20%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/image.png" alt="alt text"></p><h2 id="RSA密钥协商算法的缺点"><a href="#RSA密钥协商算法的缺点" class="headerlink" title="RSA密钥协商算法的缺点"></a>RSA密钥协商算法的缺点</h2><ul><li>RSA密钥协商算法的最大缺点是不支持前向加密。客户端第三次握手是使用公钥加密传输第三个随机数，如果服务端的私钥被拿到，则可以计算出会话密钥，之前通信的数据都可以破解。</li></ul><h1 id="ECDHE算法"><a href="#ECDHE算法" class="headerlink" title="ECDHE算法"></a>ECDHE算法</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><ol><li>ECDHE算法支持前向保密。</li><li>不用等四次握手，可以提前发送加密数据。<!--减少了1RTT--></li></ol><h2 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h2><ul><li>（离散）对数：幂数</li><li>底数：幂数下的数</li><li>模数：mod 后的数</li><li>真数：运算后右边的数<br><img src="/2025/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%20%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/image-1.png" alt="alt text"></li></ul><h2 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h2><ul><li>知道真数，很难推出对数；知道对数，正常运算就能推出真数。</li></ul><ol><li>双方确定 <strong>模数</strong> 和 <strong>底数</strong>，各自选一个数作为<strong>私钥</strong>。</li><li>计算出各自的公钥。<br>小红的公钥记作 A，A &#x3D; G ^ a ( mod P )；<br>小明的公钥记作 B，B &#x3D; G ^ b ( mod P )；<br><img src="/2025/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%20%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/image-2.png" alt="alt text"></li><li>协商出来的K作为<strong>会话密钥</strong>。</li></ol><h2 id="DHE算法"><a href="#DHE算法" class="headerlink" title="DHE算法"></a>DHE算法</h2><ol><li>每次我生成的私钥不同，生成的K也不同，就可以支持前向保密了。每个通信的私钥都是不一样的。</li></ol><!-- DH、DHE算法看了，ECDHE算法是用椭圆曲线做了优化，具体算法没看懂 --><h2 id="ECDHE算法-1"><a href="#ECDHE算法-1" class="headerlink" title="ECDHE算法"></a>ECDHE算法</h2><ol><li>ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运输层</title>
    <link href="/2025/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%20%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <url>/2025/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%20%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<ul><li>一台主机的应用进程和另一台主机的应用进程通信，网络层负责主机与主机之间的通信。</li></ul><h1 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h1><ol><li><em><strong>可靠</strong></em>：可靠，不可靠</li><li><em><strong>连接</strong></em>：建立连接，不建立连接</li><li><em><strong>控制</strong></em>：tcp有流量控制拥塞控制，udp没有</li><li><em><strong>服务</strong></em>：tcp一对一，udp一对多</li><li><em><strong>传输</strong></em>：字节流：tcp的数据包可以按字节大小拆分成多个数据包，udp每次一个包一个包完整的发送。</li></ol><h1 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h1><h2 id="前置基础"><a href="#前置基础" class="headerlink" title="前置基础"></a>前置基础</h2><ol><li>停止-等待协议：发送数据包后，等对方确认才能发送下一个数据包。</li><li>超时重传：如果长时间未收到应答，发送方重新发送数据。</li><li>回退N帧协议：一个窗口内的数据一同发送，提高信道利用率。</li></ol><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ol><li><strong>是什么</strong>：TCP采用的是请求-应答的机制，确保数据传输的可靠性。如果请求一次，等待应答再发送下一次就导致效率很低。所以引入了窗口概念，无需等待应答，窗口内的数据都能够发送.</li><li><strong>工作流程</strong>：发送方：收到应答后，滑动窗口就往后移动，后面的数据就可以继续发送。接收方：收到数据并确认后往后移动，可以接受更多的数据发送。</li></ol><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><ul><li>让发送方发送速率不要过快，要让接收方来得及接受。</li></ul><ol><li>接收窗口：接收方在tcp头部告诉发送方自己的接收窗口大小，接收方的发送窗口大小不能超过接收窗口大小。</li><li>零窗口探测：接收窗口是零；接收方发送更改接收窗口大小不为0情况，但丢失。&#x3D;&gt; 持续计时器，收到零窗口通知后开启，到达时间后发送零窗口探测报文。</li></ol><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><ul><li>防止过多数据注入网络，避免路由器或链路过载。</li></ul><ol><li><em><strong>慢开始算法</strong></em>：呈<em><strong>指数增长</strong></em>往网络中注入字节数据，同时有个慢开始门限，避免增长过快。</li><li><em><strong>拥塞避免算法</strong></em>：当拥塞窗口大于慢开始门限后进行拥塞避免算法，线性增长窗口大小.</li><li><em><strong>超时重传</strong></em>：拥塞窗口设置为1，慢开始门限设置为滑动窗口大小的一半，重新开始慢开始算法和拥塞避免算法。</li><li><em><strong>快重传</strong></em>：对已收到的报文立即确认，重复的报文也发送确认，发送方收到三次确认后立即发送。</li><li><em><strong>快恢复</strong></em>：快重传后执行，将慢开始门限调整到滑动窗口大小的一半，再将窗口大小设置和慢开始门限一样，后续进行拥塞避免算法。</li></ol><p><img src="/2025/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%20%E8%BF%90%E8%BE%93%E5%B1%82/image-5.png" alt="alt text"><br><img src="/2025/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%20%E8%BF%90%E8%BE%93%E5%B1%82/image-4.png" alt="alt text"></p><blockquote><p>流量控制和拥塞控制区别：流量控制是端到端问题，控制发送方速率，让接收方来得及接收；拥塞控制是一个全局性的过程。</p></blockquote><h1 id="tcp三次握手流程"><a href="#tcp三次握手流程" class="headerlink" title="tcp三次握手流程"></a>tcp三次握手流程</h1><ol><li>开始双方都处于close状态，服务端主动进入listen状态。</li><li><em><strong>第一次握手</strong></em>：客户端发送SYN同步位为1，把初始化序号放到序号中。进入SYN-sent。</li><li><em><strong>第二次握手</strong></em>：服务端收到后发送SYN同步位、ACK确认位为1，确认号为客户端序号下一位，初始化序号放到序号中。进入SYN-REC状态。</li><li><em><strong>第三次握手</strong></em>：客户端最后应答,ACK&#x3D;1,确认号为服务端序号下一位,这时可以携带数据发送.客户端进入ESTABLISHED状态</li><li>服务端收到后也进入ESTABLISHED(既定)状态.</li></ol><h1 id="tcp不能两次握手的原因"><a href="#tcp不能两次握手的原因" class="headerlink" title="tcp不能两次握手的原因"></a>tcp不能两次握手的原因</h1><ol><li><em><strong>避免历史连接和资源浪费</strong></em>：上一次握手失败后建立新的握手，如果旧的SYN信号此时到达，服务端会与其建立连接导致资源的浪费，<strong>服务端没有中间状态给客户端来阻止历史连接</strong>。如果是三次握手，客户端在收到第二次握手后发送RST报文中止连接。</li><li><em><strong>同步双方序列号</strong></em>：两次握手只能服务端初始化序列号，客户端无法得知服务端的初始序号。</li></ol><h1 id="tcp可以四次握手的原因"><a href="#tcp可以四次握手的原因" class="headerlink" title="tcp可以四次握手的原因"></a>tcp可以四次握手的原因</h1><ul><li>三次握手中的第二个部分分为：确认序列号，同步序列号，可以合成一次握手发送。</li></ul><h1 id="每次建立tcp的初始化序列号不一致"><a href="#每次建立tcp的初始化序列号不一致" class="headerlink" title="每次建立tcp的初始化序列号不一致"></a>每次建立tcp的初始化序列号不一致</h1><ol><li>避免历史报文被下一个相同的连接接收。</li><li>防止攻击者伪造相同的序列号被接收。</li></ol><h1 id="第一二三次握手丢失发生什么"><a href="#第一二三次握手丢失发生什么" class="headerlink" title="第一二三次握手丢失发生什么"></a>第一二三次握手丢失发生什么</h1><ol><li>第一次: 客户端重传(没得到服务端响应),达到最大次数断开连接.</li><li>第二次: 客户端重传(没得到服务端响应),服务端重传(没得到客户端响应),达到最大次数断开连接.</li><li>第三次: 服务端重传,客户端收到后再重传第三次握手.(ACK应答不会主动传)</li></ol><h1 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h1><ul><li>攻击者用不同ip向服务端发送第一次握手连接，服务端每接收一个SYN就进入SYN-REC状态，服务端发送的第二次握手SYN+ACK不会被应答，这样服务端半连接队列被占满。</li><li>解决方法：</li></ul><ol><li>增大半连接队列。</li><li>减少SYN-ACK重传次数。</li></ol><h1 id="tcp四次挥手流程"><a href="#tcp四次挥手流程" class="headerlink" title="tcp四次挥手流程"></a>tcp四次挥手流程</h1><ol><li>客户端发送FIN &#x3D; 1标志位的第一次挥手请求，进入FIN-wait1状态。</li><li>服务端接收后返回ACK &#x3D; 1的第二次挥手请求，进入close-wait状态。</li><li>客户端进入FIN-wait2状态。</li><li>服务端如果有数据继续进行发送。</li><li>服务端发送 FIN &#x3D; 1的第三次挥手请求，进入last-ack状态。</li><li>客户端发送ACK &#x3D; 1的第四次挥手请求，进入time-wait状态。</li><li>服务端收到后进入close状态。</li><li>客户端等待2MSL（报文最大生存时间）后关闭。</li></ol><h1 id="tcp可以三次挥手的原因"><a href="#tcp可以三次挥手的原因" class="headerlink" title="tcp可以三次挥手的原因"></a>tcp可以三次挥手的原因</h1><ol><li>服务端没有数据需要发送且开启了tcp延迟确认机制，则可以将第二、三次挥手合为一次挥手。</li><li>tcp延迟确认机制：解决ack传输效率低的问题：ack延迟一段时间，等待是否有数据一起发送。</li></ol><h1 id="第一二三四次挥手丢失发生什么"><a href="#第一二三四次挥手丢失发生什么" class="headerlink" title="第一二三四次挥手丢失发生什么"></a>第一二三四次挥手丢失发生什么</h1><ol><li>第一次:客户端重传,达到最大次数后进入close状态</li><li>第二次:(ACK不会主动超时重传)客户端重传,服务端收到后再发送ACK.客户端达到最大次数后进入close状态.</li><li>第三次:服务端重传,达到最大次数后服务端close,客户端<em><strong>FIN_WAIT2状态等60s</strong></em>后进入close.</li><li>第四次:服务端重传,达到最大次数后close,客户端收到fin会重置TIME_WAIT时间(这里要原本等2MSL)</li></ol><h1 id="等待时间是2MSL原因"><a href="#等待时间是2MSL原因" class="headerlink" title="等待时间是2MSL原因"></a>等待时间是2MSL原因</h1><ul><li>2MSL（报文最大生存时间）允许ACK丢失一次，服务端进行FIN重传可在2MSL内到达。</li></ul><h1 id="time-wait状态的意义"><a href="#time-wait状态的意义" class="headerlink" title="time-wait状态的意义"></a>time-wait状态的意义</h1><ol><li>因为序号和确认号是循环的,防止历史连接的数据被错误的接受.2MSL可以让这次网络的数据都会丢失或者接受完毕.</li><li>确保被动关闭的一方能正确关闭.被动关闭方没收到ACK信号可以重传.</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>http</title>
    <link href="/2025/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%20http/"/>
    <url>/2025/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%20http/</url>
    
    <content type="html"><![CDATA[<h1 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>强制缓存,协商缓存</li><li>长连接,短链接</li><li>Host头部字段(解决一个ip对应到多个域名的问题,指明域名)</li><li>增加了http状态码</li><li>可以局部请求</li><li>(管道传输)</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>无状态 &#x3D;&gt; cookie解决</li><li>明文传输 &#x3D;&gt; https</li></ol><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol><li><strong>避免http请求的发送</strong>：强制缓存协商缓存</li><li><strong>减少http请求的发送</strong>：减少重定向(代理服务器处理重定向),按需请求</li><li><strong>减少http请求量体</strong>：压缩减少请求体量</li></ol><h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>非对称加密和对称加密结合:tls握手非对称加密传输第三个随机数.</li><li>防止内容篡改:私钥加密内容的hash值,公钥解密hash值,并计算内容的hash值进行对比,相同则内容未篡改.</li><li>身份认证:数字证书,CA私钥加密,浏览器内置的公钥解密,验证服务器身份.</li></ol><h2 id="tls握手"><a href="#tls握手" class="headerlink" title="tls握手"></a>tls握手</h2><ol><li>客户端发送三个参数：<em><strong>随机数,支持的tls版本号,密码套件</strong></em>给服务端</li><li>服务端返回四个：<em><strong>随机数,选择一个atls版本号,选择一个密码套件,数字证书</strong></em></li><li>客户端<em><strong>验证数字证书后取出公钥,生成第三个随机数,用服务端公钥加密传输第三个随机数,并通知后续采用加密传输.</strong></em></li><li>服务端获取<em><strong>第三个随机数生成会话密钥,通知后续采用加密传输</strong></em></li></ol><h2 id="数字证书验证"><a href="#数字证书验证" class="headerlink" title="数字证书验证"></a>数字证书验证</h2><ul><li>CA对公钥、有效时间、颁发者等信息进行hash运算，通过私钥签名生成数字证书。客户端拿到数字证书后用内置的公钥解密，计算hash值对比，相同则说明身份是正确的。</li></ul><h2 id="证书信任链"><a href="#证书信任链" class="headerlink" title="证书信任链"></a>证书信任链</h2><ul><li>根证书信任了某些中间证书用私钥加密，中间证书给服务器公钥颁发数字证书。</li><li>我们可以先用根证书的公钥验证中间证书 &#x3D;》 获取中间证书的公钥；再去验证服务器的数字证书。</li></ul><h2 id="https一定安全-中间人攻击"><a href="#https一定安全-中间人攻击" class="headerlink" title="https一定安全?中间人攻击"></a>https一定安全?中间人攻击</h2><ul><li>tls第二次握手服务端返回数字证书时候中间人服务器获取,中间人获取服务端公钥,把自己伪造的公钥数字证书给客户端.(客户端如果信任非法的数字证书就会导致https不安全),第三次握手用自己伪造的私钥解密客户端信息获取第三个随机数中间人根据三个随机数和密码套件生成会话密钥.</li><li>解决方案：http双向认证，客户端也有自己的公私钥，把自己的证书发送给服务端，服务端用根证书验证后获取客户端公钥，后续用客户端公钥加密通信。</li></ul><h2 id="https的缺点"><a href="#https的缺点" class="headerlink" title="https的缺点"></a>https的缺点</h2><ol><li>性能开销：https需要tls四次握手协商会话密钥；每次通信都需要经过会话密钥加解密。</li><li>断开重连：https连接断开后重新握手成本更高。</li><li>成本问题：购买证书，证书需要定期更新和维护。</li><li>隐藏问题：中间人攻击。</li></ol><h2 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h2><ol><li>tls1.2升级到1.3,RSA算法&#x3D;&gt;ECDHE算法,1RTT后即可通信</li><li>证书有效期验证:服务器请求CA(CA私钥加密,防止服务器篡改)证书有效期,客户端请求服务器时候顺带返回证书有效期,避免让客户端请求CA.</li><li>会话复用:类似token,session机制</li></ol><h1 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h1><h2 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h2><ol><li>静态表,哈夫曼编码,动态表</li></ol><h2 id="二进制帧-为并发传输服务"><a href="#二进制帧-为并发传输服务" class="headerlink" title="二进制帧(为并发传输服务)"></a>二进制帧(为并发传输服务)</h2><h2 id="并发传输"><a href="#并发传输" class="headerlink" title="并发传输"></a>并发传输</h2><ul><li>每个TCP连接下有多个stream流,每个stream流里面对应一个http请求和响应,每个请求或响应由一个或多个二进制帧组成.各个stream之间可以并发传递数据.(但注意,tcp层只能按顺序接收,可能出现后续数据到达但tcp无法向上交付的问题)</li></ul><h2 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h2><ul><li>客户端请求html文件,服务器主动推送css文件.</li></ul><h1 id="http3-0"><a href="#http3-0" class="headerlink" title="http3.0"></a>http3.0</h1><h2 id="http层"><a href="#http层" class="headerlink" title="http层"></a>http层</h2><ul><li>扩充了静态表</li></ul><h2 id="无队头阻塞"><a href="#无队头阻塞" class="headerlink" title="无队头阻塞"></a>无队头阻塞</h2><ul><li>各个stream流数据只要完整到达就可被接受,各个stream流之间无影响.因为采用了UDP协议</li><li>UDP协议也会保证可靠性,一个流中的数据包有唯一id,一个流中数据包丢失,即使其他数据包到达也无法读取.</li></ul><h2 id="更快建立连接"><a href="#更快建立连接" class="headerlink" title="更快建立连接"></a>更快建立连接</h2><ul><li>quic协议和tls协议没有分层,在自己帧中携带tls的记录.并且采用tls1.3,仅需1RTT即可完成连接和密钥协商.</li></ul><h2 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h2><ul><li>基于tcp的http协议采用的是四元组确定tcp连接,quic协议通过连接id来标记两个端点.</li></ul><h1 id="quic协议如何确保可靠性"><a href="#quic协议如何确保可靠性" class="headerlink" title="quic协议如何确保可靠性"></a>quic协议如何确保可靠性</h1><ol><li><strong>递增、乱序确认</strong>：每个请求报文的id都是递增的，即使是重传的也是递增的（和之前的不一样），服务端可以<strong>乱序确认</strong>，滑动窗口后移，解决了队头阻塞。</li><li><strong>streamID + 偏移量</strong>：确保数据的有序性，每个数据虽然重传后id不一样，但偏移量是不变的。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础</title>
    <link href="/2025/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%20%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/04/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%20%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h1><ol><li>200,204,206</li><li>301,302,304</li><li>400,403,404</li><li>500,502</li></ol><h1 id="http头部字段"><a href="#http头部字段" class="headerlink" title="http头部字段"></a>http头部字段</h1><ol><li><strong>host</strong>:请求服务器的域名</li><li><strong>connection</strong>:keep-alive, http1.1,长连接</li><li><strong>expires&#x2F;cache-control</strong>:强制缓存</li><li><strong>last-modified&#x2F;if-modified-since  if-none-match&#x2F;etag</strong>:协商缓存</li><li><strong>accept，content-type</strong>:服务端返回数据类型。</li><li><strong>accept-encoding，content-encoding</strong>：数据压缩方法。</li></ol><h2 id="http1-1与http1-0区别"><a href="#http1-1与http1-0区别" class="headerlink" title="http1.1与http1.0区别"></a>http1.1与http1.0区别</h2><ol><li>强制缓存,协商缓存</li><li>host字段：解决一个ip地址对应多个域名。</li><li>增加更多状态码</li><li>允许局部请求</li><li>短连接,长连接</li></ol><h1 id="get和post请求区别"><a href="#get和post请求区别" class="headerlink" title="get和post请求区别"></a>get和post请求区别</h1><ol><li>获取数据,修改数据</li><li>get请求是在url后面长度和编码都有限制，post请求没有，post请求有请求体。</li><li>get是幂等安全的,post不是</li><li>get可以做强制缓存和协商缓存</li></ol><h1 id="TCP-IP网络模型四层模型"><a href="#TCP-IP网络模型四层模型" class="headerlink" title="TCP&#x2F;IP网络模型四层模型"></a>TCP&#x2F;IP网络模型四层模型</h1><ol><li><strong>应用层</strong>:定义通信的规则和数据格式（HTTP、http数据格式），身份认证（HTTPS），错误处理（HTTP状态码）。</li><li><strong>传输层</strong>:TCPUDP,将应用层报文作为数据部分,添加TCP头部(IP地址,端口信息,SYN,FIN标志位)流量控制,拥塞控制,可靠传输,有端口号信息,负责把数据交付给对应的应用程序.</li><li><strong>网络层</strong>:IP协议,将传输层报文作为数据部分,添加IP头部,每一个设备对应一个ip地址:网络号+主机号,各个局域网通过路由器连接起来,路由器作用就是找到目的地址的子网,找到后把数据包发送到对应的子网了. </li><li><strong>数据链路(网络接口)层</strong>:在ip数据基础上再加MAC头部尾部,封装成数据帧.ARP地址解析协议(ip与mac地址的映射表)通过mac地址找到对应的主机.</li></ol><h1 id="ARP地址解析协议"><a href="#ARP地址解析协议" class="headerlink" title="ARP地址解析协议"></a>ARP地址解析协议</h1><ol><li>源主机在自己的ARP缓存表查找是否存在ip对应的mac地址，若存在，则封装mac帧发送；若不存在，则发送arp请求广播帧。</li><li>目的主机收到广播帧后，将源主机的ip地址和mac地址记录到自己的ARP缓存表中，并发送ARP响应单播帧返回给源主机，arp响应里包含目的主机的ip地址和mac地址。</li></ol><h1 id="输入url后会发生什么"><a href="#输入url后会发生什么" class="headerlink" title="输入url后会发生什么?"></a>输入url后会发生什么?</h1><ol><li><em><strong>解析URL</strong></em>:生成对应的HTTP请求</li><li><em><strong>缓存</strong></em>:浏览器本地是否有缓存</li><li><em><strong>DNS解析</strong></em>:查询域名对应的ip地址,先从本地域名服务器查看是否有缓存,无缓存本地域名服务器向根域名服务器请求,根域名服务器给出顶级域名服务器(.com)的ip,本地域名服务器向顶级域名服务器请求,顶级域名服务器给出权威域名服务器ip,本地域名服务器向权威域名服务器请求,获取对应的ip.</li><li><em><strong>TCP三次握手</strong></em></li><li><em><strong>TLS四次握手(HTTPS)</strong></em></li><li><em><strong>路由器转发</strong></em></li><li><em><strong>交换机转发</strong></em></li><li><em><strong>数据返回到浏览器,浏览器渲染过程</strong></em></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器进程</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/3.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/3.%20%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h1><h2 id="四种进程"><a href="#四种进程" class="headerlink" title="四种进程"></a>四种进程</h2><ol><li>浏览器进程：管理窗口和用户界面，地址栏、书签、前进、后退等功能，协调其他进程。</li><li>渲染进程：负责页面渲染工作。包括<em><strong>渲染线程，js引擎线程，异步http请求线程（用户发送请求后会将该请求传递给网络进程处理）</strong></em>。</li><li>插件进程：处理插件的运行。</li><li>GPU进程：处理图形渲染。</li></ol><h2 id="浏览器为什么要限制请求并发数？"><a href="#浏览器为什么要限制请求并发数？" class="headerlink" title="浏览器为什么要限制请求并发数？"></a>浏览器为什么要限制请求并发数？</h2><ol><li>对操作系统端口资源的考虑：操作系统开放了一半端口对外请求，一个http&#x2F;tcp请求占据一个端口，防止端口资源消耗殆尽。</li><li>避免频繁的线程切换：线程和http请求相对应，如果并发数量过大会导致频繁切换线程。</li><li>避免同一客户端发送大量请求超过服务端并发</li><li>客户端良知机制：防止两个应用抢占资源时候强势一方导致弱势一方永远阻塞。</li><li>http队头阻塞：tcp队头阻塞。</li></ol><h2 id="如何解决浏览器请求次数限制？"><a href="#如何解决浏览器请求次数限制？" class="headerlink" title="如何解决浏览器请求次数限制？"></a>如何解决浏览器请求次数限制？</h2><ul><li><a href="https://segmentfault.com/a/1190000039157302">https://segmentfault.com/a/1190000039157302</a></li></ul><ol><li>http2.0，http3.0 解决队头阻塞，并发请求。</li><li>使用缓存，减少请求量。</li><li>合并请求，减少请求次数。</li><li>按需加载。</li><li>域名分散。</li></ol><h2 id="浏览器组成"><a href="#浏览器组成" class="headerlink" title="浏览器组成"></a>浏览器组成</h2><ol><li>用户界面：地址栏、书签栏、前进、后退等等。</li><li>浏览器主引擎：渲染引擎和用户界面的桥梁，处理用户交互，传递信息给渲染引擎。</li><li>渲染引擎：浏览器渲染过程。</li><li>js引擎：解析和执行js。</li><li>网络模块：发送请求和加载资源。</li><li>数据存储：cookie、localStorage、SessionStorage、indexedDB等等</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>进程管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>锁</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/5.%20%E9%94%81/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/5.%20%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><ul><li>互斥锁和自旋锁是最基本的锁,读写锁可以基于这两个锁进行实现,前面这些锁都是悲观锁.</li></ul><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><ol><li>互斥锁加锁失败,当前进程进入阻塞队列,不占据CPU资源</li><li>适合等待时间长</li></ol><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><ol><li>自旋锁加锁失败会占据CPU资源,循环等待资源的释放.</li><li>适合等待时间短,减少上下文切换的成本</li></ol><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><ol><li>读优先锁:尽可能多的读锁,挺高并发性,读锁会阻塞写锁.能继续加读锁.</li><li>写优先锁:如果有写锁,则不能继续加读锁.</li></ol><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><ol><li>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。</li></ol><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><ol><li>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</li><li>服务端返回版本号,修改完之后发送旧版本号,相同则操作成功,否则失败.</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>进程管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>死锁</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/4.%20%E6%AD%BB%E9%94%81/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/4.%20%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>两个共有资源两把锁,两个线程各持有一个锁,都在等另一把锁释放,就造成了死锁.</li></ul><h2 id="四个条件"><a href="#四个条件" class="headerlink" title="四个条件"></a>四个条件</h2><ol><li>互斥条件:这个资源不能被多个线程同时访问.</li><li>持有并等待条件:线程在等待资源时候不会释放自己已有的资源.</li><li>不可剥夺条件:自己已有的资源不会被其他线程剥夺.</li><li>环路等待条件:两个线程获取资源顺序形成环路.</li></ol><h2 id="避免死锁问题"><a href="#避免死锁问题" class="headerlink" title="避免死锁问题"></a>避免死锁问题</h2><ul><li>破坏其中一个条件,一般是资源有序分配 &#x3D;&gt; 破坏环路条件.</li><li>A、B两个资源，线程获取A，再获取B。另一个线程也要先获取A才能获取B。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>进程管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>进程的通信</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/2.%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/2.%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><ol><li>半双工,管道传输数据是单向的，双向进程通信需要两个管道</li><li>管道是内核中的一段缓存,写入后必须等被读完才能退出(写进程被空占据)</li></ol><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><ul><li>进程把消息放到内核的消息队列中既可以退出.缺点是读取不及时,大小有限制.拷贝内核数据要从用户态切换为内核态.</li></ul><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><ol><li>进程有自己的虚拟空间,映射到一个物理空间</li><li>两个进程的<em><strong>虚拟空间映射到同一个物理空间</strong></em>既可以实现通信</li></ol><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><ul><li>实现进程的互斥和异步,防止多个进程修改同一个共享内存</li><li>P操作-1,V操作+1</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>进程管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程线程</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/1.%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/1.%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ol><li>运行中的程序就是进程,包括数据段,程序段,PCB(进程控制块:描述进程的信息,比如程序存放的位置);</li><li>资源分配的单位</li></ol><ul><li>cpu如果只执行一个进程，这个进程读硬盘时候就会很慢，cpu在傻等。所以有了cpu并发执行管理多个进程，提高cpul利用率。就有了<strong>进程状态、进程管理</strong>的概念。</li></ul><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><ul><li><strong>创建态,就绪态,运行态,阻塞态,结束态</strong>.</li><li><strong>就绪挂起态,阻塞挂起态</strong>.大量阻塞态会占据有限的内存,可以将这些进程放到外存(磁盘中)<br><img src="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/1.%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/image-1.png" alt="alt text"></li></ul><h2 id="进程的控制和管理"><a href="#进程的控制和管理" class="headerlink" title="进程的控制和管理"></a>进程的控制和管理</h2><ol><li>PCB(进程的唯一标识):进程的状态,进程的优先级,CPU上下文信息</li><li><em><strong>链表存储</strong></em>：相同状态存放在一起,比如:就绪队列,阻塞队列.更适应进程<strong>创建、销毁多</strong>的场景.</li></ol><h2 id="线程-并发-共享资源"><a href="#线程-并发-共享资源" class="headerlink" title="线程:并发 共享资源"></a>线程:并发 共享资源</h2><ol><li><strong>进程下的一条执行流程</strong></li><li><strong>可以并发且共享资源的执行</strong></li><li>CPU调度的基本单位</li></ol><h2 id="进程和线程的区别-10024"><a href="#进程和线程的区别-10024" class="headerlink" title="进程和线程的区别 &#10024;"></a>进程和线程的区别 &#10024;</h2><ol><li>根本区别:进程是操作系统资源分配的基本单位,线程是CPU任务调度和执行的基本单位.</li><li>关系:进程包含一个或多个线程</li><li>资源开销:进程有独立的数据段和程序段,程序之间切换成本大;线程是轻量级的进程,同一进程下的线程共享程序段和数据段,线程有自己独立的PC(程序计数器:记录下一条指令的位置)和执行栈,创建速度快，销毁速度快，线程切换成本低速度快.适合并发执行。</li></ol><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ul><li>进程状态改变时候比如：运行态到终止、运行到阻塞、就绪到运行，都会使用到调度算法。CPU更换新的进程来执行。</li></ul><ol><li>先来先服务算法：对短作业不利，要等长作业很久。</li><li>短作业优先算法：对长作业不利，可能一直等。</li><li>最高响应比算法：理想型算法，无法实现。<br>(等待时间 + 要求服务时间)&#x2F; 要求服务时间</li><li>时间片轮转算法：每个进程分配一个时间片，允许进程在该时间片执行。</li><li>最高优先级算法：CPU选择优先级最高的进程执行代码。静态优先级、动态优先级；抢占式、非抢占式。抢占式可能导致优先级低的永远无法执行。</li><li>多级反馈队列算法：多个队列，每个队列优先级从高到低排列，同时优先级越高时间片越短。  先进入最高优先级队列，没执行完进入下一级优先队列。对于短作业来说，很可能在最高优先级队列的时间片就执行完毕；对于长作业来说，进入到后面优先级更低的队列，但是执行时间变长了。<strong>短作业优先级高，执行时间短；长作业优先级低，执行时间长。</strong></li></ol><!-- 如果执行低优先级的长作业时候有短作业进入，则会先去执行短作业。 -->]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>进程管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟内存</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><ul><li>程序使用的内存是虚拟内存，操作系统内部将其与物理内存映射。避免各个程序物理地址冲突。操作系统通过 <strong>内存分段、内存分页</strong>两种方式实现虚拟内存到物理内存的映射。</li></ul><ol><li>内存扩展：物理内存有限，虚拟内存可以先把程序部分数据暂存到硬盘中，需要时候再调度进来。</li><li>进程隔离：各个进程运行在自己的虚拟内存中，操作系统内实现虚拟内存到物理内存的映射，避免进程访问错误。</li><li>内存管理：通过分页分段管理内存，更加有效的分配和回收内存，减少内存碎片化。</li></ol><!-- 操作系统是如何管理虚拟地址与物理地址之间的关系？主要有两种方式，分别是内存分段和内存分页 --><h2 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li>程序由若干个逻辑段组成，比如程序段、数据段，分段就是把这些段分离开来。分段的虚拟内存由<em><strong>段选择因子</strong></em>和<em><strong>段内偏移量</strong></em>。</li></ul><ol><li><em><strong>段选择因子</strong></em>：核心是<em><strong>段号</strong></em>，段号索引到段表的一个条目，这个条目有<strong>段基地址和段边界</strong></li><li><em><strong>段内偏移量</strong></em>：位于0和段边界之间，段基地址 + 段偏移量 &#x3D; 物理地址</li></ol><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ol><li><em><strong>外部内存碎片</strong></em>：每个段大小长度不固定，会产生多个不连续的小段内存（外部内存碎片），导致新程序无法加载。</li></ol><h3 id="解决方方案"><a href="#解决方方案" class="headerlink" title="解决方方案"></a>解决方方案</h3><ol><li><em><strong>内存交换</strong></em>：将内存中的应用写到硬盘上，再写回内存中，但写回的位置不再是原来的位置，而是紧跟前面的内存。</li></ol><h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><ul><li>分页是把物理内存提前划分好为一个个固定大小的空间，页与页之间紧密排列，虚拟地址和物理地址通过页表映射。</li><li>分页机制下，虚拟地址分为<em><strong>页号</strong></em>和<em><strong>页内偏移量</strong></em>，页号是页表的索引，页表包含物理页每页的基地址，再加上偏移量就得到物理地址。</li></ul><h3 id="存在的问题-1"><a href="#存在的问题-1" class="headerlink" title="存在的问题"></a>存在的问题</h3><ul><li><em><strong>内存分页机制会有内部内存碎片</strong></em>：采用了分页，页与页之间是紧密排列的，所以不会有外部内存碎片；但内存分配最小是一页，即使程序不足一页也会分配一个页，所以页面内会出现内存浪费。</li><li><em><strong>页表占据大量内存空间</strong></em>：每一页内存大小不大的话，大量内存会对应<strong>很多个</strong>页表项，每个进程又有自己的页表；（段的话因为一个程序只对应五六个段，段表不会占特别大空间）。</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><em><strong>多级页表</strong></em>：程序用不到那么多内存，不需要真正创建所有的页号和页的映射。一级页表可以覆盖全部的虚拟内存，记录二级页表目录；二级列表记录真正的映射关系，只有一级页表项用到的部分才创建二级部分。</li></ol><h2 id="TLB页表缓存"><a href="#TLB页表缓存" class="headerlink" title="TLB页表缓存"></a>TLB页表缓存</h2><ul><li>最常用的页表进行缓存，常用的页不多，TLB命中率很高。</li></ul><!-- - 缓存思想，速度慢了就缓存常用的。 --><h2 id="分段和分页相同处和不同处"><a href="#分段和分页相同处和不同处" class="headerlink" title="分段和分页相同处和不同处"></a>分段和分页相同处和不同处</h2><ul><li>相同处：</li></ul><ol><li>地址转换过程：都是从段表页表中获取基地址，再加上偏移量获取物理地址。</li><li>记录表：分段或者分页都使用了表来记录段或页的映射关系。</li></ol><ul><li>不同处：</li></ul><ol><li>大小：段的大小是根据逻辑需求而定的，且是动态变化的；页的大小是固定的，解决了内存碎片问题。</li><li>碎片：分段产生外部碎片，分页产生内部碎片。</li><li>表结构：段表记录的是段基地址和段边界，页表记录的是页号对应的页框。</li></ol><h2 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h2><!-- 现在更多是纯分页 --><ul><li>优点：<strong>逻辑分段+无外部碎片。</strong></li><li>先将程序按逻辑分成多个逻辑段。</li><li>每个段再分成固定大小的页，对段划出连续空间。</li><li>虚拟地址由：<em><strong>段号，段内页号，页面偏移量</strong></em>组成。<br><img src="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image.png" alt="alt text"></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vite</title>
    <link href="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/vite/"/>
    <url>/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/vite/</url>
    
    <content type="html"><![CDATA[<h1 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h1><ul><li>深入理解Vite核心原理: <a href="https://juejin.cn/post/7064853960636989454">https://juejin.cn/post/7064853960636989454</a></li><li>vite为什么这么快：<a href="https://juejin.cn/post/7280747221510144054#heading-1">https://juejin.cn/post/7280747221510144054#heading-1</a></li></ul><h2 id="vite预构建"><a href="#vite预构建" class="headerlink" title="vite预构建"></a>vite预构建</h2><ul><li>转换为esm模块。</li></ul><h2 id="vite核心原理-vite构建流程"><a href="#vite核心原理-vite构建流程" class="headerlink" title="vite核心原理&#x2F;vite构建流程"></a>vite核心原理&#x2F;vite构建流程</h2><ol><li>vite直接启动开发服务器，不用进行整个项目的打包编译。</li><li>vite会预处理所有文件为esm格式，利用浏览器对esm的支持，就是我们浏览器现在支持运行一些模块化的语言，比如import语句，遇到import再去发送http请求对应的模块，vite会在服务器中间拦截处理文件（比如vue编译）</li></ol><h2 id="vite本地开发esbuild，生产rollup"><a href="#vite本地开发esbuild，生产rollup" class="headerlink" title="vite本地开发esbuild，生产rollup"></a>vite本地开发esbuild，生产rollup</h2><ol><li><p>esbuild：go编写构建速度快；利用浏览器原生支持ESM模块，请求一个模块，再去加载对应的模块，拦截请求进行代码转换。</p></li><li><p>rollup：esbuild只能做简单转换，一些插件API与esbuild打包还不兼容，rollup有打包生命周期钩子，可进行模块解析加载代码分割、treeShaking、生成的代码体积更小、更高效。</p></li></ol><p><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/vite/esbuildAndRollup.png" alt="对比图"></p>]]></content>
    
    
    <categories>
      
      <category>打包工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>打包工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/"/>
    <url>/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/</url>
    
    <content type="html"><![CDATA[<p><a href="https://vue3js.cn/interview/webpack/webpack.html#%E4%B8%80%E3%80%81%E8%83%8C%E6%99%AF">https://vue3js.cn/interview/webpack/webpack.html#%E4%B8%80%E3%80%81%E8%83%8C%E6%99%AF</a></p><p><a href="https://juejin.cn/post/6844904094281236487?searchId=20241027155907A6653545D1F9EE98EE4D">https://juejin.cn/post/6844904094281236487?searchId=20241027155907A6653545D1F9EE98EE4D</a></p><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><ul><li>loader本质是一个函数，翻译官，对接收的内容进行转换。</li><li>默认情况下，webpack只能对js，json进行转换，遇到css，png等文件时候需要loader对文件分析，webpack遇到无法解析的文件时候会去loader配置查找，进行预处理编译压缩。</li><li>常见的loader：<br>css-loader，style-loader，解析css代码，将css代码作为style标签插入到页面中。<br>json-loader,默认包含。<br>image-loader：加载压缩图片。<br><strong>babel-loader</strong>：es6+语法转换为es5<br><strong>ts-loader</strong>：ts转换为js</li></ul><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><ul><li>插件，扩充webpack功能，webpack在生命周期会广播事件，plugin监听事件来执行改变结果。</li><li>HtmlWebpackPlugin，创建一个html，并把打包生成的js插入到其中。</li><li>Dllplugin</li><li>webpack-bundle-analyzer，打包后体积可视化</li></ul><h2 id="编写loader"><a href="#编写loader" class="headerlink" title="编写loader"></a>编写loader</h2><p><a href="https://juejin.cn/post/7100534685134454815?searchId=2024111811590127047A1230DEEC4E5372">https://juejin.cn/post/7100534685134454815?searchId=2024111811590127047A1230DEEC4E5372</a></p><ul><li>loader职责是单一、链式传输、易维护。</li></ul><ol><li>本质是函数，this会被webpack填充，不能用箭头函数。</li><li>接受一个参数，为webpack传递loader的文件源，源文件字符串。</li><li>this.async标明loader是个异步的，async()接受一个回调函数；<br>this.getOptions()获取 loader 的配置选项</li></ol><!-- 4. 获取配置文件配置项options：loader-utils.getOptions。(就是在webpack配置文件中给loader配置的内容) --><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; getOptions &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;loader-utils&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) &#123;<br>  <span class="hljs-keyword">const</span> options = <span class="hljs-title function_">getOptions</span>(<span class="hljs-variable language_">this</span>) || &#123;&#125;;<br>  <span class="hljs-keyword">const</span> result = source.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/foo/g</span>, options.<span class="hljs-property">replacement</span> || <span class="hljs-string">&#x27;bar&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br>在 <span class="hljs-title class_">Webpack</span> 配置中传递选项：<br>&#123;<br>  <span class="hljs-attr">loader</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;path/to/my-loader.js&#x27;</span>),<br>  <span class="hljs-attr">options</span>: &#123;<br>    <span class="hljs-attr">replacement</span>: <span class="hljs-string">&#x27;baz&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="编写plugin"><a href="#编写plugin" class="headerlink" title="编写plugin"></a>编写plugin</h2><ul><li>先说本质是一个类，然后两个核心对象compiler（每次编译的总指挥）、complication（每次编译的所有信息（模块、依赖）、资源生成输出等方面工作）。</li></ul><ol><li>一个类，有apply方法；apply方法在webpack装置插件时候会调用传入compiler对象。</li><li>类除了apply方法外，constructor里面可以收到options，就是webpack配置文件中的配置项。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options = &#123;&#125;</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = options.<span class="hljs-property">message</span> || <span class="hljs-string">&#x27;Hello, Webpack!&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">done</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>);<br>    &#125;);<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>compiler每次编译的总指挥，该对象上有生命周期钩子，使用不同的hooks钩子指定自己特定时期需要发生的处理行为。（hooks：emit：输出资源到文件系统之前触发、done：完成构建后触发，适合输出统计信息；compile：编译器开始编译时候触发）</li><li>complication生成文件、遍历模块然后操作。<br>tap：同步触发；<br> tapAsync：异步回调触发；<br> tapPromise：异步promise模式；</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 生成一个 version.txt 文件：</span><br><span class="hljs-keyword">const</span> &#123; version &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./package.json&#x27;</span>);、<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> &#123;<br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">compilation</span>) =&gt;</span> &#123;<br>      compilation.<span class="hljs-property">assets</span>[<span class="hljs-string">&#x27;version.txt&#x27;</span>] = &#123;<br>        <span class="hljs-attr">source</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-string">`版本号: <span class="hljs-subst">$&#123;version&#125;</span>`</span>,<br>        <span class="hljs-attr">size</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-string">`版本号: <span class="hljs-subst">$&#123;version&#125;</span>`</span>.<span class="hljs-property">length</span>,<br>      &#125;;<br>    &#125;);<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;<br><br><br><span class="hljs-comment">// 遍历所有模块并打印模块路径：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> &#123;<br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">compilation</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">compilation</span>) =&gt;</span> &#123;<br>      compilation.<span class="hljs-property">hooks</span>.<span class="hljs-property">succeedModule</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;模块路径:&#x27;</span>, <span class="hljs-variable language_">module</span>.<span class="hljs-property">resource</span>);<br>      &#125;);<br>    &#125;);<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;<br></code></pre></td></tr></table></figure><h2 id="webpack构建流程"><a href="#webpack构建流程" class="headerlink" title="webpack构建流程"></a>webpack构建流程</h2><ol><li>初始化参数：从配置文件，shell语句中读取参数</li><li>开始编译：用参数初始化complier对象，加载所有的插件<strong>plugin</strong>，执行对象的run方法开始编译。</li><li>确定入口，编译模块：从entry文件出发，调用loader对模块进行翻译，翻译完后解析生成AST语法树，分析AST语法树：遇到导入模块语句时，再找出该模块依赖的模块，递归处理所有依赖。<strong>module &#x3D;&gt; ast &#x3D;&gt; dependences &#x3D;&gt; module</strong></li><li>输出：将依赖关系组成一个个或多个chunk，再把每个chunk转换为文件输出</li><li>plugin：在上述过程中，webpack在特定时间暴露特定事件，插件监听到会执行特定的逻辑，改变输出的结果。</li></ol><h2 id="如何提高构建速度？"><a href="#如何提高构建速度？" class="headerlink" title="如何提高构建速度？"></a>如何提高构建速度？</h2><ol><li>cache-loader：（对loader缓存）将性能开销大的loader输出结果缓存到磁盘，后续使用到该loader的文件先交给cache-loader处理，计算hash值，如果发现有缓存直接复用。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-1.png" alt="alt text"><br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/cache-loader.png" alt="alt text"></li><li>thread-loader：许多loader比如babel-loader支持并行处理，利用多核CPU加速构建。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-2.png" alt="alt text"></li><li>缩小构建作用域：合理配置 loader 的 exclude 和 include 选项，避免不必要的文件被处理<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-3.png" alt="alt text"></li><li>dllplugin：可以帮助将一些第三方依赖（如 React、Vue、Lodash 等）提前打包生成动态链接库（DLL），并且让 Webpack 跳过这些库的重新编译。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-4.png" alt="alt text"></li><li>代码分割：将模块依赖原本的大文件拆分为多个文件，加载页面更快。</li></ol><ul><li>入口分割：指定多个入口点，每个入口点生成独立的chunk</li><li>基于模块的分割：动态调用import，按需加载模块。webpack会把该模块分割成独立的chunk，在路由配置component时候可以用箭头函数调用import引入组件，webpackChunkName申明chunk名，因为每个路由一般是单独的模块。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-8.png" alt="alt text"></li></ul><ol start="6"><li>extrenals，避免打包的资源，通过cdn引入。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-9.png" alt="alt text"><br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-10.png" alt="alt text"></li></ol><h2 id="如何减少打包体积？"><a href="#如何减少打包体积？" class="headerlink" title="如何减少打包体积？"></a>如何减少打包体积？</h2><ol><li>启动tree-shaking：剔除没使用到的模块。</li><li>删除没必要的依赖：webpack-bundle-analyzer这些依赖下载到开发环境中，而不是生产环境。</li><li>按需引入：组件库不要全部引入，使用对应的插件自动引入使用的组件。</li><li>优化图片资源：image-webpack-loader 可以在打包过程中压缩图片。</li><li>压缩js：TerserPlugin（webpack5默认启用），去除注释、空格等。合并变量、函数。删除无用代码（Dead Code Elimination）。</li><li>压缩css：css-minimizer-webpack-plugin。</li></ol><h2 id="webpack热模块更新"><a href="#webpack热模块更新" class="headerlink" title="webpack热模块更新"></a>webpack热模块更新</h2><!-- 思路查阅很多资料、询问deepseek确定是没问题的 --><ul><li>热更新又称为热替换，不用刷新浏览器将新变更的模块替换掉旧的模块。</li></ul><ol><li>webpack开发服务器会与浏览器建立websocket连接，允许客户端和服务端实时通信。</li><li>当webpack检测到有模块变化时，重新编译模块。</li><li>通过socket将hash传送给客户端，客户端对比hash区别，请求更改的文件。</li><li>在客户端进行模块更新。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-5.png" alt="alt text"></li></ol><h2 id="vite和webpack区别"><a href="#vite和webpack区别" class="headerlink" title="vite和webpack区别"></a>vite和webpack区别</h2><ul><li><a href="https://juejin.cn/post/7283682738497765413">https://juejin.cn/post/7283682738497765413</a></li></ul><ol><li>快速冷启动:vite直接启动开发服务器,不用分析模块依赖.利用ESModule的特性,<em><strong>请求某个模块时候再对模块内容编译</strong></em>.webpack是对静态资源打包生成对应的静态资源,使用一些loader,plugin插件等等.</li><li>构建方式：vite构建和按需编译都是esbuild完成，esbuild是go语言编写，可以利用多核CPU；webpack是基于node.js实现，无法利用多核CPU。</li><li>http2：vite采用http2请求，将打包产物分成多个小模块并行加载，请求资源速度更快。</li><li>热模块更新：vite检测到变更后通知浏览器重新请求，浏览器重新请求后再进行编译，并做了强制缓存（依赖模块）和协商缓存（自己的源码模块）；webpack需要将对应的依赖关系重新打包，再进行模块更新。</li></ol><ul><li>webpack适合大型复杂的项目,生态更稳定，vite更适合小型应用开发.<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-6.png" alt="alt text"><br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-7.png" alt="alt text"></li></ul><h2 id="externals优化"><a href="#externals优化" class="headerlink" title="externals优化"></a>externals优化</h2><!-- 穹顶有使用 --><ul><li>部分资源不会打包到输出目录中，而是作为外部依赖通过script标签引入。</li><li>减少打包体积也能提高构建速度。</li></ul><h2 id="chunk是什么-bundle是什么"><a href="#chunk是什么-bundle是什么" class="headerlink" title="chunk是什么 bundle是什么"></a>chunk是什么 bundle是什么</h2><ul><li>chunk：根据模块之间的依赖，将多个模块组成的代码块。</li><li>bundle：最后输出的文件，浏览器可以直接加载。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image.png" alt="alt text"></li></ul><h2 id="npm-和pnpm区别"><a href="#npm-和pnpm区别" class="headerlink" title="npm 和pnpm区别"></a>npm 和pnpm区别</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/683757720">https://zhuanlan.zhihu.com/p/683757720</a></li></ul><ol><li><em><strong>存储方式</strong></em>:pnpm的依赖项下载在全局存储,同一依赖性只会存储一次,节省了磁盘空间.npm将依赖项存储在项目目录中.</li><li><em><strong>硬链接</strong></em>:依赖项不会被复制到项目中,使用硬链接从全局引入到项目中.提高下载速度.npm将依赖项复制到项目目录中.</li><li><em><strong>扁平化依赖树</strong></em>:将依赖树扁平化,避免幽灵依赖的下载.npm保持项目树的原来结构.</li></ol>]]></content>
    
    
    <categories>
      
      <category>打包工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>磁盘调度算法</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>磁盘调度算法的目的很简单，就是为了提高磁盘的访问性能，一般是通过<strong>优化磁盘的访问请求顺序</strong>来做到的。<br><strong>寻道的时间</strong>是磁盘访问最耗时的部分，如果请求顺序优化的得当，必然可以节省一些不必要的寻道时间，从而提高磁盘的访问性能。</li></ul><h2 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h2><ul><li>先到来的请求先被服务。</li></ul><h2 id="最短寻道算法"><a href="#最短寻道算法" class="headerlink" title="最短寻道算法"></a>最短寻道算法</h2><ul><li>优先选择从当前磁头位置所需寻道时间最短的请求。</li><li>饥饿：产生饥饿的原因是磁头在一小块区域来回移动。</li></ul><h2 id="扫描算法（电梯算法）"><a href="#扫描算法（电梯算法）" class="headerlink" title="扫描算法（电梯算法）"></a>扫描算法（电梯算法）</h2><ul><li>往左扫描到没有请求为止，再往右。</li><li>中间的磁道占优势。</li></ul><h2 id="循环扫描"><a href="#循环扫描" class="headerlink" title="循环扫描"></a>循环扫描</h2><ul><li>往左扫描完后，立即磁头回到<strong>最右边0</strong>，又开始往左扫描。</li><li>响应频率更平均。</li></ul><h2 id="LOOK-与-C-LOOK算法"><a href="#LOOK-与-C-LOOK算法" class="headerlink" title="LOOK 与 C-LOOK算法"></a>LOOK 与 C-LOOK算法</h2><ul><li>扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换方向。优化的思路就是磁头在移动到「最远的请求」位置，然后立即反向移动。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>调度算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>页面调度算法</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="内存页面置换算法"><a href="#内存页面置换算法" class="headerlink" title="内存页面置换算法"></a>内存页面置换算法</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>缺页中断：CPU访问的页面不在物理内存中的时候,便会产生缺页中断，会请求操作系统将所缺页调入到物理内存中。</li><li>具体流程：<br><img src="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image.png" alt="图片说明"><br>注意：有空闲页先调度到空闲页，没有空闲页则才需要使用页面置换算法。</li></ul><h2 id="最佳页面置换算法"><a href="#最佳页面置换算法" class="headerlink" title="最佳页面置换算法"></a>最佳页面置换算法</h2><ul><li>置换未来最长时间不访问的页面。</li><li>理想算法，实际中无法预知每个页面下次被访问的时间。</li></ul><h2 id="先进先出置换算法"><a href="#先进先出置换算法" class="headerlink" title="先进先出置换算法"></a>先进先出置换算法</h2><ul><li>选择在内存中滞留时间很长的页面进行置换。</li></ul><h2 id="最近最久未使用LRU置换算法"><a href="#最近最久未使用LRU置换算法" class="headerlink" title="最近最久未使用LRU置换算法"></a>最近最久未使用LRU置换算法</h2><ul><li>选择最长时间没有被访问的页面进行置换。</li><li>很少使用，需要维护一个链表，最近使用的放链表头部，每次访问页面都需要更新链表。</li></ul><h2 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h2><ul><li>所有页面在一个链表中，一个表针指向最老的页面。</li><li>如果访问位是0：置换该页面，并把表针指向前一位。<br>  访问位是1：改为0，并把表针前移一位。</li></ul><h2 id="最不常用算法"><a href="#最不常用算法" class="headerlink" title="最不常用算法"></a>最不常用算法</h2><ul><li>选择访问次数最少的页面进行置换。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>调度算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
