<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浏览器进程</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h1><h2 id="四种进程"><a href="#四种进程" class="headerlink" title="四种进程"></a>四种进程</h2><ol><li>浏览器进程：管理窗口和用户界面，地址栏、书签、前进、后退等功能，协调其他进程。</li><li>渲染进程：负责页面渲染工作。包括<em><strong>渲染线程，js引擎线程，异步http请求线程（用户发送请求后会将该请求传递给网络进程处理）</strong></em>。</li><li>插件进程：处理插件的运行。</li><li>GPU进程：处理图形渲染。</li></ol><h2 id="浏览器为什么要限制请求并发数？"><a href="#浏览器为什么要限制请求并发数？" class="headerlink" title="浏览器为什么要限制请求并发数？"></a>浏览器为什么要限制请求并发数？</h2><ol><li>对操作系统端口资源的考虑：操作系统开放了一半端口对外请求，一个http&#x2F;tcp请求占据一个端口，防止端口资源消耗殆尽。</li><li>避免频繁的线程切换：线程和http请求相对应，如果并发数量过大会导致频繁切换线程。</li><li>避免同一客户端发送大量请求超过服务端并发</li><li>客户端良知机制：防止两个应用抢占资源时候强势一方导致弱势一方永远阻塞。</li><li>http队头阻塞：tcp队头阻塞。</li></ol><h2 id="如何解决浏览器请求次数限制？"><a href="#如何解决浏览器请求次数限制？" class="headerlink" title="如何解决浏览器请求次数限制？"></a>如何解决浏览器请求次数限制？</h2><ul><li><a href="https://segmentfault.com/a/1190000039157302">https://segmentfault.com/a/1190000039157302</a></li></ul><ol><li>http2.0，http3.0 解决队头阻塞，并发请求。</li><li>使用缓存，减少请求量。</li><li>合并请求，减少请求次数。</li><li>按需加载。</li><li>域名分散。</li></ol><h2 id="浏览器组成"><a href="#浏览器组成" class="headerlink" title="浏览器组成"></a>浏览器组成</h2><ol><li>用户界面：地址栏、书签栏、前进、后退等等。</li><li>浏览器主引擎：渲染引擎和用户界面的桥梁，处理用户交互，传递信息给渲染引擎。</li><li>渲染引擎：浏览器渲染过程。</li><li>js引擎：解析和执行js。</li><li>网络模块：发送请求和加载资源。</li><li>数据存储：cookie、localStorage、SessionStorage、indexedDB等等</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>进程管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>锁</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E9%94%81/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><ul><li>互斥锁和自旋锁是最基本的锁,读写锁可以基于这两个锁进行实现,前面这些锁都是悲观锁.</li></ul><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><ol><li>互斥锁加锁失败,当前进程进入阻塞队列,不占据CPU资源</li><li>适合等待时间长</li></ol><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><ol><li>自旋锁加锁失败会占据CPU资源,循环等待资源的释放.</li><li>适合等待时间短,减少上下文切换的成本</li></ol><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><ol><li>读优先锁:尽可能多的读锁,挺高并发性,读锁会阻塞写锁.能继续加读锁.</li><li>写优先锁:如果有写锁,则不能继续加读锁.</li></ol><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><ol><li>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。</li></ol><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><ol><li>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</li><li>服务端返回版本号,修改完之后发送旧版本号,相同则操作成功,否则失败.</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>进程管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>死锁</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%AD%BB%E9%94%81/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>两个共有资源两把锁,两个线程各持有一个锁,都在等另一把锁释放,就造成了死锁.</li></ul><h2 id="四个条件"><a href="#四个条件" class="headerlink" title="四个条件"></a>四个条件</h2><ol><li>互斥条件:这个资源不能被多个线程同时访问.</li><li>持有并等待条件:线程在等待资源时候不会释放自己已有的资源.</li><li>不可剥夺条件:自己已有的资源不会被其他线程剥夺.</li><li>环路等待条件:两个线程获取资源顺序形成环路.</li></ol><h2 id="避免死锁问题"><a href="#避免死锁问题" class="headerlink" title="避免死锁问题"></a>避免死锁问题</h2><ul><li>破坏其中一个条件,一般是资源有序分配 &#x3D;&gt; 破坏环路条件.</li><li>A、B两个资源，线程获取A，再获取B。另一个线程也要先获取A才能获取B。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>进程管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>进程的通信</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><ol><li>半双工,管道传输数据是单向的，双向进程通信需要两个管道</li><li>管道是内核中的一段缓存,写入后必须等被读完才能退出(写进程被空占据)</li></ol><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><ul><li>进程把消息放到内核的消息队列中既可以退出.缺点是读取不及时,大小有限制.拷贝内核数据要从用户态切换为内核态.</li></ul><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><ol><li>进程有自己的虚拟空间,映射到一个物理空间</li><li>两个进程的<em><strong>虚拟空间映射到同一个物理空间</strong></em>既可以实现通信</li></ol><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><ul><li>实现进程的互斥和异步,防止多个进程修改同一个共享内存</li><li>P操作-1,V操作+1</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>进程管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程线程</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ol><li>运行中的程序就是进程,包括数据段,程序段,PCB(进程控制块:描述进程的信息,比如程序存放的位置);</li><li>资源分配的单位</li></ol><ul><li>cpu如果只执行一个进程，这个进程读硬盘时候就会很慢，cpu在傻等。所以有了cpu并发执行管理多个进程，提高cpul利用率。就有了<strong>进程状态、进程管理</strong>的概念。</li></ul><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><ul><li><strong>创建态,就绪态,运行态,阻塞态,结束态</strong>.</li><li><strong>就绪挂起态,阻塞挂起态</strong>.大量阻塞态会占据有限的内存,可以将这些进程放到外存(磁盘中)<br><img src="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/image-1.png" alt="alt text"></li></ul><h2 id="进程的控制和管理"><a href="#进程的控制和管理" class="headerlink" title="进程的控制和管理"></a>进程的控制和管理</h2><ol><li>PCB(进程的唯一标识):进程的状态,进程的优先级,CPU上下文信息</li><li><em><strong>链表存储</strong></em>：相同状态存放在一起,比如:就绪队列,阻塞队列.更适应进程<strong>创建、销毁多</strong>的场景.</li></ol><h2 id="线程-并发-共享资源"><a href="#线程-并发-共享资源" class="headerlink" title="线程:并发 共享资源"></a>线程:并发 共享资源</h2><ol><li><strong>进程下的一条执行流程</strong></li><li><strong>可以并发且共享资源的执行</strong></li><li>CPU调度的基本单位</li></ol><h2 id="进程和线程的区别-10024"><a href="#进程和线程的区别-10024" class="headerlink" title="进程和线程的区别 &#10024;"></a>进程和线程的区别 &#10024;</h2><ol><li>根本区别:进程是操作系统资源分配的基本单位,线程是CPU任务调度和执行的基本单位.</li><li>关系:进程包含一个或多个线程</li><li>资源开销:进程有独立的数据段和程序段,程序之间切换成本大;线程是轻量级的进程,同一进程下的线程共享程序段和数据段,线程有自己独立的PC(程序计数器:记录下一条指令的位置)和执行栈,创建速度快，销毁速度快，线程切换成本低速度快.适合并发执行。</li></ol><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ul><li>进程状态改变时候比如：运行态到终止、运行到阻塞、就绪到运行，都会使用到调度算法。CPU更换新的进程来执行。</li></ul><ol><li>先来先服务算法：对短作业不利，要等长作业很久。</li><li>短作业优先算法：对长作业不利，可能一直等。</li><li>最高响应比算法：理想型算法，无法实现。<br>(等待时间 + 要求服务时间)&#x2F; 要求服务时间</li><li>时间片轮转算法：每个进程分配一个时间片，允许进程在该时间片执行。</li><li>最高优先级算法：CPU选择优先级最高的进程执行代码。静态优先级、动态优先级；抢占式、非抢占式。抢占式可能导致优先级低的永远无法执行。</li><li>多级反馈队列算法：多个队列，每个队列优先级从高到低排列，同时优先级越高时间片越短。  先进入最高优先级队列，没执行完进入下一级优先队列。对于短作业来说，很可能在最高优先级队列的时间片就执行完毕；对于长作业来说，进入到后面优先级更低的队列，但是执行时间变长了。<strong>短作业优先级高，执行时间短；长作业优先级低，执行时间长。</strong></li></ol><!-- 如果执行低优先级的长作业时候有短作业进入，则会先去执行短作业。 -->]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>进程管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟内存</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><ul><li>程序使用的内存是虚拟内存，操作系统内部将其与物理内存映射。避免各个程序物理地址冲突。操作系统通过 <strong>内存分段、内存分页</strong>两种方式实现虚拟内存到物理内存的映射。</li></ul><ol><li>内存扩展：物理内存有限，虚拟内存可以先把程序部分数据暂存到硬盘中，需要时候再调度进来。</li><li>进程隔离：各个进程运行在自己的虚拟内存中，操作系统内实现虚拟内存到物理内存的映射，避免进程访问错误。</li><li>内存管理：通过分页分段管理内存，更加有效的分配和回收内存，减少内存碎片化。</li></ol><!-- 操作系统是如何管理虚拟地址与物理地址之间的关系？主要有两种方式，分别是内存分段和内存分页 --><h2 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li>程序由若干个逻辑段组成，比如程序段、数据段，分段就是把这些段分离开来。分段的虚拟内存由<em><strong>段选择因子</strong></em>和<em><strong>段内偏移量</strong></em>。</li></ul><ol><li><em><strong>段选择因子</strong></em>：核心是<em><strong>段号</strong></em>，段号索引到段表的一个条目，这个条目有<strong>段基地址和段边界</strong></li><li><em><strong>段内偏移量</strong></em>：位于0和段边界之间，段基地址 + 段偏移量 &#x3D; 物理地址</li></ol><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ol><li><em><strong>外部内存碎片</strong></em>：每个段大小长度不固定，会产生多个不连续的小段内存（外部内存碎片），导致新程序无法加载。</li></ol><h3 id="解决方方案"><a href="#解决方方案" class="headerlink" title="解决方方案"></a>解决方方案</h3><ol><li><em><strong>内存交换</strong></em>：将内存中的应用写到硬盘上，再写回内存中，但写回的位置不再是原来的位置，而是紧跟前面的内存。</li></ol><h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><ul><li>分页是把物理内存提前划分好为一个个固定大小的空间，页与页之间紧密排列，虚拟地址和物理地址通过页表映射。</li><li>分页机制下，虚拟地址分为<em><strong>页号</strong></em>和<em><strong>页内偏移量</strong></em>，页号是页表的索引，页表包含物理页每页的基地址，再加上偏移量就得到物理地址。</li></ul><h3 id="存在的问题-1"><a href="#存在的问题-1" class="headerlink" title="存在的问题"></a>存在的问题</h3><ul><li><em><strong>内存分页机制会有内部内存碎片</strong></em>：采用了分页，页与页之间是紧密排列的，所以不会有外部内存碎片；但内存分配最小是一页，即使程序不足一页也会分配一个页，所以页面内会出现内存浪费。</li><li><em><strong>页表占据大量内存空间</strong></em>：每一页内存大小不大的话，大量内存会对应<strong>很多个</strong>页表项，每个进程又有自己的页表；（段的话因为一个程序只对应五六个段，段表不会占特别大空间）。</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><em><strong>多级页表</strong></em>：程序用不到那么多内存，不需要真正创建所有的页号和页的映射。一级页表可以覆盖全部的虚拟内存，记录二级页表目录；二级列表记录真正的映射关系，只有一级页表项用到的部分才创建二级部分。</li></ol><h2 id="TLB页表缓存"><a href="#TLB页表缓存" class="headerlink" title="TLB页表缓存"></a>TLB页表缓存</h2><ul><li>最常用的页表进行缓存，常用的页不多，TLB命中率很高。</li></ul><!-- - 缓存思想，速度慢了就缓存常用的。 --><h2 id="分段和分页相同处和不同处"><a href="#分段和分页相同处和不同处" class="headerlink" title="分段和分页相同处和不同处"></a>分段和分页相同处和不同处</h2><ul><li>相同处：</li></ul><ol><li>地址转换过程：都是从段表页表中获取基地址，再加上偏移量获取物理地址。</li><li>记录表：分段或者分页都使用了表来记录段或页的映射关系。</li></ol><ul><li>不同处：</li></ul><ol><li>大小：段的大小是根据逻辑需求而定的，且是动态变化的；页的大小是固定的，解决了内存碎片问题。</li><li>碎片：分段产生外部碎片，分页产生内部碎片。</li><li>表结构：段表记录的是段基地址和段边界，页表记录的是页号对应的页框。</li></ol><h2 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h2><!-- 现在更多是纯分页 --><ul><li>优点：<strong>逻辑分段+无外部碎片。</strong></li><li>先将程序按逻辑分成多个逻辑段。</li><li>每个段再分成固定大小的页，对段划出连续空间。</li><li>虚拟地址由：<em><strong>段号，段内页号，页面偏移量</strong></em>组成。<br><img src="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/image.png" alt="alt text"></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vite</title>
    <link href="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/vite/"/>
    <url>/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/vite/</url>
    
    <content type="html"><![CDATA[<h1 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h1><ul><li>深入理解Vite核心原理: <a href="https://juejin.cn/post/7064853960636989454">https://juejin.cn/post/7064853960636989454</a></li><li>vite为什么这么快：<a href="https://juejin.cn/post/7280747221510144054#heading-1">https://juejin.cn/post/7280747221510144054#heading-1</a></li></ul><h2 id="vite预构建"><a href="#vite预构建" class="headerlink" title="vite预构建"></a>vite预构建</h2><ul><li>转换为esm模块。</li></ul><h2 id="vite核心原理-vite构建流程"><a href="#vite核心原理-vite构建流程" class="headerlink" title="vite核心原理&#x2F;vite构建流程"></a>vite核心原理&#x2F;vite构建流程</h2><ol><li>vite直接启动开发服务器，不用进行整个项目的打包编译。</li><li>vite会预处理所有文件为esm格式，利用浏览器对esm的支持，就是我们浏览器现在支持运行一些模块化的语言，比如import语句，遇到import再去发送http请求对应的模块，vite会在服务器中间拦截处理文件（比如vue编译）</li></ol><h2 id="vite本地开发esbuild，生产rollup"><a href="#vite本地开发esbuild，生产rollup" class="headerlink" title="vite本地开发esbuild，生产rollup"></a>vite本地开发esbuild，生产rollup</h2><ol><li><p>esbuild：go编写构建速度快；利用浏览器原生支持ESM模块，请求一个模块，再去加载对应的模块，拦截请求进行代码转换。</p></li><li><p>rollup：esbuild只能做简单转换，一些插件API与esbuild打包还不兼容，rollup有打包生命周期钩子，可进行模块解析加载代码分割、treeShaking、生成的代码体积更小、更高效。</p></li></ol><p><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/vite/esbuildAndRollup.png" alt="对比图"></p>]]></content>
    
    
    <categories>
      
      <category>打包工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>打包工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/"/>
    <url>/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/</url>
    
    <content type="html"><![CDATA[<p><a href="https://vue3js.cn/interview/webpack/webpack.html#%E4%B8%80%E3%80%81%E8%83%8C%E6%99%AF">https://vue3js.cn/interview/webpack/webpack.html#%E4%B8%80%E3%80%81%E8%83%8C%E6%99%AF</a></p><p><a href="https://juejin.cn/post/6844904094281236487?searchId=20241027155907A6653545D1F9EE98EE4D">https://juejin.cn/post/6844904094281236487?searchId=20241027155907A6653545D1F9EE98EE4D</a></p><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><ul><li>loader本质是一个函数，翻译官，对接收的内容进行转换。</li><li>默认情况下，webpack只能对js，json进行转换，遇到css，png等文件时候需要loader对文件分析，webpack遇到无法解析的文件时候会去loader配置查找，进行预处理编译压缩。</li><li>常见的loader：<br>css-loader，style-loader，解析css代码，将css代码作为style标签插入到页面中。<br>json-loader,默认包含。<br>image-loader：加载压缩图片。<br><strong>babel-loader</strong>：es6+语法转换为es5<br><strong>ts-loader</strong>：ts转换为js</li></ul><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><ul><li>插件，扩充webpack功能，webpack在生命周期会广播事件，plugin监听事件来执行改变结果。</li><li>HtmlWebpackPlugin，创建一个html，并把打包生成的js插入到其中。</li><li>Dllplugin</li><li>webpack-bundle-analyzer，打包后体积可视化</li></ul><h2 id="编写loader"><a href="#编写loader" class="headerlink" title="编写loader"></a>编写loader</h2><p><a href="https://juejin.cn/post/7100534685134454815?searchId=2024111811590127047A1230DEEC4E5372">https://juejin.cn/post/7100534685134454815?searchId=2024111811590127047A1230DEEC4E5372</a></p><ul><li>loader职责是单一、链式传输、易维护。</li></ul><ol><li>本质是函数，this会被webpack填充，不能用箭头函数。</li><li>接受一个参数，为webpack传递loader的文件源，源文件字符串。</li><li>this.async标明loader是个异步的，async()接受一个回调函数；<br>this.getOptions()获取 loader 的配置选项</li></ol><!-- 4. 获取配置文件配置项options：loader-utils.getOptions。(就是在webpack配置文件中给loader配置的内容) --><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; getOptions &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;loader-utils&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) &#123;<br>  <span class="hljs-keyword">const</span> options = <span class="hljs-title function_">getOptions</span>(<span class="hljs-variable language_">this</span>) || &#123;&#125;;<br>  <span class="hljs-keyword">const</span> result = source.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/foo/g</span>, options.<span class="hljs-property">replacement</span> || <span class="hljs-string">&#x27;bar&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br>在 <span class="hljs-title class_">Webpack</span> 配置中传递选项：<br>&#123;<br>  <span class="hljs-attr">loader</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;path/to/my-loader.js&#x27;</span>),<br>  <span class="hljs-attr">options</span>: &#123;<br>    <span class="hljs-attr">replacement</span>: <span class="hljs-string">&#x27;baz&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="编写plugin"><a href="#编写plugin" class="headerlink" title="编写plugin"></a>编写plugin</h2><ul><li>先说本质是一个类，然后两个核心对象compiler（每次编译的总指挥）、complication（每次编译的所有信息（模块、依赖）、资源生成输出等方面工作）。</li></ul><ol><li>一个类，有apply方法；apply方法在webpack装置插件时候会调用传入compiler对象。</li><li>类除了apply方法外，constructor里面可以收到options，就是webpack配置文件中的配置项。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options = &#123;&#125;</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = options.<span class="hljs-property">message</span> || <span class="hljs-string">&#x27;Hello, Webpack!&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">done</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>);<br>    &#125;);<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>compiler每次编译的总指挥，该对象上有生命周期钩子，使用不同的hooks钩子指定自己特定时期需要发生的处理行为。（hooks：emit：输出资源到文件系统之前触发、done：完成构建后触发，适合输出统计信息；compile：编译器开始编译时候触发）</li><li>complication生成文件、遍历模块然后操作。<br>tap：同步触发；<br> tapAsync：异步回调触发；<br> tapPromise：异步promise模式；</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 生成一个 version.txt 文件：</span><br><span class="hljs-keyword">const</span> &#123; version &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./package.json&#x27;</span>);、<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> &#123;<br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">compilation</span>) =&gt;</span> &#123;<br>      compilation.<span class="hljs-property">assets</span>[<span class="hljs-string">&#x27;version.txt&#x27;</span>] = &#123;<br>        <span class="hljs-attr">source</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-string">`版本号: <span class="hljs-subst">$&#123;version&#125;</span>`</span>,<br>        <span class="hljs-attr">size</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-string">`版本号: <span class="hljs-subst">$&#123;version&#125;</span>`</span>.<span class="hljs-property">length</span>,<br>      &#125;;<br>    &#125;);<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;<br><br><br><span class="hljs-comment">// 遍历所有模块并打印模块路径：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> &#123;<br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">compilation</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">compilation</span>) =&gt;</span> &#123;<br>      compilation.<span class="hljs-property">hooks</span>.<span class="hljs-property">succeedModule</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;模块路径:&#x27;</span>, <span class="hljs-variable language_">module</span>.<span class="hljs-property">resource</span>);<br>      &#125;);<br>    &#125;);<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPlugin</span>;<br></code></pre></td></tr></table></figure><h2 id="webpack构建流程"><a href="#webpack构建流程" class="headerlink" title="webpack构建流程"></a>webpack构建流程</h2><ol><li>初始化参数：从配置文件，shell语句中读取参数</li><li>开始编译：用参数初始化complier对象，加载所有的插件<strong>plugin</strong>，执行对象的run方法开始编译。</li><li>确定入口，编译模块：从entry文件出发，调用loader对模块进行翻译，翻译完后解析生成AST语法树，分析AST语法树：遇到导入模块语句时，再找出该模块依赖的模块，递归处理所有依赖。<strong>module &#x3D;&gt; ast &#x3D;&gt; dependences &#x3D;&gt; module</strong></li><li>输出：将依赖关系组成一个个或多个chunk，再把每个chunk转换为文件输出</li><li>plugin：在上述过程中，webpack在特定时间暴露特定事件，插件监听到会执行特定的逻辑，改变输出的结果。</li></ol><h2 id="如何提高构建速度？"><a href="#如何提高构建速度？" class="headerlink" title="如何提高构建速度？"></a>如何提高构建速度？</h2><ol><li>cache-loader：（对loader缓存）将性能开销大的loader输出结果缓存到磁盘，后续使用到该loader的文件先交给cache-loader处理，计算hash值，如果发现有缓存直接复用。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-1.png" alt="alt text"><br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/cache-loader.png" alt="alt text"></li><li>thread-loader：许多loader比如babel-loader支持并行处理，利用多核CPU加速构建。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-2.png" alt="alt text"></li><li>缩小构建作用域：合理配置 loader 的 exclude 和 include 选项，避免不必要的文件被处理<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-3.png" alt="alt text"></li><li>dllplugin：可以帮助将一些第三方依赖（如 React、Vue、Lodash 等）提前打包生成动态链接库（DLL），并且让 Webpack 跳过这些库的重新编译。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-4.png" alt="alt text"></li><li>代码分割：将模块依赖原本的大文件拆分为多个文件，加载页面更快。</li></ol><ul><li>入口分割：指定多个入口点，每个入口点生成独立的chunk</li><li>基于模块的分割：动态调用import，按需加载模块。webpack会把该模块分割成独立的chunk，在路由配置component时候可以用箭头函数调用import引入组件，webpackChunkName申明chunk名，因为每个路由一般是单独的模块。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-8.png" alt="alt text"></li></ul><ol start="6"><li>extrenals，避免打包的资源，通过cdn引入。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-9.png" alt="alt text"><br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-10.png" alt="alt text"></li></ol><h2 id="如何减少打包体积？"><a href="#如何减少打包体积？" class="headerlink" title="如何减少打包体积？"></a>如何减少打包体积？</h2><ol><li>启动tree-shaking：剔除没使用到的模块。</li><li>删除没必要的依赖：webpack-bundle-analyzer这些依赖下载到开发环境中，而不是生产环境。</li><li>按需引入：组件库不要全部引入，使用对应的插件自动引入使用的组件。</li><li>优化图片资源：image-webpack-loader 可以在打包过程中压缩图片。</li><li>压缩js：TerserPlugin（webpack5默认启用），去除注释、空格等。合并变量、函数。删除无用代码（Dead Code Elimination）。</li><li>压缩css：css-minimizer-webpack-plugin。</li></ol><h2 id="webpack热模块更新"><a href="#webpack热模块更新" class="headerlink" title="webpack热模块更新"></a>webpack热模块更新</h2><!-- 思路查阅很多资料、询问deepseek确定是没问题的 --><ul><li>热更新又称为热替换，不用刷新浏览器将新变更的模块替换掉旧的模块。</li></ul><ol><li>webpack开发服务器会与浏览器建立websocket连接，允许客户端和服务端实时通信。</li><li>当webpack检测到有模块变化时，重新编译模块。</li><li>通过socket将hash传送给客户端，客户端对比hash区别，请求更改的文件。</li><li>在客户端进行模块更新。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-5.png" alt="alt text"></li></ol><h2 id="vite和webpack区别"><a href="#vite和webpack区别" class="headerlink" title="vite和webpack区别"></a>vite和webpack区别</h2><ul><li><a href="https://juejin.cn/post/7283682738497765413">https://juejin.cn/post/7283682738497765413</a></li></ul><ol><li>快速冷启动:vite直接启动开发服务器,不用分析模块依赖.利用ESModule的特性,<em><strong>请求某个模块时候再对模块内容编译</strong></em>.webpack是对静态资源打包生成对应的静态资源,使用一些loader,plugin插件等等.</li><li>构建方式：vite构建和按需编译都是esbuild完成，esbuild是go语言编写，可以利用多核CPU；webpack是基于node.js实现，无法利用多核CPU。</li><li>http2：vite采用http2请求，将打包产物分成多个小模块并行加载，请求资源速度更快。</li><li>热模块更新：vite检测到变更后通知浏览器重新请求，浏览器重新请求后再进行编译，并做了强制缓存（依赖模块）和协商缓存（自己的源码模块）；webpack需要将对应的依赖关系重新打包，再进行模块更新。</li></ol><ul><li>webpack适合大型复杂的项目,生态更稳定，vite更适合小型应用开发.<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-6.png" alt="alt text"><br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image-7.png" alt="alt text"></li></ul><h2 id="externals优化"><a href="#externals优化" class="headerlink" title="externals优化"></a>externals优化</h2><!-- 穹顶有使用 --><ul><li>部分资源不会打包到输出目录中，而是作为外部依赖通过script标签引入。</li><li>减少打包体积也能提高构建速度。</li></ul><h2 id="chunk是什么-bundle是什么"><a href="#chunk是什么-bundle是什么" class="headerlink" title="chunk是什么 bundle是什么"></a>chunk是什么 bundle是什么</h2><ul><li>chunk：根据模块之间的依赖，将多个模块组成的代码块。</li><li>bundle：最后输出的文件，浏览器可以直接加载。<br><img src="/2025/04/03/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/webpack/image.png" alt="alt text"></li></ul><h2 id="npm-和pnpm区别"><a href="#npm-和pnpm区别" class="headerlink" title="npm 和pnpm区别"></a>npm 和pnpm区别</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/683757720">https://zhuanlan.zhihu.com/p/683757720</a></li></ul><ol><li><em><strong>存储方式</strong></em>:pnpm的依赖项下载在全局存储,同一依赖性只会存储一次,节省了磁盘空间.npm将依赖项存储在项目目录中.</li><li><em><strong>硬链接</strong></em>:依赖项不会被复制到项目中,使用硬链接从全局引入到项目中.提高下载速度.npm将依赖项复制到项目目录中.</li><li><em><strong>扁平化依赖树</strong></em>:将依赖树扁平化,避免幽灵依赖的下载.npm保持项目树的原来结构.</li></ol>]]></content>
    
    
    <categories>
      
      <category>打包工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>磁盘调度算法</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>磁盘调度算法的目的很简单，就是为了提高磁盘的访问性能，一般是通过<strong>优化磁盘的访问请求顺序</strong>来做到的。<br><strong>寻道的时间</strong>是磁盘访问最耗时的部分，如果请求顺序优化的得当，必然可以节省一些不必要的寻道时间，从而提高磁盘的访问性能。</li></ul><h2 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h2><ul><li>先到来的请求先被服务。</li></ul><h2 id="最短寻道算法"><a href="#最短寻道算法" class="headerlink" title="最短寻道算法"></a>最短寻道算法</h2><ul><li>优先选择从当前磁头位置所需寻道时间最短的请求。</li><li>饥饿：产生饥饿的原因是磁头在一小块区域来回移动。</li></ul><h2 id="扫描算法（电梯算法）"><a href="#扫描算法（电梯算法）" class="headerlink" title="扫描算法（电梯算法）"></a>扫描算法（电梯算法）</h2><ul><li>往左扫描到没有请求为止，再往右。</li><li>中间的磁道占优势。</li></ul><h2 id="循环扫描"><a href="#循环扫描" class="headerlink" title="循环扫描"></a>循环扫描</h2><ul><li>往左扫描完后，立即磁头回到<strong>最右边0</strong>，又开始往左扫描。</li><li>响应频率更平均。</li></ul><h2 id="LOOK-与-C-LOOK算法"><a href="#LOOK-与-C-LOOK算法" class="headerlink" title="LOOK 与 C-LOOK算法"></a>LOOK 与 C-LOOK算法</h2><ul><li>扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换方向。优化的思路就是磁头在移动到「最远的请求」位置，然后立即反向移动。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>调度算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>页面调度算法</title>
    <link href="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <url>/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="内存页面置换算法"><a href="#内存页面置换算法" class="headerlink" title="内存页面置换算法"></a>内存页面置换算法</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>缺页中断：CPU访问的页面不在物理内存中的时候,便会产生缺页中断，会请求操作系统将所缺页调入到物理内存中。</li><li>具体流程：<br><img src="/2025/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image.png" alt="图片说明"><br>注意：有空闲页先调度到空闲页，没有空闲页则才需要使用页面置换算法。</li></ul><h2 id="最佳页面置换算法"><a href="#最佳页面置换算法" class="headerlink" title="最佳页面置换算法"></a>最佳页面置换算法</h2><ul><li>置换未来最长时间不访问的页面。</li><li>理想算法，实际中无法预知每个页面下次被访问的时间。</li></ul><h2 id="先进先出置换算法"><a href="#先进先出置换算法" class="headerlink" title="先进先出置换算法"></a>先进先出置换算法</h2><ul><li>选择在内存中滞留时间很长的页面进行置换。</li></ul><h2 id="最近最久未使用LRU置换算法"><a href="#最近最久未使用LRU置换算法" class="headerlink" title="最近最久未使用LRU置换算法"></a>最近最久未使用LRU置换算法</h2><ul><li>选择最长时间没有被访问的页面进行置换。</li><li>很少使用，需要维护一个链表，最近使用的放链表头部，每次访问页面都需要更新链表。</li></ul><h2 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h2><ul><li>所有页面在一个链表中，一个表针指向最老的页面。</li><li>如果访问位是0：置换该页面，并把表针指向前一位。<br>  访问位是1：改为0，并把表针前移一位。</li></ul><h2 id="最不常用算法"><a href="#最不常用算法" class="headerlink" title="最不常用算法"></a>最不常用算法</h2><ul><li>选择访问次数最少的页面进行置换。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>调度算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
