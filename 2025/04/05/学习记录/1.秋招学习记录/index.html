

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/batman4.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wayne Chen">
  <meta name="keywords" content="">
  
    <meta name="description" content="待办知识点 ！性能优化相关检测工具！：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6992756615346651172#heading-0 fetch   css js：基础、代码输出题、手写题。 vue：源码、八股。 ts：八股、手写。 webpack、vite：八股。 git：八股。 计算机网络 操作系统 算法 + 手写 &#9989; 浏览器原理 微前端：准备看源码 &#9989;  9">
<meta property="og:type" content="article">
<meta property="og:title" content="秋招学习记录">
<meta property="og:url" content="http://example.com/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.%E7%A7%8B%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">
<meta property="og:site_name" content="谈沉潜">
<meta property="og:description" content="待办知识点 ！性能优化相关检测工具！：https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6992756615346651172#heading-0 fetch   css js：基础、代码输出题、手写题。 vue：源码、八股。 ts：八股、手写。 webpack、vite：八股。 git：八股。 计算机网络 操作系统 算法 + 手写 &#9989; 浏览器原理 微前端：准备看源码 &#9989;  9">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.%E7%A7%8B%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image.png">
<meta property="og:image" content="http://example.com/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.%E7%A7%8B%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image.png">
<meta property="og:image" content="http://example.com/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.%E7%A7%8B%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-1.png">
<meta property="article:published_time" content="2025-04-05T07:58:36.000Z">
<meta property="article:modified_time" content="2025-04-05T08:00:28.286Z">
<meta property="article:author" content="Wayne Chen">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.%E7%A7%8B%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image.png">
  
  
  
  <title>秋招学习记录 - 谈沉潜</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"ohWadpEWlT0Q54ERBAkcKH6S-MdYXbMMI","app_key":"vCuFIlABwAvv2H6Ambf1u5e4","server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>谈沉潜</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/batman3.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="秋招学习记录"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-04-05 15:58" pubdate>
          2025年4月5日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          34k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          286 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">秋招学习记录</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="待办知识点"><a href="#待办知识点" class="headerlink" title="待办知识点"></a>待办知识点</h1><ol>
<li>！性能优化相关检测工具！：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6992756615346651172#heading-0">https://juejin.cn/post/6992756615346651172#heading-0</a></li>
<li>fetch</li>
</ol>
<hr>
<p>css</p>
<p>js：基础、代码输出题、手写题。</p>
<p>vue：源码、八股。</p>
<p>ts：八股、手写。</p>
<p>webpack、vite：八股。</p>
<p>git：八股。</p>
<p>计算机网络</p>
<p>操作系统</p>
<p>算法 + 手写 &#9989;</p>
<p>浏览器原理</p>
<p>微前端：准备看源码 &#9989;</p>
<hr>
<h1 id="9-13-git知识"><a href="#9-13-git知识" class="headerlink" title="9.13(git知识)"></a>9.13(git知识)</h1><h2 id="git-submodule（git-子模块）"><a href="#git-submodule（git-子模块）" class="headerlink" title="git submodule（git 子模块）"></a>git submodule（git 子模块）</h2><ul>
<li>将一个git仓库嵌入到另一个git仓库，适用于代码库共享的场景</li>
</ul>
<h3 id="1-添加-Submodule"><a href="#1-添加-Submodule" class="headerlink" title="1.添加 Submodule"></a>1.添加 Submodule</h3><ul>
<li>要将一个外部仓库作为子模块添加到你的主仓库中</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">git submodule <span class="hljs-built_in">add</span> <span class="hljs-symbol">&lt;repository_url&gt;</span> <span class="hljs-symbol">&lt;path&gt;</span><br></code></pre></td></tr></table></figure>
<p>会在你的主仓库中创建一个名为 submodule_path 的目录，并将外部仓库克隆到该目录中。</p>
<h3 id="2-初始化和更新-Submodule"><a href="#2-初始化和更新-Submodule" class="headerlink" title="2.初始化和更新 Submodule"></a>2.初始化和更新 Submodule</h3><ul>
<li>当你克隆一个包含子模块的仓库时，子模块的内容不会自动克隆。你需要手动初始化和更新子模块</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">submodule </span>init<br>git <span class="hljs-keyword">submodule </span>update<br></code></pre></td></tr></table></figure>
<h2 id="gitmodules"><a href="#gitmodules" class="headerlink" title=".gitmodules"></a>.gitmodules</h2><ul>
<li>配置文件，存储子模块的相关信息。在git submodule add后自动生成。文件也像 .gitignore 文件一样受到（通过）git控制。</li>
</ul>
<h1 id="9-14-qiankun框架"><a href="#9-14-qiankun框架" class="headerlink" title="9.14(qiankun框架)"></a>9.14(qiankun框架)</h1><h2 id="qiankun实现原理"><a href="#qiankun实现原理" class="headerlink" title="qiankun实现原理"></a>qiankun实现原理</h2><ol>
<li>微前端是将多个独立应用聚合到一个整体的应用。原理是通过监听路由变化动态加载卸载微应用，并通过自定义事件实现微应用之间和主应用的通信。</li>
</ol>
<h2 id="设计微前端框架考虑点？"><a href="#设计微前端框架考虑点？" class="headerlink" title="设计微前端框架考虑点？"></a>设计微前端框架考虑点？</h2><ol>
<li>应用之间的通信</li>
<li>共享状态（和通信都是基于pinia实现）</li>
<li>监听变化：监听路由变化，动态加载卸载微应用</li>
<li>样式隔离：将子应用样式隔离，避免冲突</li>
<li>生命周期：微应用需要在自己的入口 js (通常就是你配置的 webpack 的 entry js) 导出 bootstrap、mount、unmount 三个生命周期钩子.<br>bootstrap:只执行一次，做全局变量初始化，将共享库导入到子应用中。<br>mount:挂载app到元素中。<br>unmount：innerHTML为空，卸载组件。</li>
</ol>
<h2 id="沙箱机制"><a href="#沙箱机制" class="headerlink" title="沙箱机制"></a>沙箱机制</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6920110573418086413#heading-0">https://juejin.cn/post/6920110573418086413#heading-0</a><br>沙箱sandbox：它是一种安全机制，在程序中创建一个独立的运行环境，用于严格控制访问资源，隔离对外部程序影响。<em><strong>qiankun：每个子应用对应一个沙箱，确保微应用之间 全局变量&#x2F;事件 不冲突。</strong></em><br>qiankun有三种沙箱实现机制，前两种基于代理proxy，后一种支持无proxy的浏览器。</p>
</li>
<li><p><em><strong>LegacySandbox</strong></em>：单实例代理沙箱，简单来讲就是只存在一个window实例，所有的操作都是对这一个实例的操作。 legacySandbox设置了三个参数来记录全局变量,分别是记录沙箱新增的全局变量addedPropsMapInSandbox、记录沙箱更新的全局变量modifiedPropsOriginalValueMapInSandbox、持续记录更新的(新增和修改的)全局变量，用于在任意时刻做snapshot的currentUpdatedPropsValueMap。</p>
</li>
<li><p><em><strong>ProxySandbox</strong></em>：多实例代理沙箱，通过对window的拷贝建立多个副本，在沙箱中对建立的副本进行操作</p>
</li>
<li><p><em><strong>SnapshotSandbox</strong></em>：快照沙箱，基于 diff 方式实现的沙箱，用于不支持 Proxy 的低版本浏览器.将当前window的快照信息存到windowSnapshot中，如果modifyPropsMap有值，还需要还原上次的状态；激活期间，可能修改了window的数据；退出沙箱时，将修改过的信息存到modifyPropsMap里面，并且把window还原成初始进入的状态。</p>
</li>
</ul>
<h2 id="web-component"><a href="#web-component" class="headerlink" title="web-component"></a>web-component</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2019/08/web_components.html">https://www.ruanyifeng.com/blog/2019/08/web_components.html</a><br>Shadow DOM：我们不希望用户能够看到组件的内部代码，Web Component 允许内部代码隐藏起来，这叫做 Shadow DOM，即这部分 DOM 默认与外部 DOM 隔离，内部任何代码都无法影响外部。</li>
</ul>
<h2 id="样式隔离"><a href="#样式隔离" class="headerlink" title="样式隔离"></a>样式隔离</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shiazhen/p/17352397.html">https://www.cnblogs.com/shiazhen/p/17352397.html</a></li>
<li>主应用使用 styleLoader.js 加载子应用的 CSS 文件，生成style的标签，子应用template.innerHTML设置为模板，attachShadow设置当前元素是否样式隔离。</li>
</ul>
<h2 id="微前端跨域问题"><a href="#微前端跨域问题" class="headerlink" title="微前端跨域问题"></a>微前端跨域问题</h2><ul>
<li>qiankun 是通过 fetch 去获取子应用注册时配置的静态资源url，所有静态资源必须是支持跨域的，那就得设置允许源了</li>
</ul>
<h1 id="9-15-攻击"><a href="#9-15-攻击" class="headerlink" title="9.15(攻击)"></a>9.15(攻击)</h1><h2 id="XSS跨站脚本攻击"><a href="#XSS跨站脚本攻击" class="headerlink" title="XSS跨站脚本攻击"></a>XSS跨站脚本攻击</h2><ol>
<li>跨站脚本攻击,浏览器无法识别恶意脚本,一同执行.cookie,localStorage,DOM泄露.</li>
<li>解决方法:</li>
</ol>
<ul>
<li>CSP白名单:后端设置&#x2F;meta标签设置. </li>
<li>设置cookie为http-only,后端在响应头中的cookie-set字段设置.</li>
</ul>
<h2 id="CSRF跨站请求伪造攻击"><a href="#CSRF跨站请求伪造攻击" class="headerlink" title="CSRF跨站请求伪造攻击"></a>CSRF跨站请求伪造攻击</h2><ol>
<li>利用cookie在同源请求时候会携带,实现用户的身份冒充.用户信任网站A并授权cookie,并访问了恶意网站B.</li>
<li>get请求的CSRF,一般是img,script带src属性的标签,去发送请求<br>post请求是在form表单,有个js直接提交这个表单.</li>
<li>解决方法:</li>
</ol>
<ul>
<li>用token验证,token一般在请求头的authorization</li>
<li>HTTP请求头中的Referer字段:记录了请求的来源地址.网站A√,恶意网站B×</li>
<li>设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用.</li>
<li>cookie双重验证:除了cookie发送过去外,还从cookie中取出身份认证的参数再发一次(其实冗余了,不如用token)</li>
</ul>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><ol>
<li>攻击者和通信双方各自独立建立连接,交换其所收到的数据.</li>
</ol>
<h1 id="9-16-复习浏览器"><a href="#9-16-复习浏览器" class="headerlink" title="9.16(复习浏览器)"></a>9.16(复习浏览器)</h1><ul>
<li>白天复习完浏览器,刷两道链表.晚上项目</li>
</ul>
<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><ol>
<li>强制缓存,三种,expires&#x2F;cache-control判断是否过期</li>
<li>协商缓存,两种,last-modified&#x2F;etag判断是否有变化</li>
</ol>
<h2 id="地址栏回车-f5刷新-ctrl-f5刷新区别"><a href="#地址栏回车-f5刷新-ctrl-f5刷新区别" class="headerlink" title="地址栏回车,f5刷新,ctrl+f5刷新区别"></a>地址栏回车,f5刷新,ctrl+f5刷新区别</h2><ol>
<li>地址栏回车:强制缓存+协商缓存都走.</li>
<li>f5:不走强制缓存,走协商缓存.</li>
<li>ctrl+f5:强制缓存和协商缓存都不走.</li>
</ol>
<h2 id="浏览器的组成"><a href="#浏览器的组成" class="headerlink" title="浏览器的组成"></a>浏览器的组成</h2><ul>
<li>shell和内核组成</li>
</ul>
<ol>
<li>shell包括菜单栏,调用内核实现各种功能.</li>
<li>内核包括渲染引擎和js引擎.</li>
</ol>
<h2 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000042909353">https://segmentfault.com/a/1190000042909353</a></li>
</ul>
<ol>
<li>解析html文档,生成DOM树,由html元素和属性节点组成.</li>
<li>解析css,生成css树.</li>
<li>根据DOM树和CSS树构建渲染树</li>
<li>布局(回流):渲染树进行布局计算每个渲染节点的位置和大小.</li>
<li>绘制(重绘):将渲染树的节点绘制到页面上.</li>
<li>复合: 浏览器的绘制是绘制到多层,每一层单独渲染,最后合成到一起形成页面.</li>
<li>重绘:重绘不会带来重新布局,一般是修改背景颜色,边框阴影等属性.</li>
<li>回流:消耗性能,改变元素位置,DOM结构发生变化.</li>
</ol>
<h2 id="浏览器渲染优化"><a href="#浏览器渲染优化" class="headerlink" title="浏览器渲染优化"></a>浏览器渲染优化</h2><ol>
<li>js: script标签写在body后面. 用async和defer.</li>
<li>css:用link引入,开启一个线程去加载,不阻塞GUI渲染线程. @import:GUI线程会停止渲染去加载资源. css少的话就写在style标签中直接GUI渲染.</li>
<li>html:减少嵌套层次,减少回流重绘操作</li>
</ol>
<h2 id="减少回流和重绘操作"><a href="#减少回流和重绘操作" class="headerlink" title="减少回流和重绘操作"></a>减少回流和重绘操作</h2><ol>
<li>操作低层次的DOM.</li>
<li>脱离文档流,减少对其他元素影响.</li>
<li>将DOM读写操作分别放到一起,浏览器的渲染队列机制.</li>
<li>一些css属性形成新的合成层: transform,opacity等等.浏览器把这些变化交给GPU处理(不是所有合成层都给GPU,只有动画视觉效果时候交给GPU),GPU直接在显存中更改元素显示位置,无需CPU进行布局绘制的计算.</li>
</ol>
<h2 id="浏览器的本地存储"><a href="#浏览器的本地存储" class="headerlink" title="浏览器的本地存储"></a>浏览器的本地存储</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ol>
<li>大小限制4kb,不能跨域.</li>
<li>主要和seesion配合,存储sessionid,发送请求时候可以携带cookie,服务器识别sessionid来识别身份.</li>
</ol>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><ol>
<li>大小5MB,存储在本地,请求不会携带.</li>
<li>除非主动删除,否则不会消失.</li>
<li>同源多个标签可以共享数据.</li>
</ol>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><ol>
<li>同.</li>
<li>关闭窗口后会消失</li>
<li>同源多个标签不可以共享数据.</li>
</ol>
<h2 id="cookie字段"><a href="#cookie字段" class="headerlink" title="cookie字段"></a>cookie字段</h2><ol>
<li>domain:可以访问该cookie的域名</li>
<li>path:域名下的哪些路径可以访问该cookie</li>
<li>Expires:cookie过期时间,注意这个是cookie的expires!和缓存的不一样,缓存的是在请求头中!</li>
<li>name,value,size.</li>
</ol>
<ul>
<li>服务端在响应头可以用set-cookie来配置cookie信息.http-only限制cookie不能被js脚本读取.也有domain,path,expires.<br>(不要把缓存的六个字段和cookie的搞混了,缓存的是在请求头和响应头中)</li>
</ul>
<h2 id="indexDB"><a href="#indexDB" class="headerlink" title="indexDB"></a>indexDB</h2><ol>
<li>键值对存储,异步,支持事务(不会出现只修改部分数据情况),存储空间大(250MB+)</li>
</ol>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><ol>
<li>安全机制,隔离恶意文件.要求协议域名端口号都相同.</li>
<li>限制cookie,localstorage,indexDB&#x2F;DOM&#x2F;跨域请求.</li>
</ol>
<h2 id="场景题-Promise-allSettled"><a href="#场景题-Promise-allSettled" class="headerlink" title="场景题,Promise.allSettled()"></a>场景题,Promise.allSettled()</h2><ul>
<li>静态方法将一个 Promise 可迭代对象作为输入，并返回一个单独的 Promise。当所有输入的 Promise 都已敲定时（包括传入空的可迭代对象时），返回的 Promise 将被兑现，并带有描述每个 Promise 结果的对象数组。</li>
</ul>
<h1 id="9-17浏览器-刷题-项目"><a href="#9-17浏览器-刷题-项目" class="headerlink" title="9.17浏览器,刷题,项目."></a>9.17浏览器,刷题,项目.</h1><h2 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h2><ol>
<li>CORS(跨域资源共享):</li>
</ol>
<ul>
<li>简单请求: 浏览器直接发送请求携带origin,服务端响应时候设置access-control-allow-xxx等字段.</li>
<li>非简单请求(DELETE,PUT):在正式请求会发送一个<strong>预检请求options.</strong>,浏览器请求头中除了origin还会告诉服务器请求有哪些额外的http方法,哪些额外的请求头部.服务端响应头返回同意的字段后,后续浏览器请求只要origin.<br>(小点:默认跨域请求不携带cookie,后端响应头withCredentials字段可以设置带cookie)</li>
</ul>
<ol start="2">
<li>JSONP:利用script标签没有跨域限制.script的src发送带有回调函数的cb请求,服务端返回js代码,代码中调用回调函数,传递的参数传给该回调函数.<br>缺点:只能发送get请求,容易受到XSS攻击.</li>
<li>window.postmessage</li>
</ol>
<h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><ol>
<li>DOM0:不会传播,没有事件流</li>
<li>IE模型:事件触发,事件冒泡(从里到外).</li>
<li>DOM2模型:事件捕获(从外到里),事件触发,事件冒泡.</li>
</ol>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><ul>
<li>利用了事件冒泡的机制,将子节点的事件绑定到父节点上,由父节点的监听函数统一处理子节点.</li>
<li>减少了内存消耗,动态绑定事件.</li>
</ul>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ul>
<li>js是单线程,将不同函数的执行上下文压入栈中确保执行的顺序,遇到异步任务会挂起,等同步执行完后再去异步.</li>
<li>整体顺序是:先取出大的宏任务script,执行同,微任务进微任务队列,宏任务进宏任务队列.同执行完后执行微任务,然后下一个script.</li>
</ul>
<h2 id="宏任务-微任务"><a href="#宏任务-微任务" class="headerlink" title="宏任务,微任务"></a>宏任务,微任务</h2><ol>
<li>宏任务:script,setTimeout.</li>
<li>微任务: promise的回调,mutationObserver.</li>
</ol>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><ul>
<li>dom,闭包,全局变量,定时器.</li>
</ul>
<h2 id="环形链表1-2-快慢指针-快指针最后为null或者最后一个-循环条件是快指针"><a href="#环形链表1-2-快慢指针-快指针最后为null或者最后一个-循环条件是快指针" class="headerlink" title="环形链表1,2(快慢指针,快指针最后为null或者最后一个,循环条件是快指针)"></a>环形链表1,2(快慢指针,快指针最后为null或者最后一个,循环条件是快指针)</h2><h1 id="9-18"><a href="#9-18" class="headerlink" title="9.18"></a>9.18</h1><h2 id="常见http状态码？"><a href="#常见http状态码？" class="headerlink" title="常见http状态码？"></a>常见http状态码？</h2><ul>
<li>200，204，206.</li>
<li>301，302，304.</li>
<li>400，403，404.</li>
<li>500，502，503</li>
</ul>
<h2 id="get和post请求区别？"><a href="#get和post请求区别？" class="headerlink" title="get和post请求区别？"></a>get和post请求区别？</h2><ol>
<li>get获取数据，post修改</li>
<li>post有请求体</li>
<li>get安全，幂等</li>
<li>缓存</li>
</ol>
<h2 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>长连接，无需重复建立TCP连接。</li>
<li>管道运输。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>无状态</li>
<li>明文传输</li>
<li>队头阻塞，后面排序的请求无法发出。（管道传输大部分不支持）</li>
</ol>
<h2 id="http1-0和http1-1"><a href="#http1-0和http1-1" class="headerlink" title="http1.0和http1.1"></a>http1.0和http1.1</h2><ol>
<li>长连接短链接</li>
<li>强制缓存协商缓存字段区别</li>
<li>新增了状态码</li>
<li>范围请求：请求头加入range字段，请求部分数据，返回206。</li>
<li>是否支持管道运输</li>
<li>Host头部字段</li>
</ol>
<h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><ul>
<li>在http和tcp中加入了ssl&#x2F;tls协议，数据加密&#x2F;身份认证&#x2F;信息完整</li>
</ul>
<ol>
<li>混合加密：非对称加密，对称加密</li>
<li>摘要算法+数字签名：提取内容hash值， 私钥加密，公钥解密，对比hash是否相同。（区分内容加密和数字证书加密）</li>
<li>数字证书：CA私钥给服务端得公钥加密形成数字证书，数字证书发送给客户端，客户端浏览器内嵌了CA公钥，解密数字证书获取公钥。</li>
</ol>
<h2 id="TLS握手"><a href="#TLS握手" class="headerlink" title="TLS握手"></a>TLS握手</h2><ol>
<li>客户端向服务端发送加密请求：版本号，随机数，密码套件。</li>
<li>服务端确定版本号和采用的算法，生成随机数，数字证书。</li>
<li>客户端生成第三个随机数，生成会话密钥。从数字证书中取出服务端公钥，通知后续采用加密数据通信。</li>
<li>服务端获取第三个随机数也生成会话密钥，后续采用加密数据通信。</li>
</ol>
<h2 id="证书信用链"><a href="#证书信用链" class="headerlink" title="证书信用链"></a>证书信用链</h2><h2 id="http2-0（不要忘了它是基于https）"><a href="#http2-0（不要忘了它是基于https）" class="headerlink" title="http2.0（不要忘了它是基于https）"></a>http2.0（不要忘了它是基于https）</h2><ol>
<li>头部压缩</li>
<li>二进制传输</li>
<li>并向传输</li>
<li>主动推送资源</li>
</ol>
<h2 id="http1-1优化"><a href="#http1-1优化" class="headerlink" title="http1.1优化"></a>http1.1优化</h2><ol>
<li>强制缓存协商缓存</li>
<li>减少http请求</li>
</ol>
<ul>
<li>减少重定向次数，代理服务器处理重定向。</li>
<li>合并请求，减少重复请求头部。</li>
<li>延迟发送请求：按需加载</li>
</ul>
<ol start="3">
<li>压缩：减少传输的数据</li>
</ol>
<h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><ol>
<li>服务端主动推送，会先通知会在哪个streamID发送。请求了html，css也返回</li>
<li>头部压缩：静态表，哈夫曼表，动态表</li>
<li>二进制帧传输</li>
<li>并发请求：一个TCP上面多个steam流，每个steam流中包含<em><strong>一个</strong></em>http请求或者响应，每个http请求可能由多个frame组成。</li>
</ol>
<h1 id="9-22"><a href="#9-22" class="headerlink" title="9.22"></a>9.22</h1><h2 id="https优化"><a href="#https优化" class="headerlink" title="https优化"></a>https优化</h2><ol>
<li>协议优化:TLS升级,RSA算法&#x3D;&gt;ECDHE算法,2RTT到1RTT,支持前向保密性.</li>
<li>证书优化:证书验证是否过期:服务端周期性向CA查询证书状态,将结果直接返回给客户端,客户端不用再向CA请求.</li>
<li>会话复用:类似token的机制,快速识别身份.</li>
</ol>
<h2 id="http3-0"><a href="#http3-0" class="headerlink" title="http3.0"></a>http3.0</h2><ul>
<li>采用UDP+quic协议,解决队头阻塞+握手时延+连接迁移问题.</li>
</ul>
<ol>
<li>无队头阻塞,2.0某个流数据丢失会导影响其他流的数据接受,而3.0各个流之间无影响</li>
<li>更快的建立连接:quic协议握手和tls握手没有分层,quic协议握手一个RTT可以顺带上tls的信息,quic协议是用tls1.3,一次RTT可以完成建立连接和密钥协商.</li>
<li>连接迁移:(从4G网切换成wifi)quic协议握手时候协商了连接id,通过这个id可以快速恢复连接,避免原来的tcp,tls握手过程.</li>
<li>头部压缩:静态表扩充,动态表两个单向流同步.</li>
</ol>
<h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><ol>
<li>扫码登录时候,前端无法感知用户是否扫码,只能不断轮询请求后端.</li>
<li>长轮询机制,超时时间设置为30s,发出请求后30s内,服务端如果收到用户扫码的数据可以随时返回结果给客户端.</li>
</ol>
<h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><ul>
<li>基于tcp的协议</li>
<li>tcp是支持双向通信的(全双工),而http是单向通信(半双工)</li>
</ul>
<ol>
<li>使用websocket前会进行一次http通信,http请求头中携带upgrade:websocket字段</li>
</ol>
<h2 id="TCP传输层协议"><a href="#TCP传输层协议" class="headerlink" title="TCP传输层协议"></a>TCP传输层协议</h2><ol>
<li>面向连接</li>
<li>可靠的</li>
<li>基于字节流</li>
</ol>
<h2 id="UDP和TCP区别"><a href="#UDP和TCP区别" class="headerlink" title="UDP和TCP区别"></a>UDP和TCP区别</h2><ol>
<li>连接<br>tcp需要建立连接,udp直接传输数据</li>
<li>服务数量<br>tcp一对一,udp一对多</li>
<li>可靠<br>tcp可靠传输,udp不可靠传输</li>
<li>拥塞控制,流量控制</li>
<li>传输方式<br>tcp按顺序,udp不用</li>
</ol>
<h2 id="tcp和udp可以用同一个端口吗"><a href="#tcp和udp可以用同一个端口吗" class="headerlink" title="tcp和udp可以用同一个端口吗"></a>tcp和udp可以用同一个端口吗</h2><ul>
<li>可以,端口作用是传输层根据端口号将数据交付给不用的应用程序,ip包头的协议号可以知道该数据包是TCP&#x2F;UDP,然后交付给传输层的TCP&#x2F;UDP模块处理,然后根据端口号交给对应的应用程序.</li>
</ul>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ol>
<li>一开始都处于close状态,客户端打开连接,服务端被动打开进入listen状态.</li>
<li>客户端发送SYN同步标志为1,同时把初始化序号放到序号中,发送给服务端,客户端进入<em><strong>SYN-sent</strong></em>阶段.</li>
<li>服务端也同步SYN为1,ACK为1接受,确认号为客户端序号下一位,同时也把自己初始化序号放入序号中,服务端进入<em><strong>SYN-REC</strong></em>阶段.</li>
<li>客户端最后应答,ACK&#x3D;1,确认号为服务端序号下一位,这时可以携带数据发送.客户端进入ESTABLISHED状态</li>
<li>服务端收到后也进入ESTABLISHED(既定)状态.</li>
</ol>
<h2 id="为什么三次握手而不是两次"><a href="#为什么三次握手而不是两次" class="headerlink" title="为什么三次握手而不是两次?"></a>为什么三次握手而不是两次?</h2><ol>
<li>避免历史连接</li>
<li>同步双方初始序列号</li>
</ol>
<h2 id="为什么三次握手而不是四次"><a href="#为什么三次握手而不是四次" class="headerlink" title="为什么三次握手而不是四次?"></a>为什么三次握手而不是四次?</h2><ul>
<li>四次也可以,现在的第二次握手融合了四次的中间两次,ack和syn一起发送给客户端.</li>
</ul>
<h1 id="9-23"><a href="#9-23" class="headerlink" title="9.23"></a>9.23</h1><h2 id="第一次握手丢失-第二次握手丢失-第三次握手丢失"><a href="#第一次握手丢失-第二次握手丢失-第三次握手丢失" class="headerlink" title="第一次握手丢失,第二次握手丢失,第三次握手丢失"></a>第一次握手丢失,第二次握手丢失,第三次握手丢失</h2><ol>
<li>第一次: 客户端重传(没得到服务端响应),达到最大次数断开连接.</li>
<li>第二次: 客户端重传(没得到服务端响应),服务端重传(没得到客户端响应),达到最大次数断开连接.</li>
<li>第三次: 服务端重传,客户端收到后再重传第三次握手.(ACK应答不会主动传)</li>
</ol>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><ol>
<li>客户端打算关闭连接,发送FIN&#x3D;1,进入FIN_wait状态</li>
<li>服务端收到后回包ACK &#x3D; 1,进入CLOSED_WAIT状态</li>
<li>客户端收到ACK后进入FIN_wait2状态</li>
<li>服务端发送完数据后,发送FIN &#x3D; 1,进入last-ack</li>
<li>客户端收到后回包ACK &#x3D; 1,进入TIME_WAIT</li>
<li>服务端收到后进入CLOSE状态</li>
<li>客户端等2MSL（报文最大生存时间）后进入CLOSE状态</li>
</ol>
<h2 id="第一二三四次挥手丢失"><a href="#第一二三四次挥手丢失" class="headerlink" title="第一二三四次挥手丢失"></a>第一二三四次挥手丢失</h2><ol>
<li>第一次:客户端重传,达到最大次数后进入close状态</li>
<li>第二次:(ACK不会主动超时重传)客户端重传,服务端收到后再发送ACK.客户端达到最大次数后进入close状态.</li>
<li>第三次:服务端重传,达到最大次数后服务端close,客户端FIN_WAIT2状态等60s后进入close.</li>
<li>第四次:服务端重传,达到最大次数后close,客户端收到fin会重置TIME_WAIT时间(这里要原本等2MSL)</li>
</ol>
<h2 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h2><ul>
<li>MSL 报文最大生存时间</li>
</ul>
<ol>
<li>客户端ACK发出后,如果在最后丢失,服务端重传,重传的FIN可以在2MSL内到达客户端.</li>
</ol>
<h1 id="9-24"><a href="#9-24" class="headerlink" title="9.24"></a>9.24</h1><ul>
<li>投美团,滴滴,网易,B站,小红书,小米,拼多多.</li>
<li>投了美团</li>
</ul>
<h2 id="TCP滑动窗口-流量控制-拥塞控制"><a href="#TCP滑动窗口-流量控制-拥塞控制" class="headerlink" title="TCP滑动窗口,流量控制,拥塞控制."></a>TCP滑动窗口,流量控制,拥塞控制.</h2><h2 id="如何基于UDP协议实现可靠传输"><a href="#如何基于UDP协议实现可靠传输" class="headerlink" title="如何基于UDP协议实现可靠传输"></a>如何基于UDP协议实现可靠传输</h2><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><img src="/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.%E7%A7%8B%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image.png" srcset="/img/loading.gif" lazyload alt="alt text"></p>
<h1 id="9-25"><a href="#9-25" class="headerlink" title="9.25"></a>9.25</h1><h2 id="为什么需要TIME-WAIT状态"><a href="#为什么需要TIME-WAIT状态" class="headerlink" title="为什么需要TIME_WAIT状态?"></a>为什么需要TIME_WAIT状态?</h2><ol>
<li>避免历史数据被后续连接吸收,2MSL可以让这次连接中的数据包自然丢失.</li>
<li>保证被关闭方可以正确关闭.如果ACK在最后丢失,服务端可以重传FIN在2MSL内到达客户端.</li>
</ol>
<h2 id="UDP是面向报文的协议-TCP是面向字节流的协议"><a href="#UDP是面向报文的协议-TCP是面向字节流的协议" class="headerlink" title="UDP是面向报文的协议,TCP是面向字节流的协议"></a>UDP是面向报文的协议,TCP是面向字节流的协议</h2><ol>
<li>UDP协议传输数据时候不会对数据进行拆分,每个UDP报文就是一个消息边界.</li>
<li>TCP发送的包大小取决于滑动窗口,(拥塞控制流量控制).</li>
</ol>
<h1 id="9-26"><a href="#9-26" class="headerlink" title="9.26"></a>9.26</h1><h2 id="如何解决沾包问题"><a href="#如何解决沾包问题" class="headerlink" title="如何解决沾包问题?"></a>如何解决沾包问题?</h2><ol>
<li>固定长度的消息.</li>
<li>http头部设置回车,换行两个为消息边界.</li>
</ol>
<h2 id="为什么可以三次挥手"><a href="#为什么可以三次挥手" class="headerlink" title="为什么可以三次挥手?"></a>为什么可以三次挥手?</h2><ul>
<li>需要四次原因是因为还有数据要发送,数据发送完再调用关闭函数进入LAST-ACK状态.</li>
</ul>
<ol>
<li><em><strong>没有数据发送</strong></em>且<em><strong>开启了TCP延迟确认机制</strong></em>,那么第二次和第三次挥手就回合并,三次挥手.</li>
<li>TCP延迟确认机制是优化单独发ACK数据效率低,延迟等待一段时间,如果有数据发送则和ACK一起发送,提高效率.</li>
</ol>
<h2 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP&#x2F;IP网络模型"></a>TCP&#x2F;IP网络模型</h2><ol>
<li>应用层:专注为用户提供应用功能,不关注数据传输</li>
<li>传输层:TCPUDP,将应用层报文作为数据部分,添加TCP头部(IP地址,端口信息,SYN,FIN标志位)流量控制,拥塞控制,可靠传输,有端口号信息,负责把数据交付给对应的应用程序.</li>
<li>网络层:IP协议,将传输层报文作为数据部分,添加IP头部,每一个设备对应一个ip地址:网络号+主机号,各个局域网通过路由器连接起来,路由器作用就是找到目的地址的子网,找到后把数据包发送到对应的子网了. </li>
<li>数据链路(网络接口)层:在ip数据基础上再加MAC头部尾部,封装成数据帧.ARP地址解析协议(ip与mac地址的映射表)通过mac地址找到对应的主机.</li>
</ol>
<h2 id="输入url后发生的过程"><a href="#输入url后发生的过程" class="headerlink" title="输入url后发生的过程"></a>输入url后发生的过程</h2><ol>
<li>解析url(协议+域名+资源路径),生成get请求</li>
<li>浏览器本地缓存</li>
<li>查询DNS服务器,获取域名对应的IP地址.先查询本地域名服务器缓存,本地域名服务器没有则向根域名服务器(最高级的域名服务器)请求,根域名服务器给出顶级域名服务器(.com),顶级域名服务器给权威域名服务器,权威域名服务器给对应IP地址.</li>
<li>TCP三次握手,如果是https的话还有tls四次握手.确保可靠传输,拥塞控制,流量控制.</li>
<li>IP协议:封装成ip数据包,借助路由器转发.</li>
<li>MAC地址:借助ARP协议获取mac地址,可能是对应网络的路由器mac地址,如果是同一个网络则是对应主机的mac地址.交换机负责同一网络下的交付.</li>
<li>同样流程返回数据.</li>
</ol>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ol>
<li>运行中的程序,包括数据段,程序段,PCB(进程控制块:描述进程的信息,比如程序存放的位置);</li>
</ol>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><ul>
<li>创建态,就绪态,运行态,阻塞态,结束态.</li>
<li>就绪挂起态,阻塞挂起态.大量阻塞态会占据有限的内存,可以将这些进程放到外存(磁盘中)</li>
</ul>
<h2 id="进程的控制和管理"><a href="#进程的控制和管理" class="headerlink" title="进程的控制和管理"></a>进程的控制和管理</h2><ol>
<li>PCB(进程的唯一标识):进程的状态,进程的优先级,CPU上下文信息</li>
<li>通过链表存储,相同状态存放在一起,比如:就绪队列,阻塞队列.更适应进程创建,销毁多的场景.</li>
</ol>
<h2 id="线程-并发-共享资源"><a href="#线程-并发-共享资源" class="headerlink" title="线程:并发 共享资源"></a>线程:并发 共享资源</h2><ol>
<li>CPU调度的基本单位,<em><strong>可以并发且共享资源的执行</strong></em>,相比进程上下文切换线程的切换速度更快.</li>
</ol>
<h2 id="进程和线程的区别-10024"><a href="#进程和线程的区别-10024" class="headerlink" title="进程和线程的区别 &#10024;"></a>进程和线程的区别 &#10024;</h2><ol>
<li>根本区别:进程是操作系统资源分配的基本单位,线程是CPU任务调度和执行的基本单位.</li>
<li>关系:进程包含一个或多个线程</li>
<li>资源开销:进程有独立的数据段和程序段,程序之间切换成本大;线程是轻量级的进程,同一进程下的线程共享程序段和数据段,线程有自己独立的PC(程序计数器:记录下一条指令的位置)和执行栈,线程切换成本低速度快.</li>
</ol>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><ol>
<li>先来先服务</li>
<li>最短作业优先</li>
<li>高响应比优先调度: (等待时间+要求服务时间)&#x2F;要求服务时间.</li>
<li>时间片轮调度算法</li>
<li>优先级调度算法</li>
</ol>
<h2 id="http1-1-1"><a href="#http1-1-1" class="headerlink" title="http1.1"></a>http1.1</h2><ol>
<li>强制缓存,协商缓存</li>
<li>host字段</li>
<li>增加更多状态码</li>
<li>允许局部请求</li>
<li>短连接,长连接</li>
</ol>
<h1 id="9-27"><a href="#9-27" class="headerlink" title="9.27"></a>9.27</h1><ul>
<li>白天搞完操作系统,晚上复习计算机网络</li>
</ul>
<h2 id="操作系统-1"><a href="#操作系统-1" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h3><h3 id="进程状态-进程管理"><a href="#进程状态-进程管理" class="headerlink" title="进程状态,进程管理"></a>进程状态,进程管理</h3><h3 id="调度算法-1"><a href="#调度算法-1" class="headerlink" title="调度算法"></a>调度算法</h3><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><h3 id="get-post区别"><a href="#get-post区别" class="headerlink" title="get,post区别"></a>get,post区别</h3><h3 id="http头部"><a href="#http头部" class="headerlink" title="http头部"></a>http头部</h3><h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h3><h3 id="输入url到页面展示过程"><a href="#输入url到页面展示过程" class="headerlink" title="输入url到页面展示过程"></a>输入url到页面展示过程</h3><h1 id="9-28"><a href="#9-28" class="headerlink" title="9.28"></a>9.28</h1><h2 id="计算机网络复习完"><a href="#计算机网络复习完" class="headerlink" title="计算机网络复习完"></a>计算机网络复习完</h2><h2 id="手写object-create"><a href="#手写object-create" class="headerlink" title="手写object.create"></a>手写object.create</h2><h2 id="手写instanceof"><a href="#手写instanceof" class="headerlink" title="手写instanceof"></a>手写instanceof</h2><h2 id="手写new"><a href="#手写new" class="headerlink" title="手写new"></a>手写new</h2><h2 id="手写promise-all"><a href="#手写promise-all" class="headerlink" title="手写promise.all"></a>手写promise.all</h2><h2 id="手写promise-race"><a href="#手写promise-race" class="headerlink" title="手写promise.race"></a>手写promise.race</h2><h1 id="9-29休息一天"><a href="#9-29休息一天" class="headerlink" title="9.29休息一天"></a>9.29休息一天</h1><h1 id="9-30"><a href="#9-30" class="headerlink" title="9.30"></a>9.30</h1><h2 id="setTimeout的this的问题"><a href="#setTimeout的this的问题" class="headerlink" title="setTimeout的this的问题"></a>setTimeout的this的问题</h2><h2 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h2><h2 id="手写类型判断"><a href="#手写类型判断" class="headerlink" title="手写类型判断"></a>手写类型判断</h2><h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call,apply,bind"></a>call,apply,bind</h2><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><h1 id="10-1"><a href="#10-1" class="headerlink" title="10.1"></a>10.1</h1><h2 id="函数柯里化-参数长度不固定-固定两种情况"><a href="#函数柯里化-参数长度不固定-固定两种情况" class="headerlink" title="函数柯里化:参数长度不固定&#x2F;固定两种情况"></a>函数柯里化:参数长度不固定&#x2F;固定两种情况</h2><h2 id="ajax发送请求"><a href="#ajax发送请求" class="headerlink" title="ajax发送请求"></a>ajax发送请求</h2><h2 id="promise封装ajax发送请求"><a href="#promise封装ajax发送请求" class="headerlink" title="promise封装ajax发送请求"></a>promise封装ajax发送请求</h2><h2 id="浅拷贝-深拷贝"><a href="#浅拷贝-深拷贝" class="headerlink" title="浅拷贝,深拷贝"></a>浅拷贝,深拷贝</h2><h2 id="数据处理-差一个解析url参数"><a href="#数据处理-差一个解析url参数" class="headerlink" title="数据处理(差一个解析url参数)"></a>数据处理(差一个解析url参数)</h2><h1 id="10-2"><a href="#10-2" class="headerlink" title="10.2"></a>10.2</h1><h2 id="代码输出题this"><a href="#代码输出题this" class="headerlink" title="代码输出题this."></a>代码输出题this.</h2><h2 id="代码输出题-作用域"><a href="#代码输出题-作用域" class="headerlink" title="代码输出题:作用域"></a>代码输出题:作用域</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ol>
<li>var申明会提升,函数执行上下文或全局执行上下文</li>
<li>注意如果函数或全局有if等其他大括号包含的var申明,也会提升到函数和全局.</li>
</ol>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><ul>
<li>代码执行环境的抽象概念</li>
<li>全局执行上下文,函数执行上下文</li>
<li>执行栈</li>
<li>创建(this指向,词法环境: let const,变量环境)-执行-销毁</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul>
<li>变量和函数可以被访问的区域</li>
<li>全局作用域,函数作用域,块级作用域</li>
<li>词法作用域</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>一个函数访问另一个函数中的变量,一个函数捆绑了另一个函数的词法环境,这个函数就是闭包.</li>
<li>原理:函数在定义时候会创建作用域链,保存在<code>[[scope]]</code>中,当执行这个函数时候会创建函数上下文(包括词法环境),复制scope并将该词法环境推到作用域链最前端</li>
<li>创建私有变量,延长变量的生命周期.</li>
</ul>
<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><ol>
<li>new构造函数</li>
<li>call,apply,bind</li>
<li>对象调用</li>
<li>全局调用</li>
</ol>
<h1 id="10-3"><a href="#10-3" class="headerlink" title="10.3"></a>10.3</h1><h2 id="执行上下文-作用域-闭包-代码输出题总结-this-作用域"><a href="#执行上下文-作用域-闭包-代码输出题总结-this-作用域" class="headerlink" title="执行上下文,作用域,闭包 + 代码输出题总结:this,作用域"></a>执行上下文,作用域,闭包 + 代码输出题总结:this,作用域</h2><h2 id="对象-基本概念-创建-继承"><a href="#对象-基本概念-创建-继承" class="headerlink" title="对象 : 基本概念,创建,继承"></a>对象 : 基本概念,创建,继承</h2><h2 id="原型链-代码输出题"><a href="#原型链-代码输出题" class="headerlink" title="原型链+ 代码输出题"></a>原型链+ 代码输出题</h2><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><ul>
<li>为变量分配内存,当变量不再被访问时候清除,回收内存</li>
<li>标记清除: 垃圾回收器遍历所有对象,可访问的变量标记,对于没有标记的对象进行清除.</li>
<li>引用计数: 循环引用.</li>
<li>标记清除之上: 分代收集:新生代存放生命周期短的变量频繁清理,新生代变量可能变为老生代,清理频率低</li>
<li>内存泄漏: 全局变量,dom引用,未关闭的定时器,错误的闭包使用.</li>
</ul>
<h1 id="10-4"><a href="#10-4" class="headerlink" title="10.4"></a>10.4</h1><h2 id="复习对象-原型链-this-垃圾回收机制-9989"><a href="#复习对象-原型链-this-垃圾回收机制-9989" class="headerlink" title="复习对象,原型链,this,垃圾回收机制 &#9989;"></a>复习对象,原型链,this,垃圾回收机制 &#9989;</h2><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="异步-1"><a href="#异步-1" class="headerlink" title="异步"></a>异步</h3><ul>
<li>js是单线程,不会一直等请求回来,去执行其他代码,就有了异步概念.任务分为同步任务和异步任务,同步代码按顺序进主线程执行,异步任务分为宏任务队列和微任务队列,同步任务执行完后再执行微任务队列.</li>
</ul>
<h3 id="事件循环-1"><a href="#事件循环-1" class="headerlink" title="事件循环"></a>事件循环</h3><ul>
<li>先执行第一个大的宏任务script,执行同步代码,有微任务推进微任务队列,有宏任务推进宏任务队列.同步执行完后执行微任务队列,然后执行下一个宏任务.依次类推.</li>
</ul>
<h3 id="promise和async-看了promise输出的前12题"><a href="#promise和async-看了promise输出的前12题" class="headerlink" title="promise和async,看了promise输出的前12题"></a>promise和async,看了promise输出的前12题</h3><ol>
<li>promise是一个有状态的对象,创建时候传入执行器函数,在执行器函数里初始化异步行为和控制promise最终状态的转换,执行器函数是同步执行的.</li>
<li>状态有pending,fulfilled,rejected三种,状态落定后是不可改变的.</li>
<li>promise的状态代表异步行为是否完成,通过resolve,reject函数决定.</li>
</ol>
<h2 id="浏览器渲染原理-1"><a href="#浏览器渲染原理-1" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000042909353">https://segmentfault.com/a/1190000042909353</a></li>
</ul>
<ol>
<li>解析html文档,生成DOM树,由html元素和属性节点组成.</li>
<li>解析css,生成css树.</li>
<li>根据DOM树和CSS树构建渲染树</li>
<li>布局(回流):渲染树进行布局计算每个渲染节点的位置和大小.</li>
<li>绘制(重绘):将渲染树的节点绘制到页面上.</li>
<li>复合: 浏览器的绘制是绘制到多层,每一层单独渲染,最后合成到一起形成页面.</li>
<li>重绘:重绘不会带来重新布局,一般是修改背景颜色,边框阴影等属性.</li>
<li>回流:消耗性能,改变元素位置,DOM结构发生变化.</li>
</ol>
<h2 id="浏览器渲染优化-1"><a href="#浏览器渲染优化-1" class="headerlink" title="浏览器渲染优化"></a>浏览器渲染优化</h2><ol>
<li>js: script标签写在body后面. 用async和defer.</li>
<li>css:用link引入,开启一个线程去加载,不阻塞GUI渲染线程. @import:GUI线程会停止渲染去加载资源. css少的话就写在style标签中直接GUI渲染.</li>
<li>html:减少嵌套层次,减少回流重绘操作</li>
</ol>
<h2 id="减少回流和重绘操作-1"><a href="#减少回流和重绘操作-1" class="headerlink" title="减少回流和重绘操作"></a>减少回流和重绘操作</h2><ol>
<li>操作低层次的DOM.</li>
<li>脱离文档流,减少对其他元素影响.</li>
<li>将DOM读写操作分别放到一起,浏览器的渲染队列机制.</li>
<li>一些css属性形成新的合成层: transform,opacity等等.浏览器把这些变化交给GPU处理(不是所有合成层都给GPU,只有动画视觉效果时候交给GPU),GPU直接在显存中更改元素显示位置,无需CPU进行布局绘制的计算.</li>
</ol>
<h2 id="算法继续推进"><a href="#算法继续推进" class="headerlink" title="算法继续推进"></a>算法继续推进</h2><h2 id="准备进入vue"><a href="#准备进入vue" class="headerlink" title="准备进入vue"></a>准备进入vue</h2><h1 id="10-5"><a href="#10-5" class="headerlink" title="10.5"></a>10.5</h1><h2 id="js基础"><a href="#js基础" class="headerlink" title="js基础"></a>js基础</h2><h3 id="栈内存-堆内存"><a href="#栈内存-堆内存" class="headerlink" title="栈内存,堆内存"></a>栈内存,堆内存</h3><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7264503343995912246#heading-1">https://juejin.cn/post/7264503343995912246#heading-1</a></li>
<li>堆内存才有垃圾回收机制,栈内存在函数调用变量声明时候压入数据,函数执行完变量词法环境销毁时候压出栈.</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li>+运算符有字符串时候进行拼接.其他运算符都是能转换为数字都转换为数字.</li>
</ul>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><ul>
<li>对象一般调用的都是Object.prototype上面的同String()方法,但function和date两个内置对象在原型上重写了toString()方法.</li>
</ul>
<h3 id="let-const-var"><a href="#let-const-var" class="headerlink" title="let,const,var"></a>let,const,var</h3><ol>
<li>变量提升,作用死区</li>
<li>重复声明</li>
<li>块级作用域</li>
<li>var给全局window对象添加属性</li>
<li>const要设置初始值.<br>10.5 - 10.7vue搞完,后面进webpack,css.</li>
</ol>
<h1 id="10-6"><a href="#10-6" class="headerlink" title="10.6"></a>10.6</h1><h2 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h2><h2 id="map-weakMap-10024"><a href="#map-weakMap-10024" class="headerlink" title="map weakMap &#10024;"></a>map weakMap &#10024;</h2><ul>
<li>键有顺序,任意值,没有原型其他键,本质其实是一个二维数组. 有size,可遍历.</li>
<li>weakMap键只能为对象,且为弱引用,垃圾回收机制不会考虑weakMap的引用,如果对象没有其他引用,会自动清除weakMap的键及其的值.</li>
<li>set get has delete clear</li>
</ul>
<h2 id="set-weakSet-10024"><a href="#set-weakSet-10024" class="headerlink" title="set weakSet &#10024;"></a>set weakSet &#10024;</h2><ol>
<li>NaN是相等的,<em><strong>两个对象是不相等的</strong></em>.</li>
<li>add has delete clear</li>
<li>weakSet只能放对象和symbol值,都是弱引用,不考虑垃圾回收机制.</li>
</ol>
<h2 id="JSON-stringify-JSON-prase-10024"><a href="#JSON-stringify-JSON-prase-10024" class="headerlink" title="JSON.stringify JSON.prase &#10024;"></a>JSON.stringify JSON.prase &#10024;</h2><ol>
<li>function,symbol,undefined,不可枚举属性会消失,NaN&#x3D;&#x3D;&gt;null</li>
<li>原型链 循环引用不会转换</li>
</ol>
<h2 id="es和commonjs模块化区别"><a href="#es和commonjs模块化区别" class="headerlink" title="es和commonjs模块化区别"></a>es和commonjs模块化区别</h2><h2 id="AST语法树生成过程"><a href="#AST语法树生成过程" class="headerlink" title="AST语法树生成过程"></a>AST语法树生成过程</h2><ol>
<li>模板裁剪到为空,开始标签,结束标签,文本标签.</li>
<li>生成ast节点.</li>
<li>栈和全局变量:控制父子节点关系和根节点.</li>
<li>返回ast树.</li>
</ol>
<h2 id="ast语法树和虚拟dom区别"><a href="#ast语法树和虚拟dom区别" class="headerlink" title="ast语法树和虚拟dom区别?"></a>ast语法树和虚拟dom区别?</h2><ol>
<li>ast语法树出现在编译阶段,一般是开发环境的构建工具(如vite)启的服务器上执行,把.vue文件生成js代码,生成一个render渲染函数.</li>
<li>虚拟DOM出现在运行阶段,由浏览器执行js代码,执行render函数生成虚拟DOM,diff对比,最后生成新的DOM页面.</li>
</ol>
<h2 id="npm-run-build理解"><a href="#npm-run-build理解" class="headerlink" title="npm run build理解?"></a>npm run build理解?</h2><ul>
<li>Vue 项目会将 .vue 文件中的内容转换为 JavaScript，并进行编译、优化，最终打包为浏览器可执行的 JavaScript 文件。然而，这个打包后的文件通常不包含 AST 转换相关的函数文件或编译器代码。</li>
<li>vue的两个版本:生产环境版本和运行时版本,运行版本没有编译器功能.</li>
</ul>
<h2 id="AST语法对象-render函数-虚拟DOM"><a href="#AST语法对象-render函数-虚拟DOM" class="headerlink" title="AST语法对象 &#x3D;&gt; render函数 &#x3D;&gt; 虚拟DOM"></a>AST语法对象 &#x3D;&gt; render函数 &#x3D;&gt; 虚拟DOM</h2><ul>
<li>代码拼接,生成字符串,_c,_v函数,这些函数是生成虚拟DOM节点.</li>
<li>new Function,with(this)</li>
<li>执行,去组件对象上拿数据,生成虚拟DOM.</li>
</ul>
<h2 id="vue2的diff算法"><a href="#vue2的diff算法" class="headerlink" title="vue2的diff算法"></a>vue2的diff算法</h2><ul>
<li>对比是否为相同节点,如果标签名和key相同,则复用旧节点的DOM.</li>
<li>修改文本内容和DOM属性</li>
<li>对比孩子<br>头头,尾尾,头尾,映射表</li>
</ul>
<h2 id="vue3的diff算法"><a href="#vue3的diff算法" class="headerlink" title="vue3的diff算法"></a>vue3的diff算法</h2><ul>
<li>只有头头指针和尾尾指针对比,最长递增子序列 </li>
<li>对事件缓存,缓存监听器,减少监听器的重复创建和销毁.</li>
<li>静态标记</li>
</ul>
<h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><h2 id="数组响应式原理"><a href="#数组响应式原理" class="headerlink" title="数组响应式原理"></a>数组响应式原理</h2><h2 id="vue2响应式原理缺点-vue3响应式原理"><a href="#vue2响应式原理缺点-vue3响应式原理" class="headerlink" title="vue2响应式原理缺点,vue3响应式原理"></a>vue2响应式原理缺点,vue3响应式原理</h2><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><ul>
<li>监听的数据会封装成一个函数,函数会默认执行一次,读取数据,数据调用get收集该watcher.</li>
</ul>
<h1 id="10-7"><a href="#10-7" class="headerlink" title="10.7"></a>10.7</h1><ul>
<li>看完vue的read,interview.</li>
</ul>
<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><h2 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h2><ul>
<li>创建watcher</li>
</ul>
<ol>
<li>lazy,默认不求值.</li>
<li>dirty,有缓存.</li>
<li>默认脏数据,执行回调函数,读取里面的响应式数据,里面的数据收集计算属性的watcher,当里面的数据被更改时候,触发notify,让计算属性变为脏数据,重新求值.</li>
<li>(代理到组件对象上)</li>
</ol>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol>
<li>watcher去重,渲染函数只会执行一次</li>
<li>底层调用了nextTick方法,js事件循环的应用,有一个队列缓冲这次事件循环所有的同步任务,上一个队列执行完后才能执行下一个队列.</li>
<li>优雅降级: promise.then &#x3D;&gt; mutationObserver &#x3D;&gt; setImmediate &#x3D;&gt; setTimeout.</li>
</ol>
<h2 id="Vue-extend-为什么data为函数"><a href="#Vue-extend-为什么data为函数" class="headerlink" title="Vue.extend(为什么data为函数)"></a>Vue.extend(为什么data为函数)</h2><ul>
<li>返回子构造函数,选项相同则复用子构造函数,如果不为函数则共享对象内存地址.</li>
</ul>
<h2 id="Vue-mixin"><a href="#Vue-mixin" class="headerlink" title="Vue.mixin"></a>Vue.mixin</h2><ol>
<li>Vue.options</li>
</ol>
<h2 id="组件渲染过程"><a href="#组件渲染过程" class="headerlink" title="组件渲染过程"></a>组件渲染过程</h2><ul>
<li>父组件在创建虚拟DOM时候,遇到子组件标签时会把自己身上的子组件构造函数(核心:父组件的选项中有子组件的构造函数)放到子组件虚拟DOM上.</li>
<li>父组件渲染到子组件时候,会调用子组件虚拟DOM上的init方法,创建组件实例进行渲染.</li>
</ul>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul>
<li>补丁函数.</li>
</ul>
<h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><ul>
<li>组件不需要上来就渲染,避免同步加载卡顿页面,异步引入.先渲染一个占位组件,后续加载完后重新渲染.</li>
<li>异步组件本身是一个promise对象,pending状态时候返回占位组件,等promise状态变为resolve或reject时候重新渲染.</li>
</ul>
<h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><ol>
<li>组件类型分为类组件和函数式组件,类组件有this.函数式组件没有this,生命周期,watcher</li>
<li>调用h函数&#x2F;render返回虚拟DOM直接进行渲染,适合只有渲染逻辑的情况.</li>
</ol>
<h2 id="props原理"><a href="#props原理" class="headerlink" title="props原理"></a>props原理</h2><ul>
<li>创建组件虚拟节点时候会拿到组件声明的props,与传入到组件的属性一一映射,如果属性中找到props申明,会把该属性单独拿出来放到componentOptions上.</li>
<li>初始化init时候把props放到组件实例$options上,并把props属性定义为响应式放到组件上(可以直接被模板读取).</li>
</ul>
<h2 id="props为什么是单向数据流"><a href="#props为什么是单向数据流" class="headerlink" title="props为什么是单向数据流?"></a>props为什么是单向数据流?</h2><ul>
<li>props数据的setter里面会进行判断,是否为根组件,是否为父组件,否则报错.</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li>创建组件虚拟节点时候把事件放到虚拟节点$listener</li>
<li>初始化init时候放到组件实例的$options上.</li>
<li>从组件实例上拿事件,组件实例有个event属性维护事件,<code>$on</code>把事件名和事件绑定到上面,$emit从event数组中取出事件执行.</li>
</ul>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><h3 id="默认-具名插槽"><a href="#默认-具名插槽" class="headerlink" title="默认&#x2F;具名插槽"></a>默认&#x2F;具名插槽</h3><ul>
<li>父组件调用渲染函数的时候创建插槽的虚拟节点,所以插槽这个时候使用的是父组件的数据.将插槽虚拟节点作为子组件虚拟节点的属性.子组件初始化创建组件实例后将插槽虚拟节点放到组件实例上,同时解析插槽虚拟节点是否有slot属性,有的话就是具名插槽,会和默认插槽区分.渲染子组件时候遇到slot标签则去组件实例上获取插槽.</li>
</ul>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><ul>
<li>不会再直接创建插槽虚拟节点作为子组件虚拟节点属性,而是将其格式化为一个函数再作为属性.</li>
<li>子组件初始化时候将函数放到组件实例上</li>
<li>子组件渲染时候,在slot标签上通过name找到对应的函数,传入参数.函数执行&#x3D;&gt;插槽虚拟节点.</li>
</ul>
<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><ol>
<li>keep-alive也是个组件,它里面的组件也是插槽,在父组件执行渲染函数时候会把插槽虚拟节点作为keep-alive虚拟节点的属性</li>
<li>keep-alive虚拟节点初始化后将插槽虚拟节点放到组件实例上.</li>
<li>includes判断该插槽虚拟节点是否需要缓存,不需要直接返回虚拟节点,然后渲染.<br>需要的话:<br>判断是否在缓存数组中,在的话删除key,然后将这个组件key放置末尾(LRU算法)<br>不存在的话,则把key加入末尾,如果数组长度超过max则去除最长未使用的组件key.</li>
</ol>
<h2 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide,inject"></a>provide,inject</h2><ul>
<li>在组件init中有个initprovide方法,会在当前组件实例上添加一个_provide属性,provide提供的数据都会存储在里面.</li>
<li>子组件inject数据时递归查询父组件的_provide属性,找到为止.会先在自己的_provide属性上查找,所以依赖来源不明确.</li>
</ul>
<h2 id="v-if和v-for优先级"><a href="#v-if和v-for优先级" class="headerlink" title="v-if和v-for优先级"></a>v-if和v-for优先级</h2><ul>
<li>vue2中,v-for优先级高于v-if,vue3相反.</li>
</ul>
<h2 id="v-if和v-show区别及其原理"><a href="#v-if和v-show区别及其原理" class="headerlink" title="v-if和v-show区别及其原理"></a>v-if和v-show区别及其原理</h2><ul>
<li>v-if控制是否渲染虚拟节点</li>
<li>v-show,display属性为原先值还是none</li>
</ul>
<h2 id="display-visibility-opacity"><a href="#display-visibility-opacity" class="headerlink" title="display,visibility,opacity"></a>display,visibility,opacity</h2><ol>
<li>空间上,display不占据,其他占据</li>
<li>性能上:display回流重绘,visibility重绘,opacity单独形成合成层,利用GPU加速渲染</li>
<li>事件上:opacity触发事件</li>
</ol>
<h2 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h2><ul>
<li>非组件情况:v-bind+@input的语法糖.</li>
<li>组件情况: props+绑定事件的语法糖</li>
</ul>
<h1 id="10-8"><a href="#10-8" class="headerlink" title="10.8"></a>10.8</h1><ul>
<li>复习vue</li>
</ul>
<h2 id="打家劫舍1"><a href="#打家劫舍1" class="headerlink" title="打家劫舍1"></a>打家劫舍1</h2><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><h2 id="MVC-MVVM-MVP"><a href="#MVC-MVVM-MVP" class="headerlink" title="MVC MVVM MVP"></a>MVC MVVM MVP</h2><ol>
<li><em><strong>MVC观察者模式model可直接到view</strong></em>:采用了<strong>观察者模式</strong>,数据更改立即通知页面更新.数据和页面有一定耦合性.页面更改时,会触发controller来控制model层数据更新.</li>
<li><em><strong>MVP</strong></em>:view和model都需要经过中间处理.</li>
<li><em><strong>MVVM</strong></em>:VM对P的升级,将手动的   数据更改&#x3D;&gt;页面 操作自动化.降低代码复杂度</li>
</ol>
<h2 id="computed和watch区别"><a href="#computed和watch区别" class="headerlink" title="computed和watch区别"></a>computed和watch区别</h2><ol>
<li>computed:同步,缓存.</li>
<li>watch: 异步,不缓存.</li>
</ol>
<h2 id="computed和method区别"><a href="#computed和method区别" class="headerlink" title="computed和method区别"></a>computed和method区别</h2><ol>
<li>computed缓存,依赖的值未变化时候不会执行函数.</li>
<li>method总会执行函数.</li>
</ol>
<h2 id="slot默认插槽-具名插槽-作用域插槽"><a href="#slot默认插槽-具名插槽-作用域插槽" class="headerlink" title="slot默认插槽,具名插槽,作用域插槽"></a>slot默认插槽,具名插槽,作用域插槽</h2><ol>
<li>创建子组件虚拟节点时候把插槽虚拟节点作为其属性</li>
<li>子组件实例init后,插槽虚拟节点放到$slot属性上</li>
<li>子组件调用render函数时候遇到slot标签用插槽虚拟节点替换.</li>
</ol>
<h2 id="如何保存当前页面状态"><a href="#如何保存当前页面状态" class="headerlink" title="如何保存当前页面状态"></a>如何保存当前页面状态</h2><ol>
<li>localStorage,sessionStorage.</li>
<li>路由传值</li>
<li>vuex(微前端在全局事件总线)</li>
<li>父组件存储</li>
</ol>
<h2 id="事件模型-1"><a href="#事件模型-1" class="headerlink" title="事件模型"></a>事件模型</h2><ol>
<li>DOM0事件模型: 没有事件流</li>
<li>IE事件模型: 事件触发,事件冒泡</li>
<li>DOM2事件模型:事件捕获,事件触发,事件冒泡.(从document一直往下传播到目标元素)</li>
</ol>
<h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><ol>
<li>.stop阻止冒泡</li>
<li>.prevent阻止默认事件</li>
<li>.capture事件捕获模型</li>
<li>.self只触发自己</li>
<li>.once只触发一次</li>
</ol>
<h2 id="v-html原理"><a href="#v-html原理" class="headerlink" title="v-html原理"></a>v-html原理</h2><ol>
<li>移除当前元素下的所有标签,添加innerHtmL,值为v-html的值.</li>
</ol>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><ol>
<li>表单元素上: v-bind + @input</li>
<li>组件元素上: props + 绑定事件</li>
</ol>
<h2 id="data为什么是一个函数"><a href="#data为什么是一个函数" class="headerlink" title="data为什么是一个函数?"></a>data为什么是一个函数?</h2><ul>
<li>Vue.extend返回构造函数,传入的选项放在构造函数上.如果选项相同则会复用构造函数,因此多个组件实例的data会访问同一个共享地址的对象.</li>
</ul>
<h2 id="keep-alive原理"><a href="#keep-alive原理" class="headerlink" title="keep-alive原理"></a>keep-alive原理</h2><ol>
<li>keep-alive也为一个组件,将插槽虚拟节点作为keepalive组件虚拟节点的属性</li>
<li>创建keepalive组件实例时候把插槽节点放到组件实例$slots上.</li>
<li>调用render函数创建真实节点,includes判断是否在缓存数组中,不在的话直接返回虚拟节点渲染.在的话,在缓存数组中查看是否有,有的话移到数组末尾.(LRU算法)不在的话添加到数组末尾.超过max则删除第一个.</li>
</ol>
<h2 id="nextTick-1"><a href="#nextTick-1" class="headerlink" title="nextTick"></a>nextTick</h2><ol>
<li>对js事件循环的应用,利用js的异步任务队列实现vue框架的异步任务队列.</li>
<li>如果是同步更新,多次对一个属性赋值会频繁触发DOM渲染,可以减少无用渲染</li>
</ol>
<h1 id="10-9"><a href="#10-9" class="headerlink" title="10.9"></a>10.9</h1><ul>
<li>上午复习完vue.30min:生命周期+组件通信.剩下时间vue基础,但上午要进入vue-router</li>
<li>下午vue-router+vuex+刷题</li>
<li>后续规划: vue复习,项目亮点,算法,webpack和css</li>
</ul>
<h2 id="TCP-UDP区别"><a href="#TCP-UDP区别" class="headerlink" title="TCP,UDP区别"></a>TCP,UDP区别</h2><ol>
<li>连接,可靠,流量控制拥塞控制,字节流包,服务对象.</li>
</ol>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><h2 id="两次握手不行原因"><a href="#两次握手不行原因" class="headerlink" title="两次握手不行原因?"></a>两次握手不行原因?</h2><ol>
<li>避免历史连接<br>服务端没有中间状态给客户端阻止连接,导致服务端建立一个无用的历史连接浪费资源.<br>三次握手客户端在收到服务端ACK时候可以判断是否为正确序号.</li>
<li>避免资源浪费:两次握手的话服务端在收到客户端SYN后就会进行通信.</li>
<li>同步双方初始化序号:服务端发送初始化序号时候客户端需要应答回应ack.</li>
</ol>
<h2 id="数组响应式-set"><a href="#数组响应式-set" class="headerlink" title="数组响应式,$set"></a>数组响应式,$set</h2><ol>
<li>Observer处理对象属性为set,get时也会给对象本身加一个dep类,该dep类也会会收集其属性依赖的watcher.</li>
<li>$set其实就是手动调用了该对象dep类的notify通知watcher更新执行渲染函数</li>
<li>数组方法进行了重写,一是调用原来的数组方法,二是调用数组的dep.notify().</li>
</ol>
<h2 id="单页面和多页面"><a href="#单页面和多页面" class="headerlink" title="单页面和多页面"></a>单页面和多页面</h2><ol>
<li>单页面一次性加载资源,多页面多次加载</li>
<li>路由:单页面应用:history,hash.多页面应用通过路径跳转.</li>
<li>数据传递:单页面vuex.多页面cookie,localStorage,sessionStorage,接口保存.</li>
<li>单页面局部更新,切换速度快.多页面全局更新,切换速度慢.</li>
</ol>
<h2 id="react和vue区别"><a href="#react和vue区别" class="headerlink" title="react和vue区别"></a>react和vue区别</h2><h2 id="Vue优点"><a href="#Vue优点" class="headerlink" title="Vue优点"></a>Vue优点</h2><h2 id="assets和static区别"><a href="#assets和static区别" class="headerlink" title="assets和static区别"></a>assets和static区别</h2><ol>
<li>两者都可以存储静态资源,图片样式等等.</li>
<li>assets文件在npm run build时候会进行打包压缩,最后一起放到static中跟随index.html一同上传到服务器.</li>
<li>static资源不会走打包压缩格式化流程,而是直接进入打包后的目录上传至服务器.效率跟高,但占用体积更大.</li>
</ol>
<h2 id="delete和Vue-delete"><a href="#delete和Vue-delete" class="headerlink" title="delete和Vue.delete"></a>delete和Vue.delete</h2><ol>
<li>两者对对象处理结果相同</li>
<li>对数组处理:delete会把数组对应元素变为empty或undefined,Vue.delete会改变数组长度.</li>
</ol>
<h2 id="SSR服务端渲染"><a href="#SSR服务端渲染" class="headerlink" title="SSR服务端渲染?"></a>SSR服务端渲染?</h2><ul>
<li>优点:</li>
</ul>
<ol>
<li>更快的首屏加载速度.服务端根据请求路径获取到对应组件,服务端组件请求数据,将组件渲染为html.将html和vue文件作为响应内容返回给客户端.客户端渲染页面,并加载vue文件,将页面变为动态页面.</li>
<li>更好支持SEO,搜索引擎爬虫可以获取到完全渲染的页面.</li>
</ol>
<ul>
<li>缺点:</li>
</ul>
<ol>
<li>只支持beforeCreate钩子和created钩子.</li>
<li>增大服务端压力.</li>
</ol>
<h2 id="对SPA单页面应用的理解"><a href="#对SPA单页面应用的理解" class="headerlink" title="对SPA单页面应用的理解?"></a>对SPA单页面应用的理解?</h2><ul>
<li>优点:</li>
</ul>
<ol>
<li>一次性获取所有js,css,html文件,减少服务端压力.</li>
<li>内容改动无需重新加载整个页面,局部更新页面.</li>
<li>前后端分离,前端负责图层,后端负责数据层.</li>
</ol>
<ul>
<li>缺点:</li>
</ul>
<ol>
<li>首屏加载速度慢</li>
<li>客户端占用更多内存和cpu资源.</li>
<li>前端手动实现路由,管理浏览器前进后退功能.</li>
</ol>
<h2 id="vue初始化页面闪动问题"><a href="#vue初始化页面闪动问题" class="headerlink" title="vue初始化页面闪动问题"></a>vue初始化页面闪动问题</h2><ul>
<li>数据异步获取,页面先渲染完出现闪动情况.</li>
<li>解决方法:[v-cloak]:{display:none}</li>
</ul>
<h2 id="MVVM优缺点"><a href="#MVVM优缺点" class="headerlink" title="MVVM优缺点"></a>MVVM优缺点</h2><ol>
<li>将视图和数据解耦合,提高视图和数据的复用性.</li>
<li>双向绑定,无需编写复杂的操作DOM逻辑.</li>
</ol>
<h2 id="生命周期-10024"><a href="#生命周期-10024" class="headerlink" title="生命周期 &#10024;"></a>生命周期 &#10024;</h2><ol>
<li>beforeCreate:调用组件init方法时候调用,此时无法访问初始化数据,创建页面watcher,计算属性等等.</li>
<li>created:响应式数据,计算属性,监听器等初始化完成,但还未进入渲染阶段.</li>
<li>beforeMount:模板编译,将模板转换为AST语法树,代码拼接成渲染函数,执行渲染函数生成虚拟DOM,diff对比后生成真实DOM.但未挂载到容器上.</li>
<li>mounted:将生成的html挂载到容器上.</li>
<li>beforeUpdate:响应式数据更新时调用,此时数据进行了更新,但页面还未渲染.</li>
<li>updated:render函数重新执行,页面更新.</li>
<li>beforeUnmount:组件实例销毁前调用,此时还保留了组件所有功能.</li>
<li>unMounted: 组件卸载完后调用,清除定时器 DOM监听器等等.</li>
</ol>
<h2 id="父子组件执行顺序"><a href="#父子组件执行顺序" class="headerlink" title="父子组件执行顺序"></a>父子组件执行顺序</h2><ul>
<li>加载渲染过程:父组件beforeCreate,created,beforeMount,子组件一直到mounted,父组件mounted.</li>
<li>更新过程:父组件beforeUpdate,子组件beforeUpdate,updated,父组件updated.</li>
<li>销毁过程: 父组件beforeUmount,子组件before&#x3D;&gt;unmounted,父组件unmounted.</li>
</ul>
<h2 id="keep-alive生命周期"><a href="#keep-alive生命周期" class="headerlink" title="keep-alive生命周期"></a>keep-alive生命周期</h2><ul>
<li>deactivated,activated</li>
</ul>
<h2 id="组件通信-10024"><a href="#组件通信-10024" class="headerlink" title="组件通信 &#10024;"></a>组件通信 &#10024;</h2><ol>
<li>props,emits.</li>
<li>vuex.pinia</li>
<li>事件总线</li>
<li>provide,inject</li>
<li>ref</li>
<li>$attrs</li>
<li>localStorage,cookie</li>
</ol>
<h2 id="项目中的通信"><a href="#项目中的通信" class="headerlink" title="项目中的通信"></a>项目中的通信</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-number">1</span>. props:defineProps.@update:defineEmits,emits([&#x27;update&#x27;]);<br><span class="hljs-number">2</span>. 全局vuex存储:用户信息及其所在组织架构的基本信息,权限节点,是否为白名单,可以访问<br>的模板.<br><span class="hljs-number">3</span>. 基于vuex的事件总线,Bus类共享了vuex数据,并且支持数据总线实现各个子应用之间通<br>信. 每个子应用都需要选择一个模板,红一政治,色情等等.<br><span class="hljs-number">3.1</span>: 子应用把自己需要初始化的事件绑定到总线,主应用监听到模板变化时候<span class="hljs-string">$e</span>mit子应用初<br>始化事件.<br><span class="hljs-number">3.2</span>: 子应用<span class="hljs-string">$o</span>n绑定解锁事件,解锁按钮在主应用模板,主应用<span class="hljs-string">$e</span>mit触发解锁.<br><br><br><span class="hljs-number">4</span>. provide,inject<br><span class="hljs-number">5</span>. ref<br><span class="hljs-number">6</span>. <span class="hljs-string">$a</span>ttrs<br></code></pre></td></tr></table></figure>
<h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><ol>
<li>箭头函数+import</li>
</ol>
<h2 id="路由hash-history模式"><a href="#路由hash-history模式" class="headerlink" title="路由hash&#x2F;history模式"></a>路由hash&#x2F;history模式</h2><ul>
<li>后端路由</li>
</ul>
<ol>
<li>服务端根据客户端的请求路径找到对应组件,将页面渲染完后返回给客户端.seo优化好,但服务端压力大.</li>
</ol>
<ul>
<li>前端路由<br>js动态改变html.前端路由就是基于SPA实现,对url进行处理,使每一个url对应一个资源,监听url变化执行操作.</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">hash模式:<br><span class="hljs-bullet">1.</span> hash值是#xxx<br><span class="hljs-bullet">2.</span> 只出现在url中,请求时候不会发送给后端.<br><span class="hljs-bullet">3.</span> 监听onhashchange事件加载对应的页面<br><span class="hljs-bullet">4.</span> hash值变化会被浏览器监听下来,实现浏览器前进后退. <br></code></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">history模式:<br><span class="hljs-bullet">1.</span> 没有#.<br><span class="hljs-bullet">2.</span> historyAPI主要分外两个部分:<br>pushstate,repalcestate<br>go,back,forward<br><span class="hljs-bullet">3.</span> 通过监听pushstate和replacestate去加载对应页面.<br></code></pre></td></tr></table></figure>
<h2 id="vue中路由模式"><a href="#vue中路由模式" class="headerlink" title="vue中路由模式"></a>vue中路由模式</h2><ul>
<li><p>createWebHistory创建history模式.</p>
</li>
<li><p>createWebHashHistory创建hash模式.</p>
</li>
</ul>
<h2 id="route-router"><a href="#route-router" class="headerlink" title="$route,$router"></a><code>$route</code>,<code>$router</code></h2><ul>
<li>route是当前路由信息对象,包括path,params,query,</li>
<li>router是路由实例,包括跳转方法,钩子函数.</li>
</ul>
<h1 id="10-10"><a href="#10-10" class="headerlink" title="10.10"></a>10.10</h1><h2 id="路由钩子"><a href="#路由钩子" class="headerlink" title="路由钩子"></a>路由钩子</h2><ol>
<li>全局前置守卫:获取权限节点,判断用户是否有权限进入该页面.进入的页面主应用判断是启动子应用还是主应用,如果是子应用则启动qiankun框架.</li>
<li>组件内守卫:beforeRouteEnter,beforeRouteLeave,beforeRouteUpdate.</li>
<li>路由守卫: beforeEnter,嵌套组件时候可以在父路由匹配规则加上路由守卫,则子路由都会触发.</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css">顺序:<br><span class="hljs-number">1</span>. beforeRouteLeave<br><span class="hljs-number">2</span>. beforeEach<br><span class="hljs-number">3</span>. 重用组件调用beforeRouteUpdate<br><span class="hljs-number">4</span>. 调用路由守卫beforeEnter<br><span class="hljs-number">5</span>. 解析异步路由<br><span class="hljs-number">6</span>. 非重用调用beforeRouteEnter<br><span class="hljs-number">7</span>. 全局解析守卫beforeResolve<br><span class="hljs-number">8</span>. 全局后置守卫<br><span class="hljs-number">9</span>. DOM更新<br><br>// 路由守卫beforeEnter例子<br>const routes = [<br>  &#123;<br>    <span class="hljs-selector-tag">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>,<br>    <span class="hljs-built_in">beforeEnter</span>() &#123;<br>      // ...<br>    &#125;,<br>    children: [<br>      &#123; <span class="hljs-selector-tag">path</span>: <span class="hljs-string">&#x27;list&#x27;</span>, component: UserList &#125;,<br>      &#123; <span class="hljs-selector-tag">path</span>: <span class="hljs-string">&#x27;details&#x27;</span>, component: UserDetails &#125;,<br>    ],<br>  &#125;,<br>]<br></code></pre></td></tr></table></figure>
<h2 id="history-pushstate-和location-href-区别"><a href="#history-pushstate-和location-href-区别" class="headerlink" title="history.pushstate()和location.href &#x3D; 区别?"></a>history.pushstate()和location.href &#x3D; 区别?</h2><ul>
<li>前者静态跳转,不会刷新页面. 后者会刷新页面</li>
</ul>
<h2 id="params传参和query传参区别"><a href="#params传参和query传参区别" class="headerlink" title="params传参和query传参区别?"></a>params传参和query传参区别?</h2><ul>
<li>query参数是在路径后? &amp; &#x3D; 拼接,是查询参数,不是必需的.类似get请求.</li>
<li>params参数是路由一部分,路径要设置为&#x2F;:id&#x2F;:name,必须在路由后添加参数名.类似post请求.</li>
</ul>
<h2 id="vuex和pinia区别-10024"><a href="#vuex和pinia区别-10024" class="headerlink" title="vuex和pinia区别? &#10024;"></a>vuex和pinia区别? &#10024;</h2><ol>
<li>pinia是用 ts编写,类型支持更友好.</li>
<li>去除mutations. state,getters,actions.</li>
<li>vuex树结构,读取数据不方便.都会定义到根模块,覆盖根模块状态.只能创建一个,单例模式. pinia定义多个store,store之间互相引用,扁平化结构.</li>
</ol>
<h2 id="Vue-use"><a href="#Vue-use" class="headerlink" title="Vue.use"></a>Vue.use</h2><ol>
<li>查看这个插件是否安装过,安装过不再引用</li>
<li>调用插件对象的install方法(或者直接传入函数),并传入app实例.</li>
</ol>
<h2 id="pinia基本注意项"><a href="#pinia基本注意项" class="headerlink" title="pinia基本注意项."></a>pinia基本注意项.</h2><ol>
<li>定义的state&#x3D;&gt;reactive,getter&#x3D;&gt;computed,actions&#x3D;&gt;method</li>
<li>如果解构出来会丧失响应式,得用storeToRefs&#x2F;toRefs(用前者,后者会把actions也变成ref).<br><img src="/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.%E7%A7%8B%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image.png" srcset="/img/loading.gif" lazyload alt="alt text"></li>
</ol>
<h2 id="actions和mutations区别"><a href="#actions和mutations区别" class="headerlink" title="actions和mutations区别"></a>actions和mutations区别</h2><ol>
<li>作用:mutation修改状态,action处理业务代码和异步请求,提交到commit.</li>
<li>同异步:mutation同步执行,action是异步执行</li>
</ol>
<h2 id="为什么需要vuex"><a href="#为什么需要vuex" class="headerlink" title="为什么需要vuex"></a>为什么需要vuex</h2><ol>
<li>多层嵌套的组件传参和兄弟组件之间传参不便,将组件的公共状态抽离出来,由统一的store仓库管理.</li>
</ol>
<h2 id="vuex和localStorage区别"><a href="#vuex和localStorage区别" class="headerlink" title="vuex和localStorage区别?"></a>vuex和localStorage区别?</h2><ol>
<li>vuex在内存中,localStorage本地磁盘</li>
<li>SPA组件访问,跨页面访问,响应式,非响应式.</li>
<li>刷新丢失不丢失</li>
</ol>
<h2 id="为什么vuex需要actions-为什么pinia不需要"><a href="#为什么vuex需要actions-为什么pinia不需要" class="headerlink" title="为什么vuex需要actions?为什么pinia不需要?"></a>为什么vuex需要actions?为什么pinia不需要?</h2><ol>
<li>将同步和异步分离,代码结构更清晰,方便追踪状态变化,mutations执行后对应一个新的状态.</li>
<li>更贴合组合式API写法,将同步异步逻辑集中到一起,组件中直接调用状态的方法,代码更简洁规范.</li>
</ol>
<h2 id="vuex严格模式"><a href="#vuex严格模式" class="headerlink" title="vuex严格模式"></a>vuex严格模式</h2><ul>
<li>开启后只能通过mutation修改state.</li>
</ul>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><ol>
<li>ref通信:setup默认对外不暴露,使用defineExpose.</li>
<li>provide,inject: 如果传给子代数据很多,可以provide当前父实例getCurrentInstance,在父实例definExpose.</li>
</ol>
<h2 id="fn-bind-a-bind-b"><a href="#fn-bind-a-bind-b" class="headerlink" title="fn.bind(a).bind(b)"></a>fn.bind(a).bind(b)</h2><ul>
<li>bind只能绑定第一个this,第二个绑定无效.</li>
</ul>
<h1 id="10-11"><a href="#10-11" class="headerlink" title="10.11"></a>10.11</h1><h2 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h2><ol>
<li>简单请求: 浏览器在请求头添加origin字段,表明该请求来自哪个源.服务端如果同意这次请求则在响应头配置对应允许的字段.</li>
<li>非简单请求: 先进行一次预检请求,携带origin,额外的请求方法,额外的请求头.服务端同意请求后,后续请求只需携带origin.</li>
</ol>
<h2 id="单页面和多页面-1"><a href="#单页面和多页面-1" class="headerlink" title="单页面和多页面"></a>单页面和多页面</h2><ol>
<li>请求资源:单页面一次性加载资源,多页面多次加载</li>
<li>路由:单页面应用:history,hash.多页面应用通过路径跳转.</li>
<li>数据传递:单页面vuex.多页面cookie,localStorage,sessionStorage,接口保存.</li>
<li>单页面局部更新,切换速度快.多页面全局更新,切换速度慢.</li>
</ol>
<h2 id="SSR服务端渲染-1"><a href="#SSR服务端渲染-1" class="headerlink" title="SSR服务端渲染?"></a>SSR服务端渲染?</h2><ul>
<li>优点:</li>
</ul>
<ol>
<li>更快的首屏加载速度.服务端根据请求路径获取到对应组件,服务端组件请求数据,将组件渲染为html.将html和vue文件作为响应内容返回给客户端.客户端渲染页面,并加载vue文件,将页面变为动态页面.</li>
<li>更好支持SEO,搜索引擎爬虫可以获取到完全渲染的页面.</li>
</ol>
<ul>
<li>缺点:</li>
</ul>
<ol>
<li>只支持beforeCreate钩子和created钩子.</li>
<li>增大服务端压力.</li>
</ol>
<h2 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h2><ol>
<li>全局在Vue构造函数上</li>
<li>生命周期,响应式数据</li>
<li>可插拔可复用,优先原来组件</li>
</ol>
<h2 id="优雅降级和渐进增强"><a href="#优雅降级和渐进增强" class="headerlink" title="优雅降级和渐进增强"></a>优雅降级和渐进增强</h2><ul>
<li>渐进增强:针对低版本浏览器构建页面,针对高版本浏览器加强功能改进和更好的用户体验.</li>
<li>优雅降级:一开始完善功能和用户体验,针对低版本浏览器做兼容.</li>
</ul>
<h2 id="actions和mutations区别-1"><a href="#actions和mutations区别-1" class="headerlink" title="actions和mutations区别"></a>actions和mutations区别</h2><ol>
<li>作用:mutation修改状态,action处理业务代码和异步请求,提交到commit.</li>
<li>同异步:mutation同步执行,action是异步执行</li>
</ol>
<h2 id="为什么vuex需要actions-为什么pinia不需要-1"><a href="#为什么vuex需要actions-为什么pinia不需要-1" class="headerlink" title="为什么vuex需要actions?为什么pinia不需要?"></a>为什么vuex需要actions?为什么pinia不需要?</h2><ol>
<li>将同步和异步分离,代码结构更清晰,方便追踪状态变化,mutations执行后对应一个新的状态.</li>
<li>更贴合组合式API写法,将同步异步逻辑集中到一起,组件中直接调用状态的方法,代码更简洁规范.</li>
</ol>
<h1 id="10-12"><a href="#10-12" class="headerlink" title="10.12"></a>10.12</h1><h2 id="k个一组翻转"><a href="#k个一组翻转" class="headerlink" title="k个一组翻转"></a>k个一组翻转</h2><h2 id="链表翻转"><a href="#链表翻转" class="headerlink" title="链表翻转"></a>链表翻转</h2><h2 id="随机链表的复制-没搞出来"><a href="#随机链表的复制-没搞出来" class="headerlink" title="随机链表的复制(没搞出来)"></a>随机链表的复制(没搞出来)</h2><h2 id="小米笔试"><a href="#小米笔试" class="headerlink" title="小米笔试"></a>小米笔试</h2><h2 id="美团笔试"><a href="#美团笔试" class="headerlink" title="美团笔试"></a>美团笔试</h2><h1 id="10-13"><a href="#10-13" class="headerlink" title="10.13"></a>10.13</h1><h2 id="oauth2"><a href="#oauth2" class="headerlink" title="oauth2"></a>oauth2</h2><h2 id="随机链表复制"><a href="#随机链表复制" class="headerlink" title="随机链表复制"></a>随机链表复制</h2><h2 id="合并k个升序数组"><a href="#合并k个升序数组" class="headerlink" title="合并k个升序数组"></a>合并k个升序数组</h2><h2 id="环形链表1-2"><a href="#环形链表1-2" class="headerlink" title="环形链表1,2"></a>环形链表1,2</h2><h1 id="10-14"><a href="#10-14" class="headerlink" title="10.14"></a>10.14</h1><ul>
<li>上午:看完登录,直传oss. 下午:webworker</li>
</ul>
<h2 id="浏览器六大对象"><a href="#浏览器六大对象" class="headerlink" title="浏览器六大对象"></a>浏览器六大对象</h2><ul>
<li>window窗口 history历史记录 screen屏幕 navigator浏览器相关信息 location地址栏<br>document当前页面文档</li>
</ul>
<h2 id="auth2授权登录全过程"><a href="#auth2授权登录全过程" class="headerlink" title="auth2授权登录全过程"></a>auth2授权登录全过程</h2><h2 id="单点登录全过程"><a href="#单点登录全过程" class="headerlink" title="单点登录全过程"></a>单点登录全过程</h2><ol>
<li>同父域名: 公司的单点登录</li>
<li>非同父域名:<blockquote>
<p>两者后端拿到code,token都会去企业微信API,认证中心验证合理性和时效性.</p>
</blockquote>
</li>
</ol>
<h2 id="oss直传"><a href="#oss直传" class="headerlink" title="oss直传"></a>oss直传</h2><h2 id="无感刷新"><a href="#无感刷新" class="headerlink" title="无感刷新"></a>无感刷新</h2><ol>
<li>双token</li>
<li>token续期</li>
</ol>
<h2 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h2><ul>
<li>描述文件类型: 文本,图片,视频,音频.</li>
</ul>
<h2 id="文件相关对象-10024"><a href="#文件相关对象-10024" class="headerlink" title="文件相关对象 &#10024;"></a>文件相关对象 &#10024;</h2><ol>
<li>blob，二进制大对象，类文件对象，不可修改。</li>
<li>fileReader：读取blob对象。</li>
<li>file：blob对象的特殊类型。通过input选择。</li>
<li>ArrayBuffer：二进制数据的缓冲区，字节数组。</li>
<li>TypedArray：读取ArrayBuffer。</li>
</ol>
<h2 id="xlsx和csv"><a href="#xlsx和csv" class="headerlink" title="xlsx和csv"></a>xlsx和csv</h2><ul>
<li>都是存储表格数据的文件格式</li>
<li>csv纯文本，体积更小，支持所有文本编辑器，但不支持密码保护。前端csv就是逗号拼接起来的数据。</li>
<li>xlsx是excel专有格式，适合复杂数据管理。</li>
</ul>
<h2 id="webworker基本知识"><a href="#webworker基本知识" class="headerlink" title="webworker基本知识"></a>webworker基本知识</h2><h1 id="10-15"><a href="#10-15" class="headerlink" title="10.15"></a>10.15</h1><h2 id="webWorker结合项目"><a href="#webWorker结合项目" class="headerlink" title="webWorker结合项目"></a>webWorker结合项目</h2><h2 id="sharedWorker"><a href="#sharedWorker" class="headerlink" title="sharedWorker"></a>sharedWorker</h2><h2 id="css八股"><a href="#css八股" class="headerlink" title="css八股"></a>css八股</h2><h1 id="10-16"><a href="#10-16" class="headerlink" title="10.16"></a>10.16</h1><h2 id="css八股复习完"><a href="#css八股复习完" class="headerlink" title="css八股复习完"></a>css八股复习完</h2><ul>
<li>基础，浮动，定位，flex，两栏布局三栏布局垂直居中。</li>
</ul>
<h2 id="flex：1"><a href="#flex：1" class="headerlink" title="flex：1"></a>flex：1</h2><ol>
<li>flex是flex-grow，flex-shrink，flex-basis简写。</li>
<li>flex：1 &#x3D;&gt; flex:1,1,0%.表示子元素等比放大缩小。</li>
</ol>
<h1 id="10-17"><a href="#10-17" class="headerlink" title="10.17"></a>10.17</h1><h2 id="虚拟列表"><a href="#虚拟列表" class="headerlink" title="虚拟列表"></a>虚拟列表</h2><ul>
<li>有三个div元素，一个div里包了两个div，外层div开启相对定位，里层一个div开启绝对定位，设置z-index为-1，高度为整个大列表实际高度，解决滚动条无法拖到底和滚动条长度变化的问题。另一个子div负责展示列表。</li>
<li>监听外层div的滚动事件，滚动过的高度&#x2F;每一个元素高度，再加上渲染的个数从大列表中进行截取。通过transform：translate对里层子div进行偏移。transform会单独抽离出一个合成层，不会触发回流重绘，可以利用GPU加速渲染。</li>
</ul>
<h2 id="晚上抽离公共组件工具方法以及样式类，并通过子模块仓库引入，提高开发效率"><a href="#晚上抽离公共组件工具方法以及样式类，并通过子模块仓库引入，提高开发效率" class="headerlink" title="晚上抽离公共组件工具方法以及样式类，并通过子模块仓库引入，提高开发效率"></a>晚上抽离公共组件工具方法以及样式类，并通过子模块仓库引入，提高开发效率</h2><h1 id="10-18"><a href="#10-18" class="headerlink" title="10.18"></a>10.18</h1><h2 id="手写发布订阅"><a href="#手写发布订阅" class="headerlink" title="手写发布订阅"></a>手写发布订阅</h2><h2 id="实现自定义角色权限，为不同管理权限设置不同路由，并完成按钮级别权限控制"><a href="#实现自定义角色权限，为不同管理权限设置不同路由，并完成按钮级别权限控制" class="headerlink" title="实现自定义角色权限，为不同管理权限设置不同路由，并完成按钮级别权限控制"></a>实现自定义角色权限，为不同管理权限设置不同路由，并完成按钮级别权限控制</h2><ul>
<li>在子模块仓库封装了getCurModuleAuth获取当前模块权限的函数，iauth是一个权限申请平台，各个系统权限节点可以在上面申请，因此可以实现自定义角色权限；配置中心获取基本配置信息，白名单用户，权限节点&#x3D;&gt;权限的映射。从七彩石配置中心拉取权限节点&#x3D;&gt;权限的映射，从iauth平台拉取当前用户所有的权限。再传入当前模块字符串，返回权限数组比如[增加策略，删除策略，修改策略，发布策略].按钮级权限控制：按钮disabled时候判断权限数组是否包含按钮操作的节点。</li>
<li>子模块仓库封装了injectAuthId注入路由权限id函数，在全局路由前置守卫调用。七彩石配置中心获取权限节点&#x3D;&gt;权限映射，iauth获取权限数组。路由配置时候不同页面配置对应的权限信息。权限&#x3D;&gt;权限id，查看用户是否有当前id的权限，有的话在路由的meta元信息注入字段&#x2F;白名单用户也会注入该字段，根据是否有该字段来判断是给用户放行&#x2F;还是跳转到403统一无权限页面。</li>
</ul>
<h2 id="vuex和pinia区别-10024-1"><a href="#vuex和pinia区别-10024-1" class="headerlink" title="vuex和pinia区别? &#10024;"></a>vuex和pinia区别? &#10024;</h2><ol>
<li>pinia是用 ts编写,类型支持更友好.</li>
<li>去除mutations. state,getters,actions.</li>
<li>vuex树结构,读取数据不方便.都会定义到根模块,覆盖根模块状态.只能创建一个,单例模式. pinia定义多个store,store之间互相引用,扁平化结构.</li>
</ol>
<h2 id="作为子应用接入微前端框架，通过暴露生命周期钩子和基于pinia的事件注册和分发来实现与主应用的数据共享"><a href="#作为子应用接入微前端框架，通过暴露生命周期钩子和基于pinia的事件注册和分发来实现与主应用的数据共享" class="headerlink" title="作为子应用接入微前端框架，通过暴露生命周期钩子和基于pinia的事件注册和分发来实现与主应用的数据共享"></a>作为子应用接入微前端框架，通过暴露生命周期钩子和基于pinia的事件注册和分发来实现与主应用的数据共享</h2><h2 id><a href="#" class="headerlink" title=".*"></a>.*</h2><ul>
<li>匹配任意长度的字符串</li>
</ul>
<h2 id="动态路由参数"><a href="#动态路由参数" class="headerlink" title="动态路由参数"></a>动态路由参数</h2><ol>
<li>：pathName：user&#x2F;:id &#x3D;&gt; user&#x2F;1 ,user&#x2F;2</li>
</ol>
<h2 id="POWERED-BY-QIANKUN"><a href="#POWERED-BY-QIANKUN" class="headerlink" title="POWERED_BY_QIANKUN"></a>POWERED_BY_QIANKUN</h2><p>window.<del><strong>POWERED_BY_QIANKUN</strong></del>：这是一个标识，用于判断当前应用是否在 qiankun 的环境中运行。如果为 true，说明当前是子应用。</p>
<h2 id="process-env"><a href="#process-env" class="headerlink" title="process.env"></a>process.env</h2><ul>
<li>是Node.js 中的一个<em><strong>全局变量</strong></em>，包含当前环境（开发环境，线上环境）信息。可在vue项目中全局访问，使代码在不同环境使用不同配置，不需要修改源代码。</li>
</ul>
<!-- vue开启本地服务器先启动node环境运行js，对模板编译生成渲染函数，将vue文件=> 浏览器可识别的js，html，css文件执行 -->
<h1 id="10-19"><a href="#10-19" class="headerlink" title="10.19"></a>10.19</h1><h2 id="复习权限控制"><a href="#复习权限控制" class="headerlink" title="复习权限控制"></a>复习权限控制</h2><h2 id="qiankun和iframe区别"><a href="#qiankun和iframe区别" class="headerlink" title="qiankun和iframe区别"></a>qiankun和iframe区别</h2><ol>
<li>实现方式</li>
<li>数据通信</li>
<li>加载性能</li>
<li>使用场景</li>
</ol>
<h2 id="微前端解决了什么问题"><a href="#微前端解决了什么问题" class="headerlink" title="微前端解决了什么问题"></a>微前端解决了什么问题</h2><ol>
<li>可维护性</li>
<li>团队独立性</li>
<li>技术灵活性</li>
<li>增量升级</li>
</ol>
<h2 id="子应用如何接入qiankun框架？"><a href="#子应用如何接入qiankun框架？" class="headerlink" title="子应用如何接入qiankun框架？"></a>子应用如何接入qiankun框架？</h2><ol>
<li>在加载主应用入口文件时候注册子应用，当url变化时候自动触发qiankun的匹配逻辑。</li>
<li>主应用路由全局前置守卫判断：403，404，主应用页面，子应用（挂载到一个空壳路由也页面）。子应用的话start启动qiankun框架。</li>
<li>切换到子应用挂载的路由，id为container，子应用配置container字段为#container。</li>
<li>子应用启动时候调用mount生命周期钩子，卸载时候调用unmount生命周期钩子。bootstrap首次初始化加载，设置全局状态的缓存，不会在unmount卸载；mount里挂载子组件，unmount里卸载子组件。</li>
</ol>
<h2 id="父子应用通信"><a href="#父子应用通信" class="headerlink" title="父子应用通信"></a>父子应用通信</h2><h2 id="组件通信-1"><a href="#组件通信-1" class="headerlink" title="组件通信"></a>组件通信</h2><ol>
<li>ref通信:setup默认对外不暴露,使用defineExpose.</li>
<li>provide,inject: 如果传给子代数据很多,可以provide当前父实例getCurrentInstance,在父实例definExpose.</li>
</ol>
<h2 id="fn-bind-a-bind-b-1"><a href="#fn-bind-a-bind-b-1" class="headerlink" title="fn.bind(a).bind(b)"></a>fn.bind(a).bind(b)</h2><ul>
<li>bind只能绑定第一个this,第二个绑定无效.</li>
</ul>
<h2 id="京东笔试"><a href="#京东笔试" class="headerlink" title="京东笔试"></a>京东笔试</h2><h1 id="10-20"><a href="#10-20" class="headerlink" title="10.20"></a>10.20</h1><h2 id="js沙箱机制"><a href="#js沙箱机制" class="headerlink" title="js沙箱机制"></a>js沙箱机制</h2><h2 id="css样式隔离"><a href="#css样式隔离" class="headerlink" title="css样式隔离"></a>css样式隔离</h2><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><ul>
<li>三道题（两数之和，字母异位词分组，最长连续序列）</li>
</ul>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ul>
<li>四道题：接雨水（动态规划或双指针）</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li>两道题</li>
</ul>
<ol>
<li>相加链表：hash，双指针</li>
<li>反转链表</li>
</ol>
<!-- ## get请求没问题,post请求失败? -->
<h1 id="10-21"><a href="#10-21" class="headerlink" title="10.21"></a>10.21</h1><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/</a></li>
</ul>
<h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><ul>
<li>十五道题</li>
</ul>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><ul>
<li>理论基础</li>
<li>五道题</li>
</ul>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul>
<li>满二叉树：除叶子节点外的节点都有两个子节点。</li>
<li>完全二叉树：叶子节点一定是从左到右的，中间不能断。</li>
<li>二叉搜索树：搜索复杂度是logn，</li>
</ul>
<h1 id="10-22"><a href="#10-22" class="headerlink" title="10.22"></a>10.22</h1><h2 id="链表思路"><a href="#链表思路" class="headerlink" title="链表思路"></a>链表思路</h2><ul>
<li>快慢指针 slow &#x3D; fast &#x3D; head;</li>
<li>创建hair指针 res &#x3D; hair &#x3D; new ListNode(0,head); return res.next;</li>
</ul>
<h2 id="按值传递-按引用传递"><a href="#按值传递-按引用传递" class="headerlink" title="按值传递,按引用传递"></a>按值传递,按引用传递</h2><ul>
<li>js是按值传递,复制一份.</li>
</ul>
<ol>
<li>按值传递&#x3D;&#x3D;&#x3D;&gt;复制一份,按引用传递&#x3D;&#x3D;&#x3D;&gt;变量的内存被赋给另一个局部变量,局部变量的修改会影响原变量.</li>
</ol>
<h2 id="回溯-1"><a href="#回溯-1" class="headerlink" title="回溯"></a>回溯</h2><p>backTracking<br>if（）{return} for path.push() backTracking() path.pop()</p>
<h2 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h2><ul>
<li>前中后序遍历</li>
<li>层序遍历</li>
</ul>
<h2 id="前端攻击"><a href="#前端攻击" class="headerlink" title="前端攻击"></a>前端攻击</h2><ul>
<li>xss攻击，csrf攻击。</li>
</ul>
<h2 id="浏览器渲染进程有哪些线程？"><a href="#浏览器渲染进程有哪些线程？" class="headerlink" title="浏览器渲染进程有哪些线程？"></a>浏览器渲染进程有哪些线程？</h2><ul>
<li>js引擎线程，渲染线程，定时器相关的线程，事件循环相关的线程。</li>
</ul>
<h2 id="强制缓存，协商缓存"><a href="#强制缓存，协商缓存" class="headerlink" title="强制缓存，协商缓存"></a>强制缓存，协商缓存</h2><ul>
<li>强制缓存：expires，cache-control</li>
<li>协商缓存：if-modified-since，if-none-match。</li>
</ul>
<h2 id="f5刷新，ctrl-f5刷新，地址栏输入"><a href="#f5刷新，ctrl-f5刷新，地址栏输入" class="headerlink" title="f5刷新，ctrl+f5刷新，地址栏输入"></a>f5刷新，ctrl+f5刷新，地址栏输入</h2><ul>
<li>1：强制缓存失效，2：都失效。3：都有效。</li>
</ul>
<h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><ol>
<li>解析html文档,生成DOM树,由html元素和属性节点组成.</li>
<li>解析css,生成css树.</li>
<li>根据DOM树和CSS树构建渲染树</li>
<li>布局(回流):渲染树进行布局计算每个渲染节点的位置和大小.</li>
<li>绘制(重绘):将渲染树的节点绘制到页面上.</li>
<li>复合: 浏览器的绘制是绘制到多层,每一层单独渲染,最后合成到一起形成页面.</li>
<li>重绘:重绘不会带来重新布局,一般是修改背景颜色,边框阴影等属性.</li>
<li>回流:消耗性能,改变元素位置,DOM结构发生变化.</li>
</ol>
<h2 id="减少回流，重绘"><a href="#减少回流，重绘" class="headerlink" title="减少回流，重绘"></a>减少回流，重绘</h2><ol>
<li>浏览器队列机制。</li>
<li>脱离文档流</li>
<li>操作低层次dom</li>
<li>translate，opcity单独抽离出合成层，利用gpu加速渲染。</li>
</ol>
<h2 id="浏览器渲染优化-2"><a href="#浏览器渲染优化-2" class="headerlink" title="浏览器渲染优化"></a>浏览器渲染优化</h2><ol>
<li>js用async，defer。</li>
<li>css用link，@import。</li>
<li>减少回流重绘。</li>
</ol>
<h2 id="cookie，localStorage，sessionStorage"><a href="#cookie，localStorage，sessionStorage" class="headerlink" title="cookie，localStorage，sessionStorage"></a>cookie，localStorage，sessionStorage</h2><ol>
<li>cookie：请求携带发送，内存小，服务端可以设置客户端不准读取。</li>
<li>localStorage：请求不会携带，内存大，不删除的话一直存在。</li>
<li>sessionStroage：请求不会携带，内存大，退出页面则删除。</li>
</ol>
<h2 id="浏览器的本地存储-1"><a href="#浏览器的本地存储-1" class="headerlink" title="浏览器的本地存储"></a>浏览器的本地存储</h2><h3 id="cookie-1"><a href="#cookie-1" class="headerlink" title="cookie"></a>cookie</h3><ol>
<li>大小限制4kb,不能跨域.</li>
<li>主要和seesion配合,存储sessionid,发送请求时候可以携带cookie,服务器识别sessionid来识别身份.</li>
</ol>
<h3 id="localStorage-1"><a href="#localStorage-1" class="headerlink" title="localStorage"></a>localStorage</h3><ol>
<li>大小5MB,存储在本地,请求不会携带.</li>
<li>除非主动删除,否则不会消失.</li>
<li>同源多个标签可以共享数据.</li>
</ol>
<h3 id="sessionStorage-1"><a href="#sessionStorage-1" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><ol>
<li>同.</li>
<li>关闭窗口后会消失</li>
<li>同源多个标签不可以共享数据.</li>
</ol>
<h2 id="cookie字段-1"><a href="#cookie字段-1" class="headerlink" title="cookie字段"></a>cookie字段</h2><ol>
<li>domain:可以访问该cookie的域名</li>
<li>path:域名下的哪些路径可以访问该cookie</li>
<li>Expires:cookie过期时间,注意这个是cookie的expires!和缓存的不一样,缓存的是在请求头中!</li>
<li>name,value,size.</li>
</ol>
<ul>
<li>服务端在响应头可以用set-cookie来配置cookie信息.http-only限制cookie不能被js脚本读取.也有domain,path,expires.<br>(不要把缓存的六个字段和cookie的搞混了,缓存的是在请求头和响应头中)</li>
</ul>
<h2 id="indexDB-1"><a href="#indexDB-1" class="headerlink" title="indexDB"></a>indexDB</h2><ul>
<li>内存更大，异步，事务。</li>
</ul>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ol>
<li>CORS</li>
<li>jsonp</li>
<li>postmessage</li>
<li>开发中：代理服务器。</li>
</ol>
<h2 id="事件模型-2"><a href="#事件模型-2" class="headerlink" title="事件模型"></a>事件模型</h2><ol>
<li>DOM0：没有事件流。</li>
<li>IE：事件触发，事件冒泡</li>
<li>DOM2：事件捕获，事件触发，事件冒泡。</li>
</ol>
<h2 id="事件委托-1"><a href="#事件委托-1" class="headerlink" title="事件委托"></a>事件委托</h2><ol>
<li>利用事件冒泡机制</li>
<li>动态添加事件，减少内存消耗。</li>
</ol>
<h2 id="美团面试"><a href="#美团面试" class="headerlink" title="美团面试"></a>美团面试</h2><h1 id="10-23"><a href="#10-23" class="headerlink" title="10.23"></a>10.23</h1><h2 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h2><ul>
<li>浏览器主进程，渲染进程，插件进程，GUI进程</li>
</ul>
<h2 id="浏览器并发机制"><a href="#浏览器并发机制" class="headerlink" title="浏览器并发机制."></a>浏览器并发机制.</h2><ol>
<li>避免线程频繁切换</li>
<li>良性机制</li>
<li>避免占据服务端过多资源</li>
<li>端口号限制</li>
</ol>
<h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><p>200 204 206<br>301 302 304<br>400 404 403<br>500</p>
<h2 id="get，post请求区别"><a href="#get，post请求区别" class="headerlink" title="get，post请求区别"></a>get，post请求区别</h2><ol>
<li>获取，修改数据</li>
<li>请求体</li>
<li>幂等安全</li>
<li>get可以强制缓存，协商缓存</li>
</ol>
<h2 id="http1-1和1-0区别"><a href="#http1-1和1-0区别" class="headerlink" title="http1.1和1.0区别"></a>http1.1和1.0区别</h2><ol>
<li>强制缓存协商缓存字段</li>
<li>部分请求</li>
<li>增加的请求状态码</li>
<li>长连接</li>
<li>host</li>
</ol>
<h2 id="http和https区别"><a href="#http和https区别" class="headerlink" title="http和https区别"></a>http和https区别</h2><ol>
<li>加密通信：明文传输，加密传输 &#x3D;&gt; 非对称加密，对称加密结合</li>
<li>防止请求被篡改 &#x3D;&gt; 摘要算法+私钥签名</li>
<li>身份认证 &#x3D;&gt; 数字证书</li>
</ol>
<h2 id="TLS握手-1"><a href="#TLS握手-1" class="headerlink" title="TLS握手"></a>TLS握手</h2><ol>
<li>支持的tls版本号，支持的密码套件，随机数</li>
<li>选择版本号，密码套件，随机数，数字证书</li>
<li>验证数字证书，获取公钥，生成第三个随机数 &#x3D;&gt; 生成会话密钥，通知后续采用加密发送。</li>
<li>私钥解密获取第三个随机数，生成会话密钥，通知后续采用加密发送。</li>
</ol>
<h2 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h2><ol>
<li>主动推送</li>
<li>头部压缩</li>
<li>二进制流</li>
<li>一个tcp连接下有多个stream流，每个stream流对应一个请求和响应，</li>
</ol>
<h2 id="http3-0-1"><a href="#http3-0-1" class="headerlink" title="http3.0"></a>http3.0</h2><ul>
<li>udp，quic协议</li>
</ul>
<ol>
<li>扩充了静态表，动态表维护。</li>
<li>更快建立连接，quic协议握手和tls1.3握手一同发送，一次RTT完成连接。</li>
<li>更快的恢复连接建立</li>
<li>无队头阻塞</li>
</ol>
<h2 id="如何解决沾包问题-1"><a href="#如何解决沾包问题-1" class="headerlink" title="如何解决沾包问题?"></a>如何解决沾包问题?</h2><ol>
<li>固定长度的消息.</li>
<li>http头部设置回车,换行两个为消息边界.</li>
</ol>
<h2 id="为什么可以三次挥手-1"><a href="#为什么可以三次挥手-1" class="headerlink" title="为什么可以三次挥手?"></a>为什么可以三次挥手?</h2><ul>
<li>需要四次原因是因为还有数据要发送,数据发送完再调用关闭函数进入LAST-ACK状态.</li>
</ul>
<ol>
<li><em><strong>没有数据发送</strong></em>且<em><strong>开启了TCP延迟确认机制</strong></em>,那么第二次和第三次挥手就回合并,三次挥手.</li>
<li>TCP延迟确认机制是优化单独发ACK数据效率低,延迟等待一段时间,如果有数据发送则和ACK一起发送,提高效率.</li>
</ol>
<h2 id="setTimeout-允许我们将函数推迟到一段时间间隔之后再执行。"><a href="#setTimeout-允许我们将函数推迟到一段时间间隔之后再执行。" class="headerlink" title="setTimeout 允许我们将函数推迟到一段时间间隔之后再执行。"></a>setTimeout 允许我们将函数推迟到一段时间间隔之后再执行。</h2><p>setInterval 允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。</p>
<h1 id="10-24"><a href="#10-24" class="headerlink" title="10.24"></a>10.24</h1><h2 id="爬楼梯-1"><a href="#爬楼梯-1" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><h2 id="杨辉三角-1"><a href="#杨辉三角-1" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2><h2 id="不同路径-1"><a href="#不同路径-1" class="headerlink" title="不同路径"></a>不同路径</h2><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><h2 id="10-25"><a href="#10-25" class="headerlink" title="10.25"></a>10.25</h2><h3 id="微前端父子应用路由"><a href="#微前端父子应用路由" class="headerlink" title="微前端父子应用路由"></a>微前端父子应用路由</h3><h3 id="微前端如何加载多个子应用"><a href="#微前端如何加载多个子应用" class="headerlink" title="微前端如何加载多个子应用"></a>微前端如何加载多个子应用</h3><h3 id="京东面试"><a href="#京东面试" class="headerlink" title="京东面试"></a>京东面试</h3><h2 id="10-26"><a href="#10-26" class="headerlink" title="10.26"></a>10.26</h2><h3 id="01背包问题滚动数组"><a href="#01背包问题滚动数组" class="headerlink" title="01背包问题滚动数组"></a>01背包问题滚动数组</h3><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><h3 id="最后一块石头的重量"><a href="#最后一块石头的重量" class="headerlink" title="最后一块石头的重量"></a>最后一块石头的重量</h3><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h3><h2 id="10-27"><a href="#10-27" class="headerlink" title="10.27"></a>10.27</h2><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h3><h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h3><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h3><h3 id="loader和plugin区别-10024"><a href="#loader和plugin区别-10024" class="headerlink" title="loader和plugin区别&#10024;"></a>loader和plugin区别&#10024;</h3><h3 id="webpack构建流程-10024"><a href="#webpack构建流程-10024" class="headerlink" title="webpack构建流程&#10024;"></a>webpack构建流程&#10024;</h3><h3 id="如何提高构建速度-10024"><a href="#如何提高构建速度-10024" class="headerlink" title="如何提高构建速度&#10024;"></a>如何提高构建速度&#10024;</h3><h3 id="vite和webpack区别-10024"><a href="#vite和webpack区别-10024" class="headerlink" title="vite和webpack区别&#10024;"></a>vite和webpack区别&#10024;</h3><h3 id="webpack热模块更新-10024"><a href="#webpack热模块更新-10024" class="headerlink" title="webpack热模块更新 &#10024;"></a>webpack热模块更新 &#10024;</h3><h1 id="10-28"><a href="#10-28" class="headerlink" title="10.28"></a>10.28</h1><!-- - 我感觉我每天都处在崩溃边缘和状态好的边缘，找寻着未知的答案。 -->
<h2 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a>寻找重复数</h2><h2 id="多数元素摩尔投票法：找数组中的众数"><a href="#多数元素摩尔投票法：找数组中的众数" class="headerlink" title="多数元素摩尔投票法：找数组中的众数"></a>多数元素摩尔投票法：找数组中的众数</h2><ul>
<li>消除不同元素之间的对抗来找到可能的多数元素。</li>
</ul>
<h2 id="UDP和TCP区别-1"><a href="#UDP和TCP区别-1" class="headerlink" title="UDP和TCP区别"></a>UDP和TCP区别</h2><ul>
<li>可靠 连接 服务 控制 传输</li>
</ul>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h2 id="流量控制，拥塞控制"><a href="#流量控制，拥塞控制" class="headerlink" title="流量控制，拥塞控制"></a>流量控制，拥塞控制</h2><h2 id="冯诺依曼体系结构-10024"><a href="#冯诺依曼体系结构-10024" class="headerlink" title="冯诺依曼体系结构 &#10024;"></a>冯诺依曼体系结构 &#10024;</h2><ol>
<li>以<em><strong>运算器</strong></em>为中心。现代计算机以<em><strong>存储器</strong></em>为中心。</li>
<li>五种结构：运算器，控制器，存储器，输入设备，输出设备。</li>
</ol>
<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><ul>
<li>由地址寄存器（MAR），数据寄存器（MDR），存储体组成。</li>
<li>分为内存和外存，cpu处理数据只能处理内存，外存的数据被处理要先放到内存中。</li>
</ul>
<!-- 读取：读取的地址放到地址寄存器，存储体找到后放到数据寄存器，然后CPU读取。
     写入：写入的地址放到地址寄存器，写入的数据放到数据寄存器，然后写入到存储体。
 -->

<h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><ul>
<li>进行算术运算和逻辑运算，核心是通过ALU算术逻辑单元进行运算。</li>
</ul>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><ul>
<li>取指令、翻译指令、分析指令，然后向有关部件发送命令，协调指挥整个计算机操作。控制器和运算器共同共同组成CPU。</li>
</ul>
<h3 id="输入设备，输出设备"><a href="#输入设备，输出设备" class="headerlink" title="输入设备，输出设备"></a>输入设备，输出设备</h3><ul>
<li>入：键盘，鼠标。</li>
<li>出：显示屏，打印机。</li>
</ul>
<h2 id="不同地点访问同一个url区别-9997"><a href="#不同地点访问同一个url区别-9997" class="headerlink" title="不同地点访问同一个url区别 &#9997;"></a>不同地点访问同一个url区别 &#9997;</h2><ol>
<li>缓存</li>
<li>ip地址不同，路由器转发，交换机转发经过的网络路径不同。</li>
<li>网速不同，获取资源速度不同。</li>
</ol>
<h2 id="KMP算法基础"><a href="#KMP算法基础" class="headerlink" title="KMP算法基础"></a>KMP算法基础</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1PD4y1o7nd/?spm_id_from=333.337.search-card.all.click&vd_source=9b9c9c2844427b792423aada902b836b">https://www.bilibili.com/video/BV1PD4y1o7nd/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9b9c9c2844427b792423aada902b836b</a></li>
</ul>
<h2 id="tcp三次握手，两次握手，四次握手"><a href="#tcp三次握手，两次握手，四次握手" class="headerlink" title="tcp三次握手，两次握手，四次握手"></a>tcp三次握手，两次握手，四次握手</h2><h1 id="10-29"><a href="#10-29" class="headerlink" title="10.29"></a>10.29</h1><!-- 我的灵魂失语了，只剩下疲软的病态。 -->
<h2 id="tcp为什么初始化序列号不同？"><a href="#tcp为什么初始化序列号不同？" class="headerlink" title="tcp为什么初始化序列号不同？"></a>tcp为什么初始化序列号不同？</h2><h2 id="第一二三次握手丢失发生什么"><a href="#第一二三次握手丢失发生什么" class="headerlink" title="第一二三次握手丢失发生什么"></a>第一二三次握手丢失发生什么</h2><h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><h2 id="tcp四次挥手流程"><a href="#tcp四次挥手流程" class="headerlink" title="tcp四次挥手流程"></a>tcp四次挥手流程</h2><h2 id="tcp可以三次挥手的原因"><a href="#tcp可以三次挥手的原因" class="headerlink" title="tcp可以三次挥手的原因"></a>tcp可以三次挥手的原因</h2><h2 id="第一二三四次挥手丢失发生什么"><a href="#第一二三四次挥手丢失发生什么" class="headerlink" title="第一二三四次挥手丢失发生什么"></a>第一二三四次挥手丢失发生什么</h2><h2 id="等待时间是2MSL原因"><a href="#等待时间是2MSL原因" class="headerlink" title="等待时间是2MSL原因"></a>等待时间是2MSL原因</h2><h2 id="time-wait的意义"><a href="#time-wait的意义" class="headerlink" title="time-wait的意义"></a>time-wait的意义</h2><h2 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h2><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h2 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h2><h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><h2 id="手写发布订阅-1"><a href="#手写发布订阅-1" class="headerlink" title="手写发布订阅"></a>手写发布订阅</h2><h1 id="10-30"><a href="#10-30" class="headerlink" title="10.30"></a>10.30</h1><!-- 寻找内心的平静 -->
<h2 id="git-如何解决冲突-10024"><a href="#git-如何解决冲突-10024" class="headerlink" title="git 如何解决冲突&#10024;"></a>git 如何解决冲突&#10024;</h2><h2 id="git-rebase和git-merge区别-10024"><a href="#git-rebase和git-merge区别-10024" class="headerlink" title="git rebase和git merge区别 &#10024;"></a>git rebase和git merge区别 &#10024;</h2><h2 id="减少回流和重绘操作-10024"><a href="#减少回流和重绘操作-10024" class="headerlink" title="减少回流和重绘操作 &#10024;"></a>减少回流和重绘操作 &#10024;</h2><ol>
<li>操作低层次的DOM.</li>
<li>脱离文档流,减少对其他元素影响.</li>
<li>将DOM读写操作分别放到一起,浏览器的渲染队列机制.</li>
<li>一些css属性形成新的合成层: transform,opacity等等.浏览器把这些变化交给GPU处理(不是所有合成层都给GPU,只有动画视觉效果时候交给GPU),GPU直接在显存中更改元素显示位置,无需CPU进行布局绘制的计算.</li>
<li>不要使用table布局，一个小的改动可能导致整个table重新布局。</li>
</ol>
<h2 id="table布局"><a href="#table布局" class="headerlink" title="table布局"></a>table布局</h2><ul>
<li>父元素：display：table。子元素：display：table-cell。</li>
</ul>
<h2 id="set和map原理-10024"><a href="#set和map原理-10024" class="headerlink" title="set和map原理 &#10024;"></a>set和map原理 &#10024;</h2><ul>
<li>七个数据类型 + object经过hash值处理运算，对应到0-7八个数字；有个长为8的数组，数组每个元素对应一个数据类型，数组每个元素是链表结构存储相同数据类型的不同值。</li>
</ul>
<h2 id="输入url后发生什么"><a href="#输入url后发生什么" class="headerlink" title="输入url后发生什么"></a>输入url后发生什么</h2><ol>
<li>生成http请求</li>
<li>浏览器缓存</li>
<li>DNS域名解析，本地域名服务器缓存，根域名服务器，顶级域名服务器，权威域名服务器。</li>
<li>tcp三次握手</li>
<li>tls四次握手</li>
<li>ip地址封装ip帧，路由器转发，各个网络之间通信</li>
<li>到达目的主机网络后交换机ARP地址解析，找到目的主机的mac地址。</li>
<li>返回数据到浏览器，执行渲染过程。</li>
<li>tcp四次挥手。</li>
</ol>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h2><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h1 id="10-31"><a href="#10-31" class="headerlink" title="10.31"></a>10.31</h1><!-- 爱你所爱，行你所行，听从你心，无问西东 -->
<h2 id="数组和链表删除、新增元素的时间复杂度-9997"><a href="#数组和链表删除、新增元素的时间复杂度-9997" class="headerlink" title="数组和链表删除、新增元素的时间复杂度 &#9997;"></a>数组和链表删除、新增元素的时间复杂度 &#9997;</h2><ul>
<li>数组复杂度是O（n）：插入、删除要移动元素。</li>
<li>链表如果知道位置复杂度是O（1）。</li>
</ul>
<h2 id="js是单线程语言，如果写出死循环会怎么样？-9997"><a href="#js是单线程语言，如果写出死循环会怎么样？-9997" class="headerlink" title="js是单线程语言，如果写出死循环会怎么样？&#9997;"></a>js是单线程语言，如果写出死循环会怎么样？&#9997;</h2><ul>
<li>这个循环会占用主线程，导致js无法处理其他任务，包括用户界面的更新和事件的响应，导致页面冻结，无法进行交互。</li>
</ul>
<h2 id="微前端解决了什么问题-1"><a href="#微前端解决了什么问题-1" class="headerlink" title="微前端解决了什么问题"></a>微前端解决了什么问题</h2><h2 id="微前端工作原理"><a href="#微前端工作原理" class="headerlink" title="微前端工作原理"></a>微前端工作原理</h2><ul>
<li>应用的加载和切换，应用的隔离和通信</li>
</ul>
<h2 id="iframe和qiankun区别"><a href="#iframe和qiankun区别" class="headerlink" title="iframe和qiankun区别"></a>iframe和qiankun区别</h2><ol>
<li>实现方式</li>
<li>加载性能</li>
<li>通信方式</li>
<li>应用场景</li>
</ol>
<h2 id="子应用如何接入微前端"><a href="#子应用如何接入微前端" class="headerlink" title="子应用如何接入微前端"></a>子应用如何接入微前端</h2><h2 id="父子应用通信-1"><a href="#父子应用通信-1" class="headerlink" title="父子应用通信"></a>父子应用通信</h2><h2 id="js沙箱机制-1"><a href="#js沙箱机制-1" class="headerlink" title="js沙箱机制"></a>js沙箱机制</h2><p>-（激活沙箱干什么，退出沙箱干什么）</p>
<ol>
<li>快照沙箱：遍历window对象</li>
<li>单实例沙箱：代理层，解决遍历window对象问题</li>
<li>多实例沙箱：解决全局window对象被污染的问题</li>
</ol>
<h2 id="CSS样式隔离"><a href="#CSS样式隔离" class="headerlink" title="CSS样式隔离"></a>CSS样式隔离</h2><h2 id="mvc，mvp，mvvm"><a href="#mvc，mvp，mvvm" class="headerlink" title="mvc，mvp，mvvm"></a>mvc，mvp，mvvm</h2><h2 id="晚上复习项目，排序算法"><a href="#晚上复习项目，排序算法" class="headerlink" title="晚上复习项目，排序算法"></a>晚上复习项目，排序算法</h2><h1 id="11-1"><a href="#11-1" class="headerlink" title="11.1"></a>11.1</h1><h2 id="npm-和pnpm区别"><a href="#npm-和pnpm区别" class="headerlink" title="npm 和pnpm区别"></a>npm 和pnpm区别</h2><ul>
<li>全局存储</li>
<li>硬链接</li>
<li>扁平化依赖</li>
</ul>
<h2 id="mvc，mvp，mvvm-1"><a href="#mvc，mvp，mvvm-1" class="headerlink" title="mvc，mvp，mvvm"></a>mvc，mvp，mvvm</h2><h2 id="XSS，CSRF攻击"><a href="#XSS，CSRF攻击" class="headerlink" title="XSS，CSRF攻击"></a>XSS，CSRF攻击</h2><ul>
<li>CSRF：同源检测，token，sameSite</li>
</ul>
<h2 id="下午美团三面"><a href="#下午美团三面" class="headerlink" title="下午美团三面"></a>下午美团三面</h2><h1 id="11-2-休息一天"><a href="#11-2-休息一天" class="headerlink" title="11.2 休息一天"></a>11.2 休息一天</h1><h1 id="11-3"><a href="#11-3" class="headerlink" title="11.3"></a>11.3</h1><ul>
<li>树题目</li>
</ul>
<h2 id="二叉树前中后序递归遍历"><a href="#二叉树前中后序递归遍历" class="headerlink" title="二叉树前中后序递归遍历"></a>二叉树前中后序递归遍历</h2><h2 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h2><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><h2 id="二叉树最大深度"><a href="#二叉树最大深度" class="headerlink" title="二叉树最大深度"></a>二叉树最大深度</h2><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><h2 id="二叉树直径"><a href="#二叉树直径" class="headerlink" title="二叉树直径"></a>二叉树直径</h2><h2 id="将有序数组转换为二叉树"><a href="#将有序数组转换为二叉树" class="headerlink" title="将有序数组转换为二叉树"></a>将有序数组转换为二叉树</h2><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><h2 id="二叉搜索树第K小的元素"><a href="#二叉搜索树第K小的元素" class="headerlink" title="二叉搜索树第K小的元素"></a>二叉搜索树第K小的元素</h2><h2 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/652632988">https://zhuanlan.zhihu.com/p/652632988</a></li>
</ul>
<h1 id="11-4-没睡好，摆烂了"><a href="#11-4-没睡好，摆烂了" class="headerlink" title="11.4 没睡好，摆烂了"></a>11.4 没睡好，摆烂了</h1><h1 id="11-5"><a href="#11-5" class="headerlink" title="11.5"></a>11.5</h1><h2 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h2><h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h2><h2 id="对typescript的理解？与js区别？"><a href="#对typescript的理解？与js区别？" class="headerlink" title="对typescript的理解？与js区别？"></a>对typescript的理解？与js区别？</h2><h2 id="ts数据类型"><a href="#ts数据类型" class="headerlink" title="ts数据类型"></a>ts数据类型</h2><h2 id="any和unknown区别-✨"><a href="#any和unknown区别-✨" class="headerlink" title="any和unknown区别 ✨"></a>any和unknown区别 ✨</h2><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><h2 id="接口，接口和类区别-✨"><a href="#接口，接口和类区别-✨" class="headerlink" title="接口，接口和类区别 ✨"></a>接口，接口和类区别 ✨</h2><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h2 id="对ts函数的理解"><a href="#对ts函数的理解" class="headerlink" title="对ts函数的理解"></a>对ts函数的理解</h2><h2 id="交叉类型-和联合类型-✨"><a href="#交叉类型-和联合类型-✨" class="headerlink" title="交叉类型 &amp; 和联合类型 | ✨"></a>交叉类型 &amp; 和联合类型 | ✨</h2><h1 id="11-6"><a href="#11-6" class="headerlink" title="11.6"></a>11.6</h1><h2 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h2><h2 id="路径总和I，II没写出来"><a href="#路径总和I，II没写出来" class="headerlink" title="路径总和I，II没写出来"></a>路径总和I，II没写出来</h2><h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h1 id="11-7"><a href="#11-7" class="headerlink" title="11.7"></a>11.7</h1><h2 id="路径总和II"><a href="#路径总和II" class="headerlink" title="路径总和II"></a>路径总和II</h2><h2 id="路径总和III"><a href="#路径总和III" class="headerlink" title="路径总和III"></a>路径总和III</h2><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><h2 id="patical"><a href="#patical" class="headerlink" title="patical"></a>patical</h2><h2 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h2><h2 id="returnType"><a href="#returnType" class="headerlink" title="returnType"></a>returnType</h2><h2 id="响应式为什么要用-reflect-这种-API-10024"><a href="#响应式为什么要用-reflect-这种-API-10024" class="headerlink" title="响应式为什么要用 reflect 这种 API &#10024;"></a>响应式为什么要用 reflect 这种 API &#10024;</h2><ul>
<li>提供一种更一致和可靠的方式来执行底层的 JavaScript 操作（比如属性访问、赋值、删除等）,代码更简洁易读，13种proxy的捕获器和reflect静态方法一一对应。</li>
<li>reflect第三个参数可以修改this的指向，把this指向改成代理对象，触发响应式依赖收集。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">如果被代理的对象本身有<span class="hljs-keyword">get</span>函数，<span class="hljs-keyword">get</span>函数里面的<span class="hljs-keyword">this</span>默认指向对象本身。proxy访问这个<br>数据时候，<span class="hljs-keyword">get</span>函数<span class="hljs-keyword">this</span>需要指向proxy，才能触发响应式依赖收集。<br><br> <span class="hljs-keyword">const</span> obj = &#123;<br>            a: <span class="hljs-number">1</span>,<br>            b: <span class="hljs-number">2</span>,<br>            <span class="hljs-keyword">get</span> c() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a + <span class="hljs-keyword">this</span>.b;<br>            &#125;<br>        &#125;<br>        let proxy = new Proxy(obj, &#123;<br>            <span class="hljs-keyword">get</span>(target, key) &#123;<br>                console.log(<span class="hljs-string">&quot;read&quot;</span>, key);<br>                <span class="hljs-comment">// return Reflect.get(target,key,proxy)</span><br>                <span class="hljs-keyword">return</span> target[key];<br>            &#125;<br>        &#125;)<br>        console.log(proxy.c);<br></code></pre></td></tr></table></figure>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><ul>
<li>算出子串最长前后缀</li>
<li>遇到不匹配时候，找前一位的前后缀长度，从子串对应长度下标开始比较。</li>
<li>因为前后缀相同，不用重新比较前面相同的部分。</li>
</ul>
<h2 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h2><h2 id="进程状态-1"><a href="#进程状态-1" class="headerlink" title="进程状态"></a>进程状态</h2><h2 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h2><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li>cpu</li>
<li>可以并发且共享资源的执行</li>
</ul>
<h1 id="11-8"><a href="#11-8" class="headerlink" title="11.8"></a>11.8</h1><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ul>
<li>先来先服务</li>
<li>短作业优先</li>
<li>时间片轮询</li>
<li>最高响应比</li>
<li>最高优先级</li>
</ul>
<h2 id="进程通信-1"><a href="#进程通信-1" class="headerlink" title="进程通信"></a>进程通信</h2><ul>
<li>管道，消息队列，共享内存</li>
</ul>
<h2 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h2><ul>
<li>互斥，占有并等待，不可剥夺，循环等待。</li>
</ul>
<h2 id="锁-1"><a href="#锁-1" class="headerlink" title="锁"></a>锁</h2><h2 id="浏览器进程-1"><a href="#浏览器进程-1" class="headerlink" title="浏览器进程"></a>浏览器进程</h2><ul>
<li>GUI进程</li>
<li>插件进程</li>
<li>浏览器进程</li>
<li>渲染进程</li>
</ul>
<h2 id="为什么浏览器限制进程最大数量"><a href="#为什么浏览器限制进程最大数量" class="headerlink" title="为什么浏览器限制进程最大数量"></a>为什么浏览器限制进程最大数量</h2><ul>
<li>良性竞争</li>
<li>服务器端口数有限</li>
<li>避免并发过高</li>
<li>减少线程切换</li>
</ul>
<h2 id="虚拟内存-1"><a href="#虚拟内存-1" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><ul>
<li>进程隔离，内存扩展，内存管理</li>
</ul>
<h2 id="内存分段-1"><a href="#内存分段-1" class="headerlink" title="内存分段"></a>内存分段</h2><h2 id="内存分页-1"><a href="#内存分页-1" class="headerlink" title="内存分页"></a>内存分页</h2><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ul>
<li>先进先出 </li>
<li>最近最少使用</li>
<li>最佳</li>
<li>最不常用</li>
</ul>
<h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><ul>
<li>两个栈，保证常数时间复杂度查找最小值。</li>
</ul>
<h2 id="手写并发请求"><a href="#手写并发请求" class="headerlink" title="手写并发请求"></a>手写并发请求</h2><h1 id="11-9"><a href="#11-9" class="headerlink" title="11.9"></a>11.9</h1><ul>
<li>计算机网络，操作系统；复习项目，微前端；</li>
</ul>
<h2 id="http组成"><a href="#http组成" class="headerlink" title="http组成"></a>http组成</h2><ul>
<li>请求行，请求头，空行，请求体</li>
<li>状态行，响应头，空行，响应体</li>
</ul>
<h2 id="http状态码-1"><a href="#http状态码-1" class="headerlink" title="http状态码"></a>http状态码</h2><h2 id="http头部字段"><a href="#http头部字段" class="headerlink" title="http头部字段"></a>http头部字段</h2><h2 id="get和post请求区别"><a href="#get和post请求区别" class="headerlink" title="get和post请求区别"></a>get和post请求区别</h2><h2 id="http1-1与http1-0区别，也是http1-1优点"><a href="#http1-1与http1-0区别，也是http1-1优点" class="headerlink" title="http1.1与http1.0区别，也是http1.1优点"></a>http1.1与http1.0区别，也是http1.1优点</h2><ol>
<li>强制缓存,协商缓存</li>
<li>host字段</li>
<li>增加更多状态码</li>
<li>允许局部请求</li>
<li>短连接,长连接</li>
</ol>
<h2 id="http1-1缺点"><a href="#http1-1缺点" class="headerlink" title="http1.1缺点"></a>http1.1缺点</h2><ul>
<li>无状态 &#x3D;&gt; cookie,token</li>
<li>明文传输 &#x3D;&gt; https</li>
</ul>
<h2 id="优化http1-1"><a href="#优化http1-1" class="headerlink" title="优化http1.1"></a>优化http1.1</h2><ol>
<li>缓存</li>
<li>重定向，按需请求</li>
<li>压缩请求</li>
<li>cookie</li>
<li>https</li>
</ol>
<h2 id="https-1"><a href="#https-1" class="headerlink" title="https"></a>https</h2><ul>
<li>解决了明文传输，身份认证，信息篡改三个问题。</li>
</ul>
<ol>
<li>非对称加密，对称加密 &#x3D;》 明文传输</li>
<li>摘要算法，私钥签名 &#x3D;》 信息篡改</li>
<li>数字证书 &#x3D;》身份认证</li>
</ol>
<h2 id="tls握手"><a href="#tls握手" class="headerlink" title="tls握手"></a>tls握手</h2><ol>
<li>随机数，密码套件，tls版本号</li>
<li>随机数，数字证书，选择tls版本号、密码套件</li>
<li>解开数字证书获取公钥，公钥加密第三个随机数，三个随机数生成对称密钥，通知后续用对称密钥加密。</li>
<li>三个随机数生成对称密钥，后续用对称密钥加密。</li>
</ol>
<h2 id="https一定安全吗？"><a href="#https一定安全吗？" class="headerlink" title="https一定安全吗？"></a>https一定安全吗？</h2><ul>
<li>不一定，中间人攻击。如果客户端信任了中间人的非法证书。</li>
</ul>
<h2 id="http2-0-1"><a href="#http2-0-1" class="headerlink" title="http2.0"></a>http2.0</h2><h2 id="http3-0-2"><a href="#http3-0-2" class="headerlink" title="http3.0"></a>http3.0</h2><h2 id="父子进程-10024"><a href="#父子进程-10024" class="headerlink" title="父子进程 &#10024;"></a>父子进程 &#10024;</h2><ul>
<li>父进程：是创建其他进程的进程，父进程通常负责控制和管理其子进程，包括等待子进程的结束、收集子进程的状态、分配资源等。</li>
<li>子进程：子进程是由父进程创建的新进程，继承了父进程的大部分环境和资源。</li>
</ul>
<h2 id="孤儿进程和僵尸进程-10024"><a href="#孤儿进程和僵尸进程-10024" class="headerlink" title="孤儿进程和僵尸进程 &#10024;"></a>孤儿进程和僵尸进程 &#10024;</h2><ul>
<li>孤儿进程：父进程因特殊情况先于子进程终止。</li>
<li>僵尸进程：已经终止的子进程，但其进程控制块还在系统的进程表中，等待父进程获取状态。</li>
</ul>
<h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><h2 id="非负大整数相加"><a href="#非负大整数相加" class="headerlink" title="非负大整数相加"></a>非负大整数相加</h2><h2 id="数组每隔千分位相加"><a href="#数组每隔千分位相加" class="headerlink" title="数组每隔千分位相加"></a>数组每隔千分位相加</h2><h2 id="虾皮一面"><a href="#虾皮一面" class="headerlink" title="虾皮一面"></a>虾皮一面</h2><!-- ## RSA算法 -->
<h1 id="11-10"><a href="#11-10" class="headerlink" title="11.10"></a>11.10</h1><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><h2 id="找到字符串异位字符"><a href="#找到字符串异位字符" class="headerlink" title="找到字符串异位字符"></a>找到字符串异位字符</h2><h2 id="如何判断需求复杂度"><a href="#如何判断需求复杂度" class="headerlink" title="如何判断需求复杂度"></a>如何判断需求复杂度</h2><ol>
<li><strong>功能逻辑</strong>：需要的功能越多，业务逻辑越复杂，该需求复杂度越高。</li>
<li><strong>交互逻辑</strong>：丰富的交互体验，比如：拖拉拽、复杂的表单数据校验。</li>
<li><strong>接口数量</strong>：接口数量多、数据依赖复杂，调试成本高。</li>
<li><strong>需求变化</strong>：需求变化是否影响代码的复用性和扩展性，是否需要拆分成多个公共组件等等。</li>
</ol>
<h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><ul>
<li>flex-direction,justify-content,flex-wrap,align-item,flex-flow.</li>
<li>justify-content: flex-start,flex-end,center,space-around(平分剩余空间),space-between(先两边贴边，再平分剩余空间).</li>
<li>align-item:flex-start,flex-end,center,stretch.</li>
<li>align-content: flex-start, flex-end,center,space-around,space-between,stretch</li>
</ul>
<h1 id="11-11"><a href="#11-11" class="headerlink" title="11.11"></a>11.11</h1><!-- 好事降临 -->
<h2 id="es5实现extend"><a href="#es5实现extend" class="headerlink" title="es5实现extend"></a>es5实现extend</h2><h2 id="token原理-10024"><a href="#token原理-10024" class="headerlink" title="token原理 &#10024;"></a>token原理 &#10024;</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44972847/article/details/109249604">https://blog.csdn.net/qq_44972847/article/details/109249604</a></li>
<li>JWT：header（加密算法信息）、payload（用户基本信息，不会放敏感信息）、签名。</li>
<li>客户端请求头authorization字段携带token，服务端解密签名验证token合法性。</li>
</ul>
<h2 id="防抖节流-1"><a href="#防抖节流-1" class="headerlink" title="防抖节流"></a>防抖节流</h2><h2 id="函数柯里化-1"><a href="#函数柯里化-1" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><h2 id="promise-all、promise-race"><a href="#promise-all、promise-race" class="headerlink" title="promise.all、promise.race"></a>promise.all、promise.race</h2><h2 id="promise封装ajax"><a href="#promise封装ajax" class="headerlink" title="promise封装ajax"></a>promise封装ajax</h2><h2 id="xss攻击，csrf攻击"><a href="#xss攻击，csrf攻击" class="headerlink" title="xss攻击，csrf攻击"></a>xss攻击，csrf攻击</h2><h2 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h2><ul>
<li>剔除接口类型中不需要的属性。</li>
</ul>
<h2 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h2><h2 id="patical-1"><a href="#patical-1" class="headerlink" title="patical"></a>patical</h2><h2 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h2><h2 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h2><h2 id="extract"><a href="#extract" class="headerlink" title="extract"></a>extract</h2><h2 id="requied"><a href="#requied" class="headerlink" title="requied"></a>requied</h2><h2 id="回溯：全排列"><a href="#回溯：全排列" class="headerlink" title="回溯：全排列"></a>回溯：全排列</h2><h2 id="下午三点b站面试"><a href="#下午三点b站面试" class="headerlink" title="下午三点b站面试"></a>下午三点b站面试</h2><h2 id="下午五点美团hr面试"><a href="#下午五点美团hr面试" class="headerlink" title="下午五点美团hr面试"></a>下午五点美团hr面试</h2><!-- 操作系统，计算机网络，Ts，微前端 -->
<h1 id="11-12"><a href="#11-12" class="headerlink" title="11.12"></a>11.12</h1><h2 id="ping一个IP是哪一层协议？"><a href="#ping一个IP是哪一层协议？" class="headerlink" title="ping一个IP是哪一层协议？"></a>ping一个IP是哪一层协议？</h2><ul>
<li>网络层，用的是ICMP协议。</li>
</ul>
<h2 id="六种继承方法"><a href="#六种继承方法" class="headerlink" title="六种继承方法"></a>六种继承方法</h2><h2 id="es5实现extend-1"><a href="#es5实现extend-1" class="headerlink" title="es5实现extend"></a>es5实现extend</h2><h2 id="token原理"><a href="#token原理" class="headerlink" title="token原理"></a>token原理</h2><h2 id="防抖节流-2"><a href="#防抖节流-2" class="headerlink" title="防抖节流"></a>防抖节流</h2><h2 id="cookie和storage能跨域吗？"><a href="#cookie和storage能跨域吗？" class="headerlink" title="cookie和storage能跨域吗？"></a>cookie和storage能跨域吗？</h2><ul>
<li>不能，都有同源策略限制。</li>
</ul>
<h2 id="如何解决上一个问题？"><a href="#如何解决上一个问题？" class="headerlink" title="如何解决上一个问题？"></a>如何解决上一个问题？</h2><ol>
<li>cookie设置为父域，让子域共享cookie，单点登录时候我们可以这么做。</li>
</ol>
<h2 id="如果接手一个项目，如何处理？-10024"><a href="#如果接手一个项目，如何处理？-10024" class="headerlink" title="如果接手一个项目，如何处理？ &#10024;"></a>如果接手一个项目，如何处理？ &#10024;</h2><h2 id="JSON编辑器，其他的diff方案。"><a href="#JSON编辑器，其他的diff方案。" class="headerlink" title="JSON编辑器，其他的diff方案。"></a>JSON编辑器，其他的diff方案。</h2><h2 id="下午b站二面"><a href="#下午b站二面" class="headerlink" title="下午b站二面"></a>下午b站二面</h2><h1 id="11-13"><a href="#11-13" class="headerlink" title="11.13"></a>11.13</h1><!-- 如果结局并非所愿，那就在尘埃落定前奋力一搏。 -->
<h2 id="前端debug-10024"><a href="#前端debug-10024" class="headerlink" title="前端debug &#10024;"></a>前端debug &#10024;</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7084924971901779998">https://juejin.cn/post/7084924971901779998</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42961150/article/details/123499276">https://blog.csdn.net/qq_42961150/article/details/123499276</a></li>
</ul>
<h3 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h3><ul>
<li>console.log，console.error</li>
</ul>
<h3 id="devtool工具。"><a href="#devtool工具。" class="headerlink" title="devtool工具。"></a>devtool工具。</h3><ul>
<li>debugger。</li>
<li>打断点：除了在代码写debugger外还能在调试工具标记断点。</li>
</ul>
<h3 id="线上怎么调试"><a href="#线上怎么调试" class="headerlink" title="线上怎么调试"></a>线上怎么调试</h3><ul>
<li>有代码：console.log，debugger；</li>
<li>无代码：Override替换功能，找到保存的文件夹开启替换，在请求网络中找到要调试的文件进行更改。</li>
</ul>
<h2 id="google-devtool工具-10024"><a href="#google-devtool工具-10024" class="headerlink" title="google devtool工具 &#10024;"></a>google devtool工具 &#10024;</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KM4y1G7EF/?spm_id_from=333.337.search-card.all.click&vd_source=9b9c9c2844427b792423aada902b836b">https://www.bilibili.com/video/BV1KM4y1G7EF/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9b9c9c2844427b792423aada902b836b</a></li>
</ul>
<h3 id="elements"><a href="#elements" class="headerlink" title="elements"></a>elements</h3><ol>
<li>查找DOM元素。</li>
<li>调试css样式，修改类里面的属性值，复制样式（有图形化面板：width、padding、border）</li>
<li>设置状态：比如按钮一直为hover。</li>
<li>查看事件：事件监听器里面查看绑定的事件。</li>
</ol>
<h3 id="console"><a href="#console" class="headerlink" title="console"></a>console</h3><ol>
<li>打印变量值</li>
<li>眼睛：监听变量值</li>
</ol>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><ol>
<li>debugger；</li>
<li>断点；</li>
<li>watch监测变量。</li>
</ol>
<h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><ul>
<li>网络请求，请求是否发出、获取的结果是什么。</li>
</ul>
<h3 id="application"><a href="#application" class="headerlink" title="application"></a>application</h3><ul>
<li>查看cookie、storage。</li>
</ul>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><ul>
<li>发送请求，被浏览器代理拦截，请求指向到本机127.0.0.1：8899，8899端口号上有whistle代理，whistle代理配置规则请求的地址为我们本地跑起项目的地址。这样我们本地项目可以借助发送请求的网址的域名下的cookie。</li>
</ul>
<h1 id="11-14"><a href="#11-14" class="headerlink" title="11.14"></a>11.14</h1><h2 id="如何封装请求函数"><a href="#如何封装请求函数" class="headerlink" title="如何封装请求函数"></a>如何封装请求函数</h2><ol>
<li>封装了一个httpclient类，构造函数里确定超时时间</li>
<li>请求拦截器：携带默认参数content-type、token、post请求参数</li>
<li>响应拦截器：正常状态码返回data，登录状态过期跳转到登录页面，其他错误打印错误日志抛出错误。</li>
</ol>
<h2 id="如何取消请求？"><a href="#如何取消请求？" class="headerlink" title="如何取消请求？"></a>如何取消请求？</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/shanghai597/article/details/141132511">https://blog.csdn.net/shanghai597/article/details/141132511</a></li>
<li><strong>应用场景</strong>：用户加载数据时候跳转到其他页面、用户提交表单时候点击取消按钮就可以取消请求，减少资源消耗、提高用户体验。</li>
<li><strong>cancelToken取消逻辑</strong>：依赖promise的链式调用，调用cancel方法时候抛出错误，被catch捕获从而触发取消的逻辑。</li>
<li><strong>具体实现</strong>：每个请求生成唯一标识key，用全局map存储请求的source方法 map.set(key,cancel);请求拦截器取消重复的请求（比如之前请求过，再次请求）、在全局前置路由守卫取消所有请求。</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">config.cancelToken =<span class="hljs-keyword">new</span> axios.CancelToken(<span class="hljs-function"><span class="hljs-params">cancel</span>=&gt;</span><span class="hljs-built_in">map</span>.set(key,cancel));<br></code></pre></td></tr></table></figure>

<h2 id="setInterval缺点？"><a href="#setInterval缺点？" class="headerlink" title="setInterval缺点？"></a>setInterval缺点？</h2><ul>
<li>setInterval是每个一段时间把任务推送到任务队列当中</li>
</ul>
<ol>
<li>任务同时执行。上一个任务还在执行，下一个任务就已经推送进来了。</li>
<li>跳过某些间隔，setInterval仅当队列中没有该定时器其他任务时候才会推入任务。</li>
</ol>
<h2 id="vue实现倒计时器"><a href="#vue实现倒计时器" class="headerlink" title="vue实现倒计时器"></a>vue实现倒计时器</h2><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">count</span> &#125;&#125;</span><span class="language-xml"> s<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getCode</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> <span class="hljs-variable constant_">COUNT_NUM</span> = <span class="hljs-number">60</span>;</span></span><br><span class="language-javascript"><span class="language-xml">  count.<span class="hljs-property">value</span> = <span class="hljs-variable constant_">COUNT_NUM</span>;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">countDown</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    timer &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timer);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">if</span> (count.<span class="hljs-property">value</span> &gt; <span class="hljs-number">0</span> &amp;&amp; count.<span class="hljs-property">value</span> &lt;= <span class="hljs-variable constant_">COUNT_NUM</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      count.<span class="hljs-property">value</span>--;</span></span><br><span class="language-javascript"><span class="language-xml">      timer = <span class="hljs-built_in">setTimeout</span>(countDown, <span class="hljs-number">1000</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      timer = <span class="hljs-literal">null</span>;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">countDown</span>();</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">getCode</span>();</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">if</span> (timer) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-built_in">clearTimeout</span>(timer);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.box</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">display</span>: flex;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">justify-content</span>: center;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">align-items</span>: center;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol>
<li>beforeCreate:调用组件init方法时候调用,此时无法访问初始化数据,创建页面watcher,计算属性等等.</li>
<li>created:响应式数据,计算属性,监听器等初始化完成,但还未进入渲染阶段.</li>
<li>beforeMount:模板编译,将模板转换为AST语法树,代码拼接成渲染函数,执行渲染函数生成虚拟DOM,diff对比后生成真实DOM.但未挂载到容器上.</li>
<li>mounted:将生成的html挂载到容器上.</li>
<li>beforeUpdate:响应式数据更新时调用,此时数据进行了更新,但页面还未渲染.</li>
<li>updated:render函数重新执行,页面更新.</li>
<li>beforeUnmount:组件实例销毁前调用,此时还保留了组件所有功能.</li>
<li>unMounted: 组件卸载完后调用,清除定时器 DOM监听器等等.</li>
</ol>
<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><h2 id="实现准时setTimeout"><a href="#实现准时setTimeout" class="headerlink" title="实现准时setTimeout"></a>实现准时setTimeout</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lgno2/article/details/116574487">https://blog.csdn.net/lgno2/article/details/116574487</a></li>
</ul>
<ol>
<li>worker.js，里面开启while循环</li>
<li>requestAnimationFrame</li>
</ol>
<h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><ul>
<li>接收一个回调函数作为参数,该回调函数会在浏览器下一次重绘前执行。</li>
<li>16.67ms执行一次，因为浏览器每秒刷新60次。</li>
</ul>
<h1 id="11-15"><a href="#11-15" class="headerlink" title="11.15"></a>11.15</h1><h2 id="上午十一点滴滴一面"><a href="#上午十一点滴滴一面" class="headerlink" title="上午十一点滴滴一面"></a>上午十一点滴滴一面</h2><h2 id="package-json内容"><a href="#package-json内容" class="headerlink" title="package.json内容"></a>package.json内容</h2><ol>
<li>基本信息：项目名、版本号。</li>
<li>依赖管理：项目运行时依赖、开发时依赖。</li>
<li>脚本命令：npm run build</li>
</ol>
<h2 id="响应式为什么要用-reflect-这种-API-10024-1"><a href="#响应式为什么要用-reflect-这种-API-10024-1" class="headerlink" title="响应式为什么要用 reflect 这种 API &#10024;"></a>响应式为什么要用 reflect 这种 API &#10024;</h2><ul>
<li>提供一种更一致和可靠的方式来执行底层的 JavaScript 操作（比如属性访问、赋值、删除等）,代码更简洁易读，13种proxy的捕获器和reflect静态方法一一对应。</li>
<li>reflect第三个参数可以修改this的指向，把this指向改成代理对象，触发响应式依赖收集。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">如果被代理的对象本身有<span class="hljs-keyword">get</span>函数，<span class="hljs-keyword">get</span>函数里面的<span class="hljs-keyword">this</span>默认指向对象本身。proxy访问这个<br>数据时候，<span class="hljs-keyword">get</span>函数<span class="hljs-keyword">this</span>需要指向proxy，才能触发响应式依赖收集。<br><br> <span class="hljs-keyword">const</span> obj = &#123;<br>            a: <span class="hljs-number">1</span>,<br>            b: <span class="hljs-number">2</span>,<br>            <span class="hljs-keyword">get</span> c() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a + <span class="hljs-keyword">this</span>.b;<br>            &#125;<br>        &#125;<br>        let proxy = new Proxy(obj, &#123;<br>            <span class="hljs-keyword">get</span>(target, key) &#123;<br>                console.log(<span class="hljs-string">&quot;read&quot;</span>, key);<br>                <span class="hljs-comment">// return Reflect.get(target,key,proxy)</span><br>                <span class="hljs-keyword">return</span> target[key];<br>            &#125;<br>        &#125;)<br>        console.log(proxy.c);<br></code></pre></td></tr></table></figure>

<h2 id="父子进程-10024-1"><a href="#父子进程-10024-1" class="headerlink" title="父子进程 &#10024;"></a>父子进程 &#10024;</h2><ul>
<li>父进程：是创建其他进程的进程，父进程通常负责控制和管理其子进程，包括等待子进程的结束、收集子进程的状态、分配资源等。</li>
<li>子进程：子进程是由父进程创建的新进程，继承了父进程的大部分环境和资源。</li>
</ul>
<h2 id="孤儿进程和僵尸进程-10024-1"><a href="#孤儿进程和僵尸进程-10024-1" class="headerlink" title="孤儿进程和僵尸进程 &#10024;"></a>孤儿进程和僵尸进程 &#10024;</h2><ul>
<li>孤儿进程：父进程因特殊情况先于子进程终止。</li>
<li>僵尸进程：已经终止的子进程，但其进程控制块还在系统的进程表中，等待父进程获取状态。</li>
</ul>
<h2 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h2><ul>
<li>每秒查询次数</li>
</ul>
<h2 id="通过前端的手段来减少后端的请求压力-10024"><a href="#通过前端的手段来减少后端的请求压力-10024" class="headerlink" title="通过前端的手段来减少后端的请求压力 &#10024;"></a>通过前端的手段来减少后端的请求压力 &#10024;</h2><!-- 面对一种瞬时的并发请求，QPS有一个瞬间的峰值，作为前端同学 -->
<ul>
<li>缓存</li>
<li>取消重复get请求</li>
<li>请求合并：前后端共同设计接口</li>
<li>防抖、节流</li>
<li>懒加载</li>
</ul>
<h2 id="发布订阅-事件总线"><a href="#发布订阅-事件总线" class="headerlink" title="发布订阅&#x2F;事件总线"></a>发布订阅&#x2F;事件总线</h2><h2 id="SSR服务端渲染-2"><a href="#SSR服务端渲染-2" class="headerlink" title="SSR服务端渲染?"></a>SSR服务端渲染?</h2><ul>
<li>优点:</li>
</ul>
<ol>
<li>更快的首屏加载速度.服务端根据请求路径获取到对应组件,服务端组件请求数据,将组件渲染为html.将html和vue文件作为响应内容返回给客户端.客户端渲染页面,并加载vue文件,将页面变为动态页面.</li>
<li>更好支持SEO,搜索引擎爬虫可以获取到完全渲染的页面.</li>
</ol>
<ul>
<li>缺点:</li>
</ul>
<ol>
<li>只支持beforeCreate钩子和created钩子.</li>
<li>增大服务端压力.</li>
</ol>
<h1 id="11-16"><a href="#11-16" class="headerlink" title="11.16"></a>11.16</h1><!-- 穷且益坚，不坠青云之志 -->
<h2 id="微前端项目难点"><a href="#微前端项目难点" class="headerlink" title="微前端项目难点"></a>微前端项目难点</h2><h2 id="diff功能"><a href="#diff功能" class="headerlink" title="diff功能"></a>diff功能</h2><h2 id="开放题：实现可视化报表，前端考虑哪些？-10024"><a href="#开放题：实现可视化报表，前端考虑哪些？-10024" class="headerlink" title="开放题：实现可视化报表，前端考虑哪些？ &#10024;"></a>开放题：实现可视化报表，前端考虑哪些？ &#10024;</h2><ol>
<li><p>需求分析：<br>数据来源：数据格式、接口、频率。<br>展示内容：维度、排序、拖拽功能。<br>展示形式：表格、柱状图、折线图。</p>
</li>
<li><p>数据处理：<br>数据格式化：转换为图表、表格需要的格式数据。<br>数据清洗：处理空值、异常值<br>数据缓存：本地缓存</p>
</li>
<li><p>设计实现：<br>技术选型：echarts、组件库。<br>样式上：响应式设计，颜色、字体风格<br>交互：excel导出、选取参数更改表格（一天内、七天内）、拖拽。</p>
</li>
<li><p>优化<br>分页<br>按需加载<br>虚拟列表<br>导出用webworker</p>
</li>
</ol>
<h2 id="上午虾皮二面"><a href="#上午虾皮二面" class="headerlink" title="上午虾皮二面"></a>上午虾皮二面</h2><h2 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h2><h1 id="11-17-出去玩一天"><a href="#11-17-出去玩一天" class="headerlink" title="11.17 出去玩一天"></a>11.17 出去玩一天</h1><!-- 后面一周：滴滴、b站、虾皮收尾，周五周末疯狂海投。 
    复习webpack、！vite！知识点；
 -->
<h1 id="11-18"><a href="#11-18" class="headerlink" title="11.18"></a>11.18</h1><h2 id="编写loader"><a href="#编写loader" class="headerlink" title="编写loader"></a>编写loader</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7100534685134454815?searchId=2024111811590127047A1230DEEC4E5372">https://juejin.cn/post/7100534685134454815?searchId=2024111811590127047A1230DEEC4E5372</a></p>
<ul>
<li>loader职责是单一、链式传输、易维护。</li>
</ul>
<ol>
<li>本质是函数，this会被webpack填充，不能用箭头函数。</li>
<li>接受一个参数，为webpack传递loader的文件源，源文件字符串。</li>
<li>this.callBack异步返回结果，return同步返回结果</li>
<li>获取配置文件配置项options：loader-utils.getOptions<br>缓存： this.cacheable</li>
</ol>
<h2 id="编写plugin"><a href="#编写plugin" class="headerlink" title="编写plugin"></a>编写plugin</h2><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><h2 id="webpack构建流程"><a href="#webpack构建流程" class="headerlink" title="webpack构建流程"></a>webpack构建流程</h2><h2 id="如何提高webpack构建速度"><a href="#如何提高webpack构建速度" class="headerlink" title="如何提高webpack构建速度"></a>如何提高webpack构建速度</h2><h2 id="webpack热模块更新的原理"><a href="#webpack热模块更新的原理" class="headerlink" title="webpack热模块更新的原理"></a>webpack热模块更新的原理</h2><h2 id="vite和webpack区别"><a href="#vite和webpack区别" class="headerlink" title="vite和webpack区别"></a>vite和webpack区别</h2><h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><h2 id="es-和-commonjs区别"><a href="#es-和-commonjs区别" class="headerlink" title="es 和 commonjs区别"></a>es 和 commonjs区别</h2><ul>
<li>值浅拷贝，引用</li>
<li>编译时加载、运行时加载</li>
<li>异步加载、同步加载</li>
</ul>
<h2 id="vite核心原理"><a href="#vite核心原理" class="headerlink" title="vite核心原理"></a>vite核心原理</h2><ul>
<li>浏览器可以支持es6的import，碰见import会发送http请求获取模块的内容；vite启动服务器拦截请求，并进行相应的处理（.vue文件的编译）将文件以ESM格式返回。</li>
</ul>
<h2 id="vite构建流程"><a href="#vite构建流程" class="headerlink" title="vite构建流程"></a>vite构建流程</h2><h1 id="11-19"><a href="#11-19" class="headerlink" title="11.19"></a>11.19</h1><h2 id="堆-10024"><a href="#堆-10024" class="headerlink" title="堆 &#10024;"></a>堆 &#10024;</h2><ul>
<li>必须是完全二叉树</li>
<li>堆序性：大根堆：每个父元素大于子元素；小根堆：每个父元素小于子元素。</li>
<li>上滤、下滤 O（logN）</li>
</ul>
<h2 id="vite本地开发esbuild，生产rollup-10024"><a href="#vite本地开发esbuild，生产rollup-10024" class="headerlink" title="vite本地开发esbuild，生产rollup &#10024;&#96;"></a>vite本地开发esbuild，生产rollup &#10024;&#96;</h2><ul>
<li>esbuild：构建速度快，利用浏览器原生支持ESM模块，import代表一个http请求，拦截请求做简单的转换（转换为ESM格式）。</li>
<li>rollup：只能做简单转换，一些插件API与esbuild打包还不兼容，rollup有打包生命周期钩子，可进行模块解析、treeShaking。</li>
</ul>
<h2 id="vue编写倒计时器"><a href="#vue编写倒计时器" class="headerlink" title="vue编写倒计时器"></a>vue编写倒计时器</h2><h2 id="promise数组顺序执行"><a href="#promise数组顺序执行" class="headerlink" title="promise数组顺序执行"></a>promise数组顺序执行</h2><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><h2 id="最长递增子序列-1"><a href="#最长递增子序列-1" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><h2 id="JQ和vue区别"><a href="#JQ和vue区别" class="headerlink" title="JQ和vue区别"></a>JQ和vue区别</h2><ul>
<li>jq是命令式框架，关注过程</li>
<li>vue是声明式框架，关注结果，命令式代码封装到vue中</li>
</ul>
<h2 id="vue设计"><a href="#vue设计" class="headerlink" title="vue设计"></a>vue设计</h2><ol>
<li><em><strong>声明式框架</strong></em>：响应式原理</li>
<li><em><strong>虚拟DOM</strong></em>：第一：diff算法。第二：支持跨平台，服务端渲染、浏览器渲染，将虚拟DOM转换为真实HTML元素。</li>
<li><em><strong>区分编译时和运行时</strong></em>：<br>编译时：将<strong>模板</strong>变成js语法渲染函数生成的<strong>虚拟DOM</strong>；<br>运行时：上线时只走运行时。</li>
<li><em><strong>拥抱Ts</strong></em></li>
</ol>
<h2 id="两个vue3源码视频"><a href="#两个vue3源码视频" class="headerlink" title="两个vue3源码视频"></a>两个vue3源码视频</h2><h1 id="11-20"><a href="#11-20" class="headerlink" title="11.20"></a>11.20</h1><ul>
<li>算法 + 手写</li>
</ul>
<h2 id="手写new-1"><a href="#手写new-1" class="headerlink" title="手写new"></a>手写new</h2><ul>
<li>四步</li>
</ul>
<h2 id="手写call、apply、bind"><a href="#手写call、apply、bind" class="headerlink" title="手写call、apply、bind"></a>手写call、apply、bind</h2><ul>
<li>判断是否为函数，拿到context，拿到参数，context.fn，delete</li>
</ul>
<h2 id="promise-all"><a href="#promise-all" class="headerlink" title="promise.all"></a>promise.all</h2><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h2><ul>
<li>返回promise</li>
</ul>
<h2 id="最长连续子序列"><a href="#最长连续子序列" class="headerlink" title="最长连续子序列"></a>最长连续子序列</h2><ul>
<li>动态规划</li>
<li>双指针</li>
</ul>
<h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h2 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h2><h2 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h2><h2 id="Array-prototype-splice-方法"><a href="#Array-prototype-splice-方法" class="headerlink" title="Array.prototype.splice()方法"></a>Array.prototype.splice()方法</h2><ul>
<li>第一个参数：开始操作数组的起始位置</li>
<li>第二个参数：删除的元素个数，不传的话后面所有元素都会删除。</li>
<li>第三个参数：插入&#x2F;替换的元素。</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>.splice(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) //[‘<span class="hljs-number">1</span>’,‘<span class="hljs-number">4</span>’]<br><span class="hljs-attribute">arr</span>.splice(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,&#x27;x&#x27;,<span class="hljs-string">&quot;x&quot;</span>) // 两个元素被替换成一个x/两个x。<br><span class="hljs-attribute">arr</span>.splice(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;x&quot;</span>) // 插入一个x<br></code></pre></td></tr></table></figure>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><ol>
<li>返回值不是数组本身！</li>
<li></li>
</ol>
<h1 id="11-21"><a href="#11-21" class="headerlink" title="11.21"></a>11.21</h1><h2 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h2><ol>
<li>不要shift、pop两次!</li>
<li>数组为空shift、pop是undefined</li>
</ol>
<h2 id="url的字符串拼接"><a href="#url的字符串拼接" class="headerlink" title="url的字符串拼接"></a>url的字符串拼接</h2><h2 id="为什么要用axios而不用原生的xhr或者fetch-10024"><a href="#为什么要用axios而不用原生的xhr或者fetch-10024" class="headerlink" title="为什么要用axios而不用原生的xhr或者fetch &#10024;"></a>为什么要用axios而不用原生的xhr或者fetch &#10024;</h2><ol>
<li>简洁的API：axios基于promise封装，避免xhr复杂的回调逻辑&#x2F;</li>
<li>更好的错误处理：fetch不会将http错误码400、500抛出，需要手动抛出；axios会自动抛出。</li>
<li>请求拦截器、错误拦截器</li>
<li>自动序列化数据：JSON.stringify、解析数据。</li>
<li>版本：fetch兼容性更差。</li>
<li>更方便的请求配置：baseURL、超时设置。</li>
</ol>
<h2 id="如何封装请求函数-1"><a href="#如何封装请求函数-1" class="headerlink" title="如何封装请求函数"></a>如何封装请求函数</h2><ol>
<li>封装了一个httpclient类，构造函数里确定超时时间、baseUrl。</li>
<li>请求拦截器：携带默认参数content-type、token、post请求参数</li>
<li>响应拦截器：正常状态码返回data，登录状态过期跳转到登录页面，其他错误打印错误日志抛出错误。</li>
</ol>
<h2 id="display-visibility-opacity-1"><a href="#display-visibility-opacity-1" class="headerlink" title="display,visibility,opacity"></a>display,visibility,opacity</h2><ol>
<li>空间上,display不占据,其他占据</li>
<li>性能上:display回流重绘,visibility重绘,opacity单独形成合成层,利用GPU加速渲染</li>
<li>事件上:opacity触发事件</li>
</ol>
<h2 id="https缺点"><a href="#https缺点" class="headerlink" title="https缺点"></a>https缺点</h2><ol>
<li>tls握手开销 &#x3D;&gt; TLS升级</li>
<li>握手后加密解密的开销</li>
<li>会话复用：Session ID、token。</li>
</ol>
<h2 id="微前端复习"><a href="#微前端复习" class="headerlink" title="微前端复习"></a>微前端复习</h2><h2 id="concat和push区别"><a href="#concat和push区别" class="headerlink" title="concat和push区别"></a>concat和push区别</h2><ol>
<li>push改变原数组，concat不改变返回新数组。</li>
</ol>
<h2 id="滴滴二面"><a href="#滴滴二面" class="headerlink" title="滴滴二面"></a>滴滴二面</h2><h1 id="11-22"><a href="#11-22" class="headerlink" title="11.22"></a>11.22</h1><h2 id="为什么要用axios而不用原生的xhr或者fetch-10024-1"><a href="#为什么要用axios而不用原生的xhr或者fetch-10024-1" class="headerlink" title="为什么要用axios而不用原生的xhr或者fetch &#10024;"></a>为什么要用axios而不用原生的xhr或者fetch &#10024;</h2><ol>
<li>简洁的API：axios基于promise封装，避免xhr复杂的回调逻辑&#x2F;</li>
<li>更好的错误处理：fetch不会将http错误码400、500抛出，需要手动抛出；axios会自动抛出。</li>
<li>请求拦截器、错误拦截器</li>
<li>自动序列化数据：JSON.stringify、解析数据。</li>
<li>版本：fetch兼容性更差。</li>
<li>更方便的请求配置：baseURL、超时设置。</li>
</ol>
<h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><h2 id="http状态码-2"><a href="#http状态码-2" class="headerlink" title="http状态码"></a>http状态码</h2><ol>
<li>200、204、206</li>
<li>301、302、304</li>
<li>400、403、404</li>
<li>500、502、503</li>
</ol>
<h2 id="http头部字段-1"><a href="#http头部字段-1" class="headerlink" title="http头部字段"></a>http头部字段</h2><ol>
<li>expires&#x2F;cache-control；etag&#x2F;if-none-match；last-modified&#x2F;if-modified-since；</li>
<li>content-type&#x2F;accept、content-length、content-encoding&#x2F;accept-coding；</li>
<li>connection：keep-alive</li>
<li>host：解决一个ip地址对应多个域名。</li>
<li>跨域头部字段。</li>
</ol>
<h2 id="get和post区别"><a href="#get和post区别" class="headerlink" title="get和post区别"></a>get和post区别</h2><ol>
<li>本质：获取资源、增删改资源</li>
<li>缓存：get可以强制缓存、协商缓存</li>
<li>幂等：get是幂等的、post不是</li>
<li>请求体：get请求有长度限制，编码只能是url编码；post请求可以放在请求体，编码格式多种。</li>
</ol>
<h2 id="强制缓存和协商缓存"><a href="#强制缓存和协商缓存" class="headerlink" title="强制缓存和协商缓存"></a>强制缓存和协商缓存</h2><h2 id="http1-1优缺点（和http1-0区别）"><a href="#http1-1优缺点（和http1-0区别）" class="headerlink" title="http1.1优缺点（和http1.0区别）"></a>http1.1优缺点（和http1.0区别）</h2><p>优点：</p>
<ol>
<li>长连接</li>
<li>局部请求</li>
<li>增加了状态码</li>
<li>缓存字段升级</li>
<li>host字段：解决一个ip地址对应多个域名情况</li>
</ol>
<p>缺点：</p>
<ol>
<li>无状态 &#x3D;&gt; token&#x2F;session+cookie</li>
<li>安全性</li>
</ol>
<h2 id="https优缺点"><a href="#https优缺点" class="headerlink" title="https优缺点"></a>https优缺点</h2><!-- 先进行TCP三次握手再进行TLS四次握手 -->
<p>优点：</p>
<ol>
<li>加密传输：非对称加密协商会话密钥，通信内容经过会话密钥加密。</li>
<li>防止内容篡改：摘要算法计算出hash值，对hash值和内容用私钥签名；客户端用公钥解密，摘要算法计算新的hash对比，没变化则说明内容没被篡改。（私钥签名是为了防止内容和hash值一同被篡改）</li>
<li>身份认证：服务端公钥经过CA私钥签名生成数字证书；客户端浏览器或操作系统内置了CA的公钥，解开数字证书后获取公钥</li>
</ol>
<h2 id="非对称加密和对称加密"><a href="#非对称加密和对称加密" class="headerlink" title="非对称加密和对称加密"></a>非对称加密和对称加密</h2><ol>
<li>非对称加密：有公钥和私钥，可以传输公钥而私钥保密，解决了密钥交换问题但速度慢。</li>
<li>对称加密：只有一个会话密钥，必须保密，加密解密速度快但不能解决密钥交换。</li>
</ol>
<h1 id="11-24"><a href="#11-24" class="headerlink" title="11.24"></a>11.24</h1><h2 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h2><h2 id="TLS握手过程"><a href="#TLS握手过程" class="headerlink" title="TLS握手过程"></a>TLS握手过程</h2><h2 id="数字证书验证-10024"><a href="#数字证书验证-10024" class="headerlink" title="数字证书验证 &#10024;"></a>数字证书验证 &#10024;</h2><ul>
<li>CA对公钥、有效时间、颁发者等信息进行hash运算，通过私钥签名生成数字证书。客户端拿到数字证书后用内置的公钥解密，计算hash值对比，相同则说明身份是正确的。</li>
</ul>
<h2 id="证书信任链"><a href="#证书信任链" class="headerlink" title="证书信任链"></a>证书信任链</h2><ul>
<li>根证书信任了某些中间证书用私钥加密，中间证书给服务器公钥颁发数字证书。</li>
<li>我们可以先用根证书的公钥验证中间证书 &#x3D;》 获取中间证书的公钥；再去验证服务器的数字证书。</li>
</ul>
<h2 id="https缺点-1"><a href="#https缺点-1" class="headerlink" title="https缺点"></a>https缺点</h2><p>1.<br>2.<br>3. 成本问题<br>4. 安全问题</p>
<h2 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h2><h2 id="DH、DHE、ECDHE算法"><a href="#DH、DHE、ECDHE算法" class="headerlink" title="DH、DHE、ECDHE算法"></a>DH、DHE、ECDHE算法</h2><h2 id="压缩css类名"><a href="#压缩css类名" class="headerlink" title="压缩css类名"></a>压缩css类名</h2><ul>
<li>要复习set、map语法</li>
<li>闭包思想</li>
<li>fromCharCode API</li>
</ul>
<h1 id="11-25"><a href="#11-25" class="headerlink" title="11.25"></a>11.25</h1><h2 id="RSA算法难题"><a href="#RSA算法难题" class="headerlink" title="RSA算法难题"></a>RSA算法难题</h2><ul>
<li>基于大整数难分解的数学难题。攻击者拿到大整数n、公钥，很难计算大整数n的欧拉函数，因为很难把其拆分成两个质数。但我们私钥计算时候依赖大整数的欧拉函数。</li>
</ul>
<h2 id="set和map原理-10024-1"><a href="#set和map原理-10024-1" class="headerlink" title="set和map原理 &#10024;"></a>set和map原理 &#10024;</h2><ul>
<li>七个数据类型 + object经过hash值处理运算，对应到0-7八个数字；有个长为8的数组，数组每个元素对应一个数据类型，数组每个元素是链表结构存储相同数据类型的不同值。</li>
</ul>
<h2 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h2><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><h2 id="平衡二叉树高度-10024"><a href="#平衡二叉树高度-10024" class="headerlink" title="平衡二叉树高度 &#10024;"></a>平衡二叉树高度 &#10024;</h2><p><img src="/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.%E7%A7%8B%E6%8B%9B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-1.png" srcset="/img/loading.gif" lazyload alt="alt text"></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h1 id="11-26"><a href="#11-26" class="headerlink" title="11.26"></a>11.26</h1><h2 id="如何判断需求复杂度-1"><a href="#如何判断需求复杂度-1" class="headerlink" title="如何判断需求复杂度"></a>如何判断需求复杂度</h2><ol>
<li><strong>功能逻辑</strong>：需要的功能越多，业务逻辑越复杂，该需求复杂度越高。</li>
<li><strong>交互逻辑</strong>：丰富的交互体验，比如：拖拉拽、复杂的表单数据校验。</li>
<li><strong>接口数量</strong>：接口数量多、数据依赖复杂，调试成本高。</li>
<li><strong>需求变化</strong>：需求变化是否影响代码的复用性和扩展性，是否需要拆分成多个公共组件等等。</li>
</ol>
<h2 id="开放题：实现可视化报表，前端考虑哪些？-10024-1"><a href="#开放题：实现可视化报表，前端考虑哪些？-10024-1" class="headerlink" title="开放题：实现可视化报表，前端考虑哪些？ &#10024;"></a>开放题：实现可视化报表，前端考虑哪些？ &#10024;</h2><ol>
<li><p>需求分析：<br>数据来源：数据格式、接口、频率。<br>展示内容：维度、排序、拖拽功能。<br>展示形式：表格、柱状图、折线图。</p>
</li>
<li><p>数据处理：<br>数据格式化：转换为图表、表格需要的格式数据。<br>数据清洗：处理空值、异常值<br>数据缓存：本地缓存</p>
</li>
<li><p>设计实现：<br>技术选型：echarts、组件库。<br>样式上：响应式设计，颜色、字体风格<br>交互：excel导出、选取参数更改表格（一天内、七天内）、拖拽。</p>
</li>
<li><p>优化<br>分页<br>按需加载<br>虚拟列表<br>导出用webworker</p>
</li>
</ol>
<h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><ul>
<li>线程之间谦让资源，但都不执行。</li>
<li>当多线程中出现了相互谦让，都主动将资源释放给别的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="堆-9997"><a href="#堆-9997" class="headerlink" title="堆 &#9997;"></a>堆 &#9997;</h2><ul>
<li><strong>堆是一个完全二叉树</strong>：只允许最后一行不为满，且从左到右排列。</li>
<li><strong>堆序性</strong>：小根堆，大根堆。</li>
<li><strong>堆的基本操作</strong>：上滤、下滤。复杂度为O(logn).</li>
<li><strong>建堆的方法</strong>：<br>自顶向下建堆法（插入堆、上滤：复杂度O(nlogn)：插入一个元素上滤<br>自下而上建堆法（先建个堆、下滤：复杂度O(n)）：从倒数第二行开始下滤<br><strong>！下滤时候与较大的子节点交换！</strong></li>
</ul>
<h1 id="11-27"><a href="#11-27" class="headerlink" title="11.27"></a>11.27</h1><h2 id="排序算法时间、空间复杂度"><a href="#排序算法时间、空间复杂度" class="headerlink" title="排序算法时间、空间复杂度"></a>排序算法时间、空间复杂度</h2><ol>
<li>快速排序：nlogn n2&#x2F; nlogn</li>
<li>冒泡排序：n2 n  &#x2F; 1</li>
<li>选择排序 n2 &#x2F; 1</li>
<li>插入排序：n2 n&#x2F; 1</li>
<li>归并排序：nlogn &#x2F; n</li>
</ol>
<h2 id="js的sort方法"><a href="#js的sort方法" class="headerlink" title="js的sort方法"></a>js的sort方法</h2><ul>
<li>快速排序和插入排序的结合</li>
<li>n &lt; 10，插入排序：平均时间复杂度是n2，但理想情况可到n，优于nlogn。</li>
<li>n &gt; 10，快速排序，时间复杂度nlogn。</li>
</ul>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul>
<li>自下而上建堆法：不是nlogn，因为不是每个节点都要下滤到底部，只要最上面一个节点下滤到底部需要logn次操作，所以复杂度为O（n）。</li>
<li>建立成大根堆后，叶子节点和根节点交换，最大节点到最底层；然后下滤，倒数第二大节点到根节点，交换叶子节点。循环交换和下滤的过程。O（nlogn）。</li>
</ul>
<!--
两者时间复杂度区别：
建堆时候：大部分节点下滤一两次，只有最上面下滤logn次。
排序时候：所有节点都要交换到根节点然后下滤，大部分节点下滤logn次。
 -->

<h2 id="压缩css类名-1"><a href="#压缩css类名-1" class="headerlink" title="压缩css类名"></a>压缩css类名</h2><ol>
<li>闭包，记录index值和映射关系。</li>
<li>除以26，类似26进制。</li>
</ol>
<h2 id="fromCharCode"><a href="#fromCharCode" class="headerlink" title="fromCharCode"></a>fromCharCode</h2><p>fromCharCode() 可接受一个指定的 Unicode 值，然后返回一个字符串。</p>
<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><h2 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h2><ul>
<li>深度搜索</li>
<li>广度搜索</li>
</ul>
<h2 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById"></a>getElementById</h2><h1 id="11-28"><a href="#11-28" class="headerlink" title="11.28"></a>11.28</h1><h2 id="js基础复习"><a href="#js基础复习" class="headerlink" title="js基础复习"></a>js基础复习</h2><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><ul>
<li>扩展、拷贝。</li>
<li>数组合并（别用concat了）</li>
</ul>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><ul>
<li>提取变量：解构后，赋值。</li>
</ul>
<h2 id="map和object区别"><a href="#map和object区别" class="headerlink" title="map和object区别"></a>map和object区别</h2><ul>
<li>map键有顺序、无额外值（原型对象）、完整的键值对、可遍历的。</li>
</ul>
<h2 id="JSON-stringify-10024"><a href="#JSON-stringify-10024" class="headerlink" title="JSON.stringify &#10024;"></a>JSON.stringify &#10024;</h2><ol>
<li>数组、undefined、函数、NaN、Infinity、symbol都是null</li>
<li>循环引用报错</li>
<li>不可遍历属性不能转换</li>
</ol>
<h2 id="encodeURI、encodeURIComponent-10024"><a href="#encodeURI、encodeURIComponent-10024" class="headerlink" title="encodeURI、encodeURIComponent &#10024;"></a>encodeURI、encodeURIComponent &#10024;</h2><ol>
<li>encode URI：对整体uri转义（比如：中文、空格），但不会转换特殊字符（比如：&amp; ？ ： &#x2F;）</li>
<li>encodeURIComponent：对所有进行转义,如果我们参数里面有（&amp; ？ ： &#x2F;避免其影响url解析，就要用这个）</li>
</ol>
<h2 id="为什么要用axios而不用原生的xhr或者fetch-10024-2"><a href="#为什么要用axios而不用原生的xhr或者fetch-10024-2" class="headerlink" title="为什么要用axios而不用原生的xhr或者fetch &#10024;"></a>为什么要用axios而不用原生的xhr或者fetch &#10024;</h2><ol>
<li>简洁的API：axios基于promise封装，避免xhr复杂的回调逻辑&#x2F;</li>
<li>更好的错误处理：fetch不会将http错误码400、500抛出，需要手动抛出；axios会自动抛出。</li>
<li>请求拦截器、错误拦截器</li>
<li>自动序列化数据：JSON.stringify、解析数据。</li>
<li>版本：fetch兼容性更差。</li>
<li>更方便的请求配置：baseURL、超时设置。</li>
</ol>
<ul>
<li>下午复习完js基础+原型链（速过）深搜、广搜、腐烂的橘子</li>
</ul>
<h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><ul>
<li>默认是一个空的Object对象，存放共有属性和方法，减少内存。</li>
<li>不是所有函数都有原型对象，箭头函数、bind返回的函数</li>
</ul>
<h2 id="原型上的方法this指向-10024"><a href="#原型上的方法this指向-10024" class="headerlink" title="原型上的方法this指向 &#10024;"></a>原型上的方法this指向 &#10024;</h2><ul>
<li>指向实例对象，不是原型对象！</li>
</ul>
<h2 id="Function-proto-Function-prototype鸡蛋问题-10024"><a href="#Function-proto-Function-prototype鸡蛋问题-10024" class="headerlink" title="Function.proto &#x3D;&#x3D;&#x3D; Function.prototype鸡蛋问题 &#10024;"></a>Function.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Function.prototype鸡蛋问题 &#10024;</h2><ul>
<li>两者指向同一地址，先有prototype再有__proto__.</li>
<li>Function在任何引擎执行代码前就已经在内存中。先有的原型链顶层Object.prototype，继承该对象有了Function.prototype，然后将Function原型对象指向Function.prototype.其它构造函数继承Function.prototype产生。</li>
</ul>
<h1 id="11-29"><a href="#11-29" class="headerlink" title="11.29"></a>11.29</h1><h2 id="js看完，看部分es6"><a href="#js看完，看部分es6" class="headerlink" title="js看完，看部分es6."></a>js看完，看部分es6.</h2><h2 id="为什么变量提升？"><a href="#为什么变量提升？" class="headerlink" title="为什么变量提升？"></a>为什么变量提升？</h2><ul>
<li>预解析阶段，创建执行上下文，词法环境（对外部环境的引用）；代码开始执行后，会去作用域链查找对应的值。</li>
</ul>
<h2 id="编译性语言和解释性语言"><a href="#编译性语言和解释性语言" class="headerlink" title="编译性语言和解释性语言"></a>编译性语言和解释性语言</h2><ul>
<li>编译性语言：编译代码为机器码，后续运行使用同一编译结果即可。执行效率高，但依赖编译器跨平台性差。</li>
<li>解释性语言：解释器边转换代码边执行，没有编译过程。跨平台性好。</li>
</ul>
<h2 id="执行上下文-1"><a href="#执行上下文-1" class="headerlink" title="执行上下文"></a>执行上下文</h2><h2 id="作用域-1"><a href="#作用域-1" class="headerlink" title="作用域"></a>作用域</h2><h2 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h2><h2 id="this指向-1"><a href="#this指向-1" class="headerlink" title="this指向"></a>this指向</h2><h2 id="call和apply区别"><a href="#call和apply区别" class="headerlink" title="call和apply区别"></a>call和apply区别</h2><h1 id="11-30"><a href="#11-30" class="headerlink" title="11.30"></a>11.30</h1><!-- 不知不觉11月最后一天了，offer在哪一天？ -->


<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h2 id="promise中断请求"><a href="#promise中断请求" class="headerlink" title="promise中断请求"></a>promise中断请求</h2><ul>
<li>promise.race，只有一个promise结果可以返回，获取请求promise的reject函数，在另一个promise（一直是pending状态）调用该reject。</li>
</ul>
<h2 id="异步编程代码输出题"><a href="#异步编程代码输出题" class="headerlink" title="异步编程代码输出题"></a>异步编程代码输出题</h2><ul>
<li>如果async函数中抛出了错误，就会终止错误结果，不会继续向下执行。除非用try catch或者catch回调捕捉错误。</li>
<li>注意setTimeout时间，不一定都是0s。</li>
</ul>
<h2 id="settimeout"><a href="#settimeout" class="headerlink" title="settimeout"></a>settimeout</h2><h2 id="this代码输出题目"><a href="#this代码输出题目" class="headerlink" title="this代码输出题目"></a>this代码输出题目</h2><h1 id="12-1"><a href="#12-1" class="headerlink" title="12.1"></a>12.1</h1><!-- 十二月咯 -->
<h2 id="作用域代码输出题"><a href="#作用域代码输出题" class="headerlink" title="作用域代码输出题"></a>作用域代码输出题</h2><ul>
<li>思路要清晰</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n, o)</span></span> &#123;<br>  console.log(o)<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span>: <span class="hljs-title">function</span><span class="hljs-params">(m)</span></span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(m, n)</span></span>;<br>    &#125;<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;  a.<span class="hljs-keyword">fun</span>(<span class="hljs-number">1</span>);  a.<span class="hljs-keyword">fun</span>(<span class="hljs-number">2</span>);  a.<span class="hljs-keyword">fun</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>.<span class="hljs-keyword">fun</span>(<span class="hljs-number">1</span>).<span class="hljs-keyword">fun</span>(<span class="hljs-number">2</span>).<span class="hljs-keyword">fun</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> c = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>.<span class="hljs-keyword">fun</span>(<span class="hljs-number">1</span>);  c.<span class="hljs-keyword">fun</span>(<span class="hljs-number">2</span>);  c.<span class="hljs-keyword">fun</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>
<h2 id="js的离谱转换"><a href="#js的离谱转换" class="headerlink" title="js的离谱转换"></a>js的离谱转换</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">f = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;   <br>g = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;   <br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;   <br>   <span class="hljs-keyword">if</span> (g() &amp;&amp; [] == ![]) &#123;   <br>      f = <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;   <br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;   <br>   &#125;   <br>&#125;)();   <br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(f());<br></code></pre></td></tr></table></figure>

<h2 id="var-1"><a href="#var-1" class="headerlink" title="var"></a>var</h2><ul>
<li>没有声明符的变量，就是全局变量。</li>
<li>var的变量提升。</li>
</ul>
<h2 id="原型链代码输出题"><a href="#原型链代码输出题" class="headerlink" title="原型链代码输出题"></a>原型链代码输出题</h2><h2 id="原型上的方法this指向-10024-1"><a href="#原型上的方法this指向-10024-1" class="headerlink" title="原型上的方法this指向 &#10024;"></a>原型上的方法this指向 &#10024;</h2><ul>
<li>如果是原型链自己查找的，指向对象本身。</li>
<li>如果显性写出来，是原型对象。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(a)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.a = a;<br>&#125;<br><span class="hljs-keyword">fun</span>.prototype = &#123;<br>    a: <span class="hljs-number">9999</span>,<br>    f()&#123;<br>    console.log(<span class="hljs-keyword">this</span>);<br>    console.log(<span class="hljs-keyword">this</span>.a);<br>    &#125;            <br>&#125;<br>let fn = new <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">123</span>)</span></span>;<br>fn.f(); <span class="hljs-comment">// this指向fn本身。</span><br>fn.__proto__.f(); <span class="hljs-comment">// this指向原型对象。</span><br></code></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li>原型链继承</li>
<li>盗用构造函数</li>
<li>组合继承</li>
<li>原型式继承</li>
<li>寄生式继承</li>
<li>寄生组合继承</li>
</ol>
<h2 id="垃圾回收机制-1"><a href="#垃圾回收机制-1" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><h1 id="12-02"><a href="#12-02" class="headerlink" title="12.02"></a>12.02</h1><h2 id="Object-create是浅拷贝"><a href="#Object-create是浅拷贝" class="headerlink" title="Object.create是浅拷贝"></a>Object.create是浅拷贝</h2><ul>
<li>如果父构造函数原型对象改变，会影响到子构造函数原型对象。</li>
<li>理解错误纠正点：子构造函数改变不会影响父构造函数，因为父构造函数是子构造函数的__proto__属性，两者隔了一层。</li>
</ul>
<h2 id="作用域链和执行上下文"><a href="#作用域链和执行上下文" class="headerlink" title="作用域链和执行上下文"></a>作用域链和执行上下文</h2><ul>
<li>理解错误纠正点：当代码解析到函数定义时候，外层的执行上下文是已经创建好了的，所以解析到函数定义时候预创建作用域链是合理的。</li>
</ul>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ul>
<li>注意查找原型链是去proto上面去找，不要因为构造函数被误导去prototype上去找了。</li>
</ul>
<h2 id="总结一道题"><a href="#总结一道题" class="headerlink" title="总结一道题"></a>总结一道题</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function Parent() &#123;<br>    <span class="hljs-keyword">this</span>.a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">this</span>.b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-keyword">this</span>.a];<br>    <span class="hljs-keyword">this</span>.c = &#123; demo: <span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-keyword">this</span>.show = function () &#123;<br>        console.log(<span class="hljs-keyword">this</span>.a , <span class="hljs-keyword">this</span>.b , <span class="hljs-keyword">this</span>.c.demo );<br>    &#125;<br>&#125;<br><br>function Child() &#123;<br>    <span class="hljs-keyword">this</span>.a = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">this</span>.change = function () &#123;<br>        <span class="hljs-keyword">this</span>.b.push(<span class="hljs-keyword">this</span>.a);<br>        <span class="hljs-keyword">this</span>.a = <span class="hljs-keyword">this</span>.b.length;<br>        <span class="hljs-keyword">this</span>.c.demo = <span class="hljs-keyword">this</span>.a++;<br>    &#125;<br>&#125;<br><br>Child.prototype = new Parent();<br><span class="hljs-keyword">var</span> parent = new Parent();<br><span class="hljs-keyword">var</span> child1 = new Child();<br><span class="hljs-keyword">var</span> child2 = new Child();<br>child1.a = <span class="hljs-number">11</span>;<br>child2.a = <span class="hljs-number">12</span>;<br>parent.show();<br>child1.show();<br>child2.show();<br>child1.change();<br>child2.change();<br>parent.show();<br>child1.show();<br>child2.show();<br><br><span class="hljs-number">1.</span> 创建两个Parent实例，一个实例为子构造函数的原型对象，子构造函数共享这个实例的数据。（原型链继承）<br><span class="hljs-number">2.</span>  <br></code></pre></td></tr></table></figure>

<h2 id="MVC-MVVM-MVP-1"><a href="#MVC-MVVM-MVP-1" class="headerlink" title="MVC MVVM MVP"></a>MVC MVVM MVP</h2><ol>
<li><em><strong>MVC观察者模式model可直接到view</strong></em>:采用了<strong>观察者模式</strong>,数据更改立即通知页面更新.数据和页面有一定耦合性.页面更改时,会触发controller来控制model层数据更新.</li>
<li><em><strong>MVP</strong></em>:view和model都需要经过中间处理.</li>
<li><em><strong>MVVM</strong></em>:VM对P的升级,将手动的   数据更改&#x3D;&gt;页面 操作自动化.降低代码复杂度</li>
</ol>
<h2 id="URLSearchParams-9997"><a href="#URLSearchParams-9997" class="headerlink" title="URLSearchParams &#9997;"></a>URLSearchParams &#9997;</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42289279/article/details/134157803">https://blog.csdn.net/weixin_42289279/article/details/134157803</a></li>
</ul>
<ol>
<li>size：参数个数</li>
<li><strong>get、getAll</strong></li>
<li><strong>有迭代器，for…of 可以遍历</strong></li>
<li>has、set、delete、append</li>
<li>toString</li>
</ol>
<h2 id="new-URL-9997"><a href="#new-URL-9997" class="headerlink" title="new URL &#9997;"></a>new URL &#9997;</h2><ul>
<li>将url字符串构造解析为一个URL对象，方便获取&#x2F;操作url的部分，也可以修改后toString返回新的url。</li>
</ul>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">const</span> <span class="hljs-built_in">url</span> = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&#x27;https://example.com/path?name=John#section&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">url</span>.protocol); <span class="hljs-comment">// &#x27;https:&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">url</span>.hostname); <span class="hljs-comment">// &#x27;example.com&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">url</span>.pathname); <span class="hljs-comment">// &#x27;/path&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">url</span>.search);   <span class="hljs-comment">// &#x27;?name=John&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">url</span>.hash);     <span class="hljs-comment">// &#x27;#section&#x27;</span><br></code></pre></td></tr></table></figure>

<h2 id="不同地点访问同一个url区别-9997-1"><a href="#不同地点访问同一个url区别-9997-1" class="headerlink" title="不同地点访问同一个url区别 &#9997;"></a>不同地点访问同一个url区别 &#9997;</h2><ol>
<li>缓存</li>
<li>ip地址不同，路由器转发，交换机转发经过的网络路径不同。</li>
<li>网速不同，获取资源速度不同。</li>
</ol>
<h2 id="手撕：如何进入if语句"><a href="#手撕：如何进入if语句" class="headerlink" title="手撕：如何进入if语句"></a>手撕：如何进入if语句</h2><!-- 下午:看mvvm、mvc、mvp；看一道手写代码题目。三点一十前搞完 -->

<h1 id="12-5"><a href="#12-5" class="headerlink" title="12.5"></a>12.5</h1><ul>
<li>投好未来，复习js手写js。复习vue。</li>
</ul>
<h2 id="遍历器"><a href="#遍历器" class="headerlink" title="遍历器"></a>遍历器</h2><h2 id="for-in-for-of遍历数组"><a href="#for-in-for-of遍历数组" class="headerlink" title="for in &#x2F; for of遍历数组"></a>for in &#x2F; for of遍历数组</h2><ul>
<li>for in 是遍历数组键名也就是下标01234。还会遍历原型对象上添加的属性。</li>
<li>for of 是遍历数组的值。for of是调用遍历器对象。</li>
</ul>
<!-- for in遍历对象也是对象的键值，因为数组也是01234为键名，所有for in遍历数组是01234的下标 -->

<h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><ul>
<li>就是键为数字的对象，还有个length属性</li>
</ul>
<h2 id="手撕：解析url参数"><a href="#手撕：解析url参数" class="headerlink" title="手撕：解析url参数"></a>手撕：解析url参数</h2><h2 id="手撕：如何进入if语句-1"><a href="#手撕：如何进入if语句-1" class="headerlink" title="手撕：如何进入if语句"></a>手撕：如何进入if语句</h2><h2 id="手撕：vue双向数据绑定"><a href="#手撕：vue双向数据绑定" class="headerlink" title="手撕：vue双向数据绑定"></a>手撕：vue双向数据绑定</h2><h2 id="理解双向数据绑定和vue区别"><a href="#理解双向数据绑定和vue区别" class="headerlink" title="理解双向数据绑定和vue区别"></a>理解双向数据绑定和vue区别</h2><h2 id="string的replace方法-10024"><a href="#string的replace方法-10024" class="headerlink" title="string的replace方法 &#10024;"></a>string的replace方法 &#10024;</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46658751/article/details/123390095">https://blog.csdn.net/qq_46658751/article/details/123390095</a></li>
</ul>
<ol>
<li>replace(字符串，字符串)，只能替换一次</li>
<li>replace（正则&#x2F;g，字符串）多次替换</li>
<li>replace（正则，函数）核心用法，函数第一个参数是匹配到的子串，第二个是起始索引，第三个是字符串本身。如果有捕获器的值则插入在第二个参数，起始索引变第三个参数，字符串本身变第四个参数。</li>
</ol>
<h2 id="捕获器"><a href="#捕获器" class="headerlink" title="捕获器"></a>捕获器</h2><ul>
<li>在匹配时候将正则表达式匹配的部分内容保留下来，以便后续使用。</li>
<li>使用 圆括号 () 来定义捕获组。捕获组会将括号内匹配的内容保存起来。</li>
</ul>
<h2 id="手撕：模板字符串"><a href="#手撕：模板字符串" class="headerlink" title="手撕：模板字符串"></a>手撕：模板字符串</h2><h2 id="promise任务调度器"><a href="#promise任务调度器" class="headerlink" title="promise任务调度器"></a>promise任务调度器</h2><h1 id="12-6"><a href="#12-6" class="headerlink" title="12.6"></a>12.6</h1><h2 id="垃圾回收机制-10024"><a href="#垃圾回收机制-10024" class="headerlink" title="垃圾回收机制 &#10024;"></a>垃圾回收机制 &#10024;</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7280787122016059426">https://juejin.cn/post/7280787122016059426</a></li>
</ul>
<ol>
<li>js为对象、变量、函数分配内存，当不再使用这些值时候，垃圾回收机制会收回对应的内存。</li>
<li>全局变量、局部变量，全局变量要等页面卸载才会回收，局部变量等函数执行完毕退出执行栈时候回收；特殊情况：闭包下不会回收函数执行上下文的词法环境。</li>
<li>引用计数</li>
<li>标记清除</li>
<li>分代回收：根据生命周期分为新旧生代，旧生代采用标记清除。新生代有from to两个空间，刚进来变量放在from里，from满之后进行标记清除，剩下的变量放到to中；然后to变成from，from变成to，重复上述过程。</li>
<li>闲时收集：CPU空闲时候才进行垃圾回收。</li>
</ol>
<h2 id="手写并发请求-1"><a href="#手写并发请求-1" class="headerlink" title="手写并发请求"></a>手写并发请求</h2><h2 id="手写进度条"><a href="#手写进度条" class="headerlink" title="手写进度条"></a>手写进度条</h2><h2 id="requestAnimationFrame-10024"><a href="#requestAnimationFrame-10024" class="headerlink" title="requestAnimationFrame &#10024;"></a>requestAnimationFrame &#10024;</h2><ol>
<li>60HZ &#x3D;&gt; 1s刷新60次 &#x3D;&gt; 1000ms&#x2F;60 &#x3D; 16.67ms 刷新一次</li>
<li>解决setTimeout时间不稳定情况：是推入到宏任务等待执行，还有微任务同步任务执行时间的误差。</li>
<li><strong>该api不由js控制，由系统时间间隔控制，时间间隔固定是16.67ms。</strong></li>
</ol>
<h2 id="DocumentFragments-10024"><a href="#DocumentFragments-10024" class="headerlink" title="DocumentFragments &#10024;"></a>DocumentFragments &#10024;</h2><ol>
<li>DocumentFragments 是 DOM 节点。它们不是主 DOM 树的一部分。通常的用例是创建文档片段，元素附加到文档片段，然后将文档片段附加到 DOM 树。</li>
<li>文档片段存在于内存中，并不在 DOM 树中，所以将子元素插入到文档片段时不会引起页面回流</li>
</ol>
<h2 id="渲染万条数据"><a href="#渲染万条数据" class="headerlink" title="渲染万条数据"></a>渲染万条数据</h2><ul>
<li>文档碎片减少<strong>回流</strong></li>
<li>动画帧<strong>拆分任务</strong></li>
<li>将一个大任务拆分成多个小任务，每个小任务是创建文档碎片，将一次性渲染的dom节点添加到文档碎片中，这个小任务在动画帧中执行，也就是每次重绘前执行。优化dom操作：通过文档碎片，减少dom树更改；优化渲染：通过动画帧，每次重绘前将新增的dom节点添加到dom树中。</li>
</ul>
<h1 id="12-7"><a href="#12-7" class="headerlink" title="12.7"></a>12.7</h1><h2 id="any和unkown区别"><a href="#any和unkown区别" class="headerlink" title="any和unkown区别"></a>any和unkown区别</h2><h2 id="interface接口和类区别"><a href="#interface接口和类区别" class="headerlink" title="interface接口和类区别"></a>interface接口和类区别</h2><h2 id="js和ts区别"><a href="#js和ts区别" class="headerlink" title="js和ts区别"></a>js和ts区别</h2><ol>
<li>后缀 执行速度</li>
<li>ts是超集</li>
<li>强类型语言，弱类型语言</li>
<li>编译时检测错误</li>
<li>泛型、接口、模块化</li>
</ol>
<h2 id="枚举类型-1"><a href="#枚举类型-1" class="headerlink" title="枚举类型"></a>枚举类型</h2><h2 id="接口定义函数类型"><a href="#接口定义函数类型" class="headerlink" title="接口定义函数类型"></a>接口定义函数类型</h2><p>interface SeachObj{<br>  (name:string, age: number) &#x3D;&gt; string;<br>}</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h2 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h2><h2 id="函数理解"><a href="#函数理解" class="headerlink" title="函数理解"></a>函数理解</h2><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="高级类型-1"><a href="#高级类型-1" class="headerlink" title="高级类型"></a>高级类型</h2><h2 id="as-const"><a href="#as-const" class="headerlink" title="as const"></a>as const</h2><p>as const 使得对象中的字符串值保持为字面量类型，而不是宽泛的 string 类型，从而能在后续的类型推断中提供更严格的类型信息。</p>
<h2 id="typeof作用"><a href="#typeof作用" class="headerlink" title="typeof作用"></a>typeof作用</h2><h2 id="returnType-1"><a href="#returnType-1" class="headerlink" title="returnType"></a>returnType</h2><h2 id="parameters"><a href="#parameters" class="headerlink" title="parameters"></a>parameters</h2><h2 id="patical-2"><a href="#patical-2" class="headerlink" title="patical"></a>patical</h2><h2 id="required"><a href="#required" class="headerlink" title="required"></a>required</h2><h2 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h2><h2 id="联合类型的分配"><a href="#联合类型的分配" class="headerlink" title="联合类型的分配"></a>联合类型的分配</h2><ul>
<li>当条件类型（extends）应用于 联合类型 时，TypeScript 会将联合类型中的每个成员逐个进行判断，而不是一次性地判断整个联合类型。</li>
</ul>
<h2 id="exclude-extract"><a href="#exclude-extract" class="headerlink" title="exclude extract"></a>exclude extract</h2><h2 id="omit-pick"><a href="#omit-pick" class="headerlink" title="omit pick"></a>omit pick</h2><h2 id="算法题：最长不重复子串"><a href="#算法题：最长不重复子串" class="headerlink" title="算法题：最长不重复子串"></a>算法题：最长不重复子串</h2><h1 id="12-8"><a href="#12-8" class="headerlink" title="12.8"></a>12.8</h1><h2 id="蓝眼睛问题"><a href="#蓝眼睛问题" class="headerlink" title="蓝眼睛问题"></a>蓝眼睛问题</h2><ol>
<li>一个蓝眼睛看其他人没有蓝眼睛，第一天离开。</li>
<li>两个蓝眼睛，看有其他蓝眼睛第一天不离开，第二天发现他没离开说明不止一个蓝眼睛，而自己看其他人都不是蓝眼睛，所以自己离开。</li>
<li>三个蓝眼睛，第二天过后发现这两个蓝眼睛都没离开，说明不止两个蓝眼睛，看其他人都不是蓝眼睛，所以自己离开。</li>
<li>以此类推，k个蓝眼睛，第k天全部离开。</li>
</ol>
<h2 id="交叉类型冲突"><a href="#交叉类型冲突" class="headerlink" title="交叉类型冲突"></a>交叉类型冲突</h2><ol>
<li>直接报错</li>
<li>解决办法：用any，联合类型</li>
</ol>
<h2 id="算法题：最长连续序列"><a href="#算法题：最长连续序列" class="headerlink" title="算法题：最长连续序列"></a>算法题：最长连续序列</h2><h2 id="算法题：字母异位词分组"><a href="#算法题：字母异位词分组" class="headerlink" title="算法题：字母异位词分组"></a>算法题：字母异位词分组</h2><h2 id="算法题：数组中第k大的数（还要整理）"><a href="#算法题：数组中第k大的数（还要整理）" class="headerlink" title="算法题：数组中第k大的数（还要整理）"></a>算法题：数组中第k大的数（还要整理）</h2><h2 id="loader、plugin"><a href="#loader、plugin" class="headerlink" title="loader、plugin"></a>loader、plugin</h2><h2 id="webpack功能"><a href="#webpack功能" class="headerlink" title="webpack功能"></a>webpack功能</h2><ol>
<li>编译代码能力，解析es6，解决浏览器兼容</li>
<li>模块整合能力，将多个模块整合为一个文件，减少浏览器请求</li>
<li>万物皆可模块化，支持不同种类的模块类型。</li>
</ol>
<h2 id="webpack构建流程-1"><a href="#webpack构建流程-1" class="headerlink" title="webpack构建流程"></a>webpack构建流程</h2><h2 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h2><h2 id="优化webpack打包速度"><a href="#优化webpack打包速度" class="headerlink" title="优化webpack打包速度"></a>优化webpack打包速度</h2><ul>
<li><a target="_blank" rel="noopener" href="https://chatgpt.com/c/675593b5-4a54-800f-944b-f14fabacdd0c">https://chatgpt.com/c/675593b5-4a54-800f-944b-f14fabacdd0c</a></li>
</ul>
<ol>
<li>cache-loader</li>
<li>terser plugin开启多线程</li>
<li>loader不作用node-module，excude、include优化loader</li>
<li>dll plugin 公共模块提取出来，直接引入</li>
</ol>
<h1 id="12-9"><a href="#12-9" class="headerlink" title="12.9"></a>12.9</h1><ul>
<li>上午+下午部分时间：webpack、vite，下午多刷题。</li>
<li>晚上：开始vue</li>
</ul>
<h2 id="loader、plugin-1"><a href="#loader、plugin-1" class="headerlink" title="loader、plugin"></a>loader、plugin</h2><h2 id="webpack构建流程-2"><a href="#webpack构建流程-2" class="headerlink" title="webpack构建流程"></a>webpack构建流程</h2><h2 id="优化webpack构建速度"><a href="#优化webpack构建速度" class="headerlink" title="优化webpack构建速度"></a>优化webpack构建速度</h2><ol>
<li>cache-loader</li>
<li>多线程loader</li>
<li>exclude</li>
<li>dllplugin</li>
<li>代码分割</li>
</ol>
<h2 id="如何减少打包体积"><a href="#如何减少打包体积" class="headerlink" title="如何减少打包体积"></a>如何减少打包体积</h2><ol>
<li>tree-shaking：剔除没用的代码部分。</li>
<li>删除不必要的依赖：开发依赖下载到开发中</li>
<li>按需引入：组件库对应的插件，不要引入所有组件</li>
<li>图片压缩：image-webpack-plugin</li>
<li>js：terser-plugin，webpack5自带，压缩css，删除空格注释，变量名简写</li>
<li>css压缩</li>
</ol>
<h2 id="热模块更新"><a href="#热模块更新" class="headerlink" title="热模块更新"></a>热模块更新</h2><ol>
<li>客户端和服务端建立websocket连接</li>
<li>webpack检测到变化后重新编译对应的模块</li>
<li>通过websocket传递新模块的hash值</li>
<li>浏览器用hash请求更新的mokuai</li>
<li>浏览器更新</li>
</ol>
<h2 id="vite-和-webpack区别"><a href="#vite-和-webpack区别" class="headerlink" title="vite 和 webpack区别"></a>vite 和 webpack区别</h2><ol>
<li>快速冷启动：vite启动开发服务器，不会进行打包，利用es模块特性，请求对应的模块才对对应的模块处理为esm格式返回；webpack需要进行完整的打包生命周期。</li>
<li>热模块更新：vite直接通知浏览器重新请求更新的模块，然后返回对应的模块；webpack需要先重新编译，然后再通知浏览器。</li>
<li>http2：vite利用http2，请求文件可以为多个小文件，请求速度更快；vite也有强制缓存和协商缓存。</li>
<li>线程：vite是go编写，可以利用多线程；webpack是nodejs编写，利用多线程需要插件。</li>
</ol>
<h2 id="vite核心原理-1"><a href="#vite核心原理-1" class="headerlink" title="vite核心原理"></a>vite核心原理</h2><ul>
<li>vite直接启动开发服务器，不用进行整个项目的打包编译，按需请求。</li>
<li>会预处理所有文件为esm格式，利用浏览器对esm的支持，遇到import再去请求对应的模块，vite会在服务器中间拦截处理文件（比如vue编译）</li>
</ul>
<h2 id="vite本地开发esbuild，打包rollup"><a href="#vite本地开发esbuild，打包rollup" class="headerlink" title="vite本地开发esbuild，打包rollup"></a>vite本地开发esbuild，打包rollup</h2><h2 id="编写loader-1"><a href="#编写loader-1" class="headerlink" title="编写loader"></a>编写loader</h2><h2 id="编写plugin-1"><a href="#编写plugin-1" class="headerlink" title="编写plugin"></a>编写plugin</h2><h2 id="算法题：移动零"><a href="#算法题：移动零" class="headerlink" title="算法题：移动零"></a>算法题：移动零</h2><h2 id="算法题：盛最多水的容器"><a href="#算法题：盛最多水的容器" class="headerlink" title="算法题：盛最多水的容器"></a>算法题：盛最多水的容器</h2><h2 id="算法题：三树之和"><a href="#算法题：三树之和" class="headerlink" title="算法题：三树之和"></a>算法题：三树之和</h2><h2 id="生成AST语法树"><a href="#生成AST语法树" class="headerlink" title="生成AST语法树"></a>生成AST语法树</h2><ol>
<li>是一个裁剪开始标签、文本标签、结束标签，直到模板字符串为空。</li>
<li>根据开始标签创建节点，注意父子节点以及根节点判断。</li>
<li>全局变量，栈结构，栈末尾就是当前父节点。</li>
<li>最终生成ast语法树，根开始标签就是根节点，根开始标签下的开始标签就是子节点，以此类推。</li>
</ol>
<!-- ## js、ts、webpackvite、 -->

<h1 id="12-10"><a href="#12-10" class="headerlink" title="12.10"></a>12.10</h1><h2 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h2><ul>
<li>vue，刷算法</li>
</ul>
<h2 id="AST语法树"><a href="#AST语法树" class="headerlink" title="AST语法树"></a>AST语法树</h2><h2 id="AST语法树代码拼接为渲染函数"><a href="#AST语法树代码拼接为渲染函数" class="headerlink" title="AST语法树代码拼接为渲染函数"></a>AST语法树代码拼接为渲染函数</h2><ul>
<li>将ast语法树对象解析为一个字符串，调用_c创建虚拟标签节点、_v创建虚拟文本节点，with（this），this就是组件实例，上面有响应式的数据。new Function这个字符串，生成渲染函数。</li>
</ul>
<h2 id="AST语法树和虚拟DOM区别"><a href="#AST语法树和虚拟DOM区别" class="headerlink" title="AST语法树和虚拟DOM区别"></a>AST语法树和虚拟DOM区别</h2><h2 id="vue2-diff算法"><a href="#vue2-diff算法" class="headerlink" title="vue2 diff算法"></a>vue2 diff算法</h2><h2 id="vue3-diff算法"><a href="#vue3-diff算法" class="headerlink" title="vue3 diff算法"></a>vue3 diff算法</h2><h2 id="响应式原理-1"><a href="#响应式原理-1" class="headerlink" title="响应式原理"></a>响应式原理</h2><ul>
<li>数据劫持 + 发布订阅</li>
</ul>
<h2 id="数组响应式原理-1"><a href="#数组响应式原理-1" class="headerlink" title="数组响应式原理"></a>数组响应式原理</h2><ul>
<li>除了对象属性会有dep类以外，每个对象本身也会有一个dep类，在__ob__属性上。<br>一是可以根据这个属性判断该对象是否已经处理为响应式；<br>二是数组的变异方法里手动调用dep.notify更新页面。</li>
</ul>
<h2 id="vue3响应式原理"><a href="#vue3响应式原理" class="headerlink" title="vue3响应式原理"></a>vue3响应式原理</h2><ol>
<li>使用proxy代替Object.defineProperty，完整的代理，数组下标修改、对象的新增删除都能检测到。</li>
<li>set、map数据结构的方法重写，也能触发响应式。</li>
</ol>
<h2 id="为什么使用reflect-API"><a href="#为什么使用reflect-API" class="headerlink" title="为什么使用reflect API"></a>为什么使用reflect API</h2><ol>
<li>提供一种 一致、可靠、简洁易懂的方式去完成js的底层操作</li>
<li>如果对象本身有个get属性的数据，get c 返回是this.a，this.b，这个this会指向对象本身，而不是代理；在vue中代理其实就是经过响应式处理的对象，this不走代理就无法触发依赖的收集。如果a、b变了，依赖c的组件不会更新。</li>
</ol>
<h2 id="监听器原理"><a href="#监听器原理" class="headerlink" title="监听器原理"></a>监听器原理</h2><ul>
<li>监听器也是对应一个watcher，在watcher里默认把数据读一遍，让数据的dep类收集这个watcher，当数据改变时候触发dep.notify，通知依赖该数据的页面watcher和监听器watcher更新。</li>
</ul>
<h2 id="computed原理"><a href="#computed原理" class="headerlink" title="computed原理"></a>computed原理</h2><ol>
<li>lazy，默认不计算，只有访问这个计算属性时候才会计算。</li>
<li>dirty，对计算结果缓存，如果依赖的数据没变则不会重新计算，复用之前的计算结果。</li>
<li>本身也是一个watcher，只有计算属性依赖的数据改变触发dep.notify，会把计算属性watcher的dirty变为true，true则需要重新计算值，不能走缓存。</li>
</ol>
<h2 id="nextTick-2"><a href="#nextTick-2" class="headerlink" title="nextTick"></a>nextTick</h2><ul>
<li>js事件循环的应用</li>
<li>任务队列缓冲一次同步任务中的数据更改</li>
<li>优雅降级方式触发watcher对应的函数，Promise.then、MutationObserver、setTimeout</li>
</ul>
<h1 id="12-11"><a href="#12-11" class="headerlink" title="12.11"></a>12.11</h1><!--  -->
<h2 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h2><ul>
<li>渲染函数执行完后生成虚拟DOM树</li>
</ul>
<h2 id="组件渲染过程-1"><a href="#组件渲染过程-1" class="headerlink" title="组件渲染过程"></a>组件渲染过程</h2><ul>
<li>父组件执行render渲染函数生成虚拟DOM树时候，在生成子组件虚拟DOM时候会从父组件上拿到子组件的构造函数放到子组件虚拟节点属性上；当执行patch方法将虚拟DOM转换为真实DOM时候，子组件虚拟节点会调用构造函数构造函数返回子组件真实DOM渲染。</li>
</ul>
<h2 id="props原理-1"><a href="#props原理-1" class="headerlink" title="props原理"></a>props原理</h2><ul>
<li>父组件在创建子组件虚拟DOM时候，会从子组件配置中拿到申明的props，在虚拟DOM上的属性上一一查看，因为我们props写法与属性类似，从属性列表中删除申明的props，props的变了单独放在子组件虚拟DOM的componentOptions。</li>
<li>子组件初始化实例时候，通过数据代理把props值放到组件实例上，并经过响应式的处理。</li>
</ul>
<h2 id="事件的原理"><a href="#事件的原理" class="headerlink" title="事件的原理"></a>事件的原理</h2><ul>
<li>父组件在创建子组件虚拟DOM时候，会把属性中的事件单独拿出来放到componentOptions上。</li>
<li>子组件实例化时候会通过<code>$on</code>把事件绑定到组件实例的__event上，我们调用$emit就是去组件实例上的event查找事件执行。</li>
</ul>
<h2 id="插槽的原理"><a href="#插槽的原理" class="headerlink" title="插槽的原理"></a>插槽的原理</h2><h2 id="keep-alive-1"><a href="#keep-alive-1" class="headerlink" title="keep-alive"></a>keep-alive</h2><h2 id="provide-inject-1"><a href="#provide-inject-1" class="headerlink" title="provide inject"></a>provide inject</h2><h2 id="attrs-、-listeners"><a href="#attrs-、-listeners" class="headerlink" title="$attrs 、$listeners"></a>$attrs 、$listeners</h2><h2 id="v-if和v-for的优先级"><a href="#v-if和v-for的优先级" class="headerlink" title="v-if和v-for的优先级"></a>v-if和v-for的优先级</h2><h2 id="v-if-和-v-show区别"><a href="#v-if-和-v-show区别" class="headerlink" title="v-if 和 v-show区别"></a>v-if 和 v-show区别</h2><h2 id="visibility、opacity、display"><a href="#visibility、opacity、display" class="headerlink" title="visibility、opacity、display"></a>visibility、opacity、display</h2><h2 id="v-model原理-1"><a href="#v-model原理-1" class="headerlink" title="v-model原理"></a>v-model原理</h2><ul>
<li>本质是一个语法糖，在输入框时候 ＝ v-bind：value    +    @input，<br>在checkedbox   ＝  v-bind checked  +   @change</li>
<li>在组件上的时候是 props+事件绑定的语法糖</li>
</ul>
<h2 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h2><ul>
<li>前端发送http请求携带url，后端根据url进行逻辑处理返回对应的html页面。优点是SEO优化好，适合多页面应用。缺点是服务端压力大。</li>
</ul>
<h2 id="前端路由、后端路由"><a href="#前端路由、后端路由" class="headerlink" title="前端路由、后端路由"></a>前端路由、后端路由</h2><h2 id="vuex和pinia区别-10024-2"><a href="#vuex和pinia区别-10024-2" class="headerlink" title="vuex和pinia区别? &#10024;"></a>vuex和pinia区别? &#10024;</h2><ol>
<li>pinia是用 ts编写,类型支持更友好.</li>
<li>去除mutations. state,getters,actions.</li>
<li>vuex树结构,读取数据不方便.都会定义到根模块,覆盖根模块状态.只能创建一个,单例模式. pinia定义多个store,store之间互相引用,扁平化结构.</li>
</ol>
<h2 id="actions和mutations区别-2"><a href="#actions和mutations区别-2" class="headerlink" title="actions和mutations区别"></a>actions和mutations区别</h2><ol>
<li>作用:mutation修改状态,action处理业务代码和异步请求,提交到commit.</li>
<li>同异步:mutation同步执行,action是异步执行</li>
</ol>
<h1 id="12-12"><a href="#12-12" class="headerlink" title="12.12"></a>12.12</h1><!-- 一切都说不准,只能说坚持下来 -->
<h2 id="vuex和pinia区别"><a href="#vuex和pinia区别" class="headerlink" title="vuex和pinia区别"></a>vuex和pinia区别</h2><ol>
<li>单例模式，树形结构，嵌套；扁平化，多个实例。</li>
<li>ts</li>
<li>mutations</li>
<li>选项式api；组合式api</li>
</ol>
<h2 id="mutations和actions区别"><a href="#mutations和actions区别" class="headerlink" title="mutations和actions区别"></a>mutations和actions区别</h2><ol>
<li>业务逻辑、异步请求数据；直接修改数据</li>
<li>异步；同步</li>
</ol>
<h2 id="Array-prototype-splice-方法-1"><a href="#Array-prototype-splice-方法-1" class="headerlink" title="Array.prototype.splice()方法"></a>Array.prototype.splice()方法</h2><ul>
<li>第一个参数：开始操作数组的起始位置</li>
<li>第二个参数：删除的元素个数，不传的话后面所有元素都会删除。</li>
<li>第三个参数：插入&#x2F;替换的元素。</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>.splice(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) //[‘<span class="hljs-number">1</span>’,‘<span class="hljs-number">4</span>’]<br><span class="hljs-attribute">arr</span>.splice(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,&#x27;x&#x27;,<span class="hljs-string">&quot;x&quot;</span>) // 两个元素被替换成一个x/两个x。<br><span class="hljs-attribute">arr</span>.splice(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;x&quot;</span>) // 插入一个x<br></code></pre></td></tr></table></figure>

<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><ul>
<li>一定要异步执行，如果是同步的话，任务还没推进来就开始执行了。</li>
<li>如何等五秒后执行下一个任务?我们用setTimeout,在他的外层再用promise包装,五秒后才调用promise的resolve方法.</li>
</ul>
<h2 id="MVC、MVP、MVVM"><a href="#MVC、MVP、MVVM" class="headerlink" title="MVC、MVP、MVVM"></a>MVC、MVP、MVVM</h2><ul>
<li>MVC：</li>
</ul>
<h1 id="12-13"><a href="#12-13" class="headerlink" title="12.13"></a>12.13</h1><!-- 摆烂了一天，查看虾皮内推进度是offer已审批，有希望吗 -->

<h1 id="12-14"><a href="#12-14" class="headerlink" title="12.14"></a>12.14</h1><!-- 摆烂一天 -->
<h2 id="复习源码"><a href="#复习源码" class="headerlink" title="复习源码"></a>复习源码</h2><h2 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h2><ul>
<li>props、emits</li>
<li>provide、inject</li>
<li>事件总线</li>
<li>vuex</li>
<li>ref</li>
<li>localStorage</li>
<li>attrs</li>
</ul>
<h2 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h2><ol>
<li>beforeCreated：组件实例初始化时候立即调用，无法访问响应式数据、计算属性等等</li>
<li>created：初始化完成，可以访问响应式数据和计算属性</li>
<li>beforeMounted：render函数被调用，但页面还没挂载。</li>
<li>mounted：页面挂载。</li>
<li>beforeUpdated：数据已经发生变化，但页面视图未更新</li>
<li>updated：视图更新。</li>
<li>beforeUnmount：卸载前，还能使用组件所有功能。</li>
<li>unmounted：卸载完毕，清除定时器、DOM监听器等等。</li>
</ol>
<h1 id="12-15"><a href="#12-15" class="headerlink" title="12.15"></a>12.15</h1><!--
你不能在已经赢的时候才自信，
那不是自信，是对结果的复读。
 -->
<h2 id="keep-alive有哪些生命周期"><a href="#keep-alive有哪些生命周期" class="headerlink" title="keep-alive有哪些生命周期"></a>keep-alive有哪些生命周期</h2><ul>
<li>activated、deactivated</li>
</ul>
<h2 id="vue父子组件执行顺序"><a href="#vue父子组件执行顺序" class="headerlink" title="vue父子组件执行顺序"></a>vue父子组件执行顺序</h2><ul>
<li>父先开始，子先结束</li>
</ul>
<h2 id="created和mounted哪里发请求"><a href="#created和mounted哪里发请求" class="headerlink" title="created和mounted哪里发请求"></a>created和mounted哪里发请求</h2><ul>
<li>created，渲染函数未执行，DOM结构未挂载，但响应式数据已经初始化。</li>
<li>mounted：适合要操作DOM的请求，会导致页面重新渲染。</li>
</ul>
<h2 id="MVC、MVP、MVVM-1"><a href="#MVC、MVP、MVVM-1" class="headerlink" title="MVC、MVP、MVVM"></a>MVC、MVP、MVVM</h2><ul>
<li>MVC：观察者模式、策略模式</li>
<li>MVP：进一步解耦，view暴露接口给presenter</li>
<li>MVVM：操作自动化，降低代码复杂度</li>
</ul>
<h2 id="事件模型-3"><a href="#事件模型-3" class="headerlink" title="事件模型"></a>事件模型</h2><ol>
<li>DOM0：没有事件流，只有本身触发</li>
<li>IE事件模型：事件处理 + 事件冒泡</li>
<li>DOM2：事件捕获 + 事件处理 + 事件冒泡</li>
</ol>
<h2 id="vue默认事件机制"><a href="#vue默认事件机制" class="headerlink" title="vue默认事件机制"></a>vue默认事件机制</h2><ul>
<li>事件冒泡模型</li>
</ul>
<h2 id="常见的事件修饰符"><a href="#常见的事件修饰符" class="headerlink" title="常见的事件修饰符"></a>常见的事件修饰符</h2><ol>
<li>stop，阻止事件冒泡</li>
<li>prevent，阻止默认行为</li>
<li>capture: 让事件在捕获时候触发</li>
<li>once：触发一次</li>
<li>self：只触发本身</li>
</ol>
<h2 id="data为什么是函数而不是对象"><a href="#data为什么是函数而不是对象" class="headerlink" title="data为什么是函数而不是对象"></a>data为什么是函数而不是对象</h2><ul>
<li>创建组件的子构造函数本身会保留配置项，相同组件会调用同一个构造函数，会访问相同的构造函数上的配置项，到达复用的效果。</li>
<li>对象是引用值，一个实例修改其他实例也会更改。</li>
</ul>
<h2 id="TCP握手不能两次"><a href="#TCP握手不能两次" class="headerlink" title="TCP握手不能两次"></a>TCP握手不能两次</h2><ol>
<li><strong>避免历史连接</strong>：如果上一次SYN请求滞留在网络中；这时候开启新的TCP握手，但旧SYN先到达，服务器会建立连接。两次握手没有中间状态来拒绝服务端的连接。服务端返回第二次握手后会直接发送数据，导致资源的浪费。</li>
<li><strong>同步双方序列号</strong>：服务端发送序列号过去后需要客户端ACK应答。</li>
</ol>
<h2 id="单页面和多页面-2"><a href="#单页面和多页面-2" class="headerlink" title="单页面和多页面"></a>单页面和多页面</h2><ol>
<li>资源加载：单页面一次性加载资源,多页面多次加载</li>
<li>路由:单页面应用:history,hash.多页面应用通过路径跳转.</li>
<li>数据传递:单页面vuex.多页面cookie,localStorage,sessionStorage,接口保存.</li>
<li>页面跳转：单页面局部更新,切换速度快.多页面全局更新,切换速度慢.</li>
</ol>
<h2 id="对SPA单页面应用的理解-1"><a href="#对SPA单页面应用的理解-1" class="headerlink" title="对SPA单页面应用的理解?"></a>对SPA单页面应用的理解?</h2><ul>
<li>优点:</li>
</ul>
<ol>
<li>一次性获取所有js,css,html文件,减少服务端压力.</li>
<li>内容改动无需重新加载整个页面,局部更新页面.</li>
<li>前后端分离,前端负责图层,后端负责数据层.</li>
</ol>
<ul>
<li>缺点:</li>
</ul>
<ol>
<li>首屏加载速度慢</li>
<li>客户端占用更多内存和cpu资源.</li>
<li>前端手动实现路由,管理浏览器前进后退功能.</li>
</ol>
<h2 id="vue初始化页面闪动问题-1"><a href="#vue初始化页面闪动问题-1" class="headerlink" title="vue初始化页面闪动问题"></a>vue初始化页面闪动问题</h2><ul>
<li>数据异步获取,页面先渲染完出现闪动情况.</li>
<li>解决方法:[v-cloak]:{display:none}</li>
</ul>
<h2 id="react和vue区别-1"><a href="#react和vue区别-1" class="headerlink" title="react和vue区别"></a>react和vue区别</h2><ol>
<li>核心思想：vue是双向数据绑定；53是模块化、单向数据流：数据在父组件中，传递给子组件渲染。</li>
<li>模板编写：vue模板语法，react是jsx写法：把html、css写入到js中。</li>
<li>逻辑复用：一个组件对应一个函数，高阶组件接受一个组件添加功能逻辑，再返回一个组件；vue mixin、组合式API。</li>
</ol>
<h2 id="vue优点"><a href="#vue优点" class="headerlink" title="vue优点"></a>vue优点</h2><ol>
<li><em><strong>声明式框架</strong></em>：响应式原理</li>
<li><em><strong>虚拟DOM</strong></em>：第一：diff算法。第二：支持跨平台，服务端渲染、浏览器渲染，将虚拟DOM转换为真实HTML元素。</li>
<li><em><strong>区分编译时和运行时</strong></em>：<br>编译时：将<strong>模板</strong>变成js语法渲染函数生成的<strong>虚拟DOM</strong>；<br>运行时：上线时只走运行时。</li>
<li><em><strong>拥抱Ts</strong></em></li>
</ol>
<h2 id="assets和static区别-1"><a href="#assets和static区别-1" class="headerlink" title="assets和static区别"></a>assets和static区别</h2><ul>
<li>assets资源会打包压缩后放到static里面上传到服务器</li>
<li>static资源会避免打包压缩流程直接上传到服务器，提高效率，但体积更大。</li>
</ul>
<h2 id="vue性能优化"><a href="#vue性能优化" class="headerlink" title="vue性能优化"></a>vue性能优化</h2><ol>
<li>防抖节流</li>
<li>虚拟列表</li>
<li>webworker</li>
<li>公共组件抽离</li>
<li>强制缓存、协商缓存</li>
<li>v-if、v-show</li>
<li>异步组件</li>
<li>打包体积优化</li>
<li>构建速度优化</li>
</ol>
<h2 id="vue上"><a href="#vue上" class="headerlink" title="vue上"></a>vue上</h2><h1 id="12-16"><a href="#12-16" class="headerlink" title="12.16"></a>12.16</h1><h2 id="vue上-1"><a href="#vue上-1" class="headerlink" title="vue上"></a>vue上</h2><h2 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h2><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><ol>
<li>vue component：与用户交互触发事件，dispatch触发action</li>
<li>action里处理业务逻辑和异步请求，会经过promise封装。</li>
<li>action处理完后dispatch交给mutations里去修改数据。</li>
<li>state变化后通知vue组件更新</li>
<li>getters计算属性，响应式原理和getters原理都是借助了vue组件去创建响应式数据和计算属性。</li>
</ol>
<h2 id="actions和mutations区别-3"><a href="#actions和mutations区别-3" class="headerlink" title="actions和mutations区别"></a>actions和mutations区别</h2><ol>
<li>actions处理业务逻辑、请求数据；mutations中直接修改数据</li>
<li>异步；同步</li>
<li>一般是组件触发actions，再去触发mutations。</li>
</ol>
<h2 id="vuex和localStorage区别-1"><a href="#vuex和localStorage区别-1" class="headerlink" title="vuex和localStorage区别"></a>vuex和localStorage区别</h2><ol>
<li>vuex存在内存中，localStorage存在本地磁盘文件中</li>
<li>刷新vuex清空，localStorage不会</li>
<li>vuex是响应式数据，localStorage</li>
</ol>
<h2 id="代码输出题"><a href="#代码输出题" class="headerlink" title="代码输出题"></a>代码输出题</h2><ol>
<li>没有var、let、const声明的变量就是全局，会在window上。</li>
</ol>
<h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h2><ul>
<li>不能有比我小1的数，找比我大1的数</li>
</ul>
<h2 id="移动0"><a href="#移动0" class="headerlink" title="移动0"></a>移动0</h2><h2 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h2><h2 id="重复最多的数"><a href="#重复最多的数" class="headerlink" title="重复最多的数"></a>重复最多的数</h2><h2 id="找数组中的值find、findIndex、indexOf"><a href="#找数组中的值find、findIndex、indexOf" class="headerlink" title="找数组中的值find、findIndex、indexOf"></a>找数组中的值find、findIndex、indexOf</h2><ul>
<li>前两个是要函数，后一个是元素</li>
</ul>
<ol>
<li>find：arr.find((value)&#x3D;&gt; value &gt; 10) 返回第一个大于10的数</li>
<li>findIndex，同find用法，但返回的是下标</li>
<li><strong>indexOf</strong>：arr.indexOf(‘cc’)，数组中第一个出现给定元素的下标。</li>
</ol>
<h2 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h2><ul>
<li>传参parseInt(转换的数,多少进制)；</li>
</ul>
<h2 id="RGB转换"><a href="#RGB转换" class="headerlink" title="RGB转换"></a>RGB转换</h2><h2 id="千分位隔开"><a href="#千分位隔开" class="headerlink" title="千分位隔开"></a>千分位隔开</h2><h2 id="微前端网课一半"><a href="#微前端网课一半" class="headerlink" title="微前端网课一半"></a>微前端网课一半</h2><h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><ul>
<li>当拿当前这家和不拿当前这家的钱是一样的时候，不拿当前这家，这样可以拿更少的文章。</li>
</ul>
<h1 id="12-17"><a href="#12-17" class="headerlink" title="12.17"></a>12.17</h1><h2 id="接雨水动态规划"><a href="#接雨水动态规划" class="headerlink" title="接雨水动态规划"></a>接雨水动态规划</h2><ul>
<li>核心思路：当前格子能接的雨水是 ：两边最大值中的小值减去当前格子的高度。</li>
</ul>
<h2 id="接雨水-双指针"><a href="#接雨水-双指针" class="headerlink" title="接雨水 双指针"></a>接雨水 双指针</h2><ul>
<li>不需要找到两边的最大值，如果我AA边的最大值比BB边其中一个值小，那我就可以计算A边一个格子的能接的雨水量。</li>
</ul>
<h2 id="无重复字符的最长子串-1"><a href="#无重复字符的最长子串-1" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><ul>
<li>！考虑right在末尾超出边界的情况！</li>
</ul>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><ul>
<li>都是content、padding、border、margin</li>
</ul>
<ol>
<li>IE盒子模型：width、height包括content、padding、border</li>
</ol>
<h2 id="px、em、rem区别"><a href="#px、em、rem区别" class="headerlink" title="px、em、rem区别"></a>px、em、rem区别</h2><ol>
<li>px是固定像素</li>
<li>em、rem是相对长度，em是相对父元素的字体大小。rem是相对根元素html的大小。</li>
</ol>
<h2 id="animation和transition"><a href="#animation和transition" class="headerlink" title="animation和transition"></a>animation和transition</h2><ol>
<li>transition：强调过度，他的实现需要一个事件触发（鼠标移上去，点击），只有一个开始帧和结束帧。 属性有：transition-property、transition-duration、transition-function、transition-delay</li>
<li>animation：实现不需要触发，设定时间后自动触发，且可以循环动画，通过@keyframe设置多个关键帧。</li>
</ol>
<h2 id="vue2、vue3区别"><a href="#vue2、vue3区别" class="headerlink" title="vue2、vue3区别"></a>vue2、vue3区别</h2><ul>
<li>响应式原理、diff算法、</li>
</ul>
<ol>
<li>响应式核心思想没变，数据劫持 + 发布订阅，Object.definProperty&#x3D;》proxy，数组可以监听到。对象新增删除也能监听。</li>
<li>diff算法</li>
</ol>
<!-- 3. 模板解析器，vue2是正则匹配，vue3基于状态机。 -->
<ol start="3">
<li>选项式API &#x3D;》组合式API</li>
<li>v-if、v-for优先级变化</li>
<li>对ts支持更友好</li>
<li>生命周期</li>
</ol>
<h2 id="实现继承的方法"><a href="#实现继承的方法" class="headerlink" title="实现继承的方法"></a>实现继承的方法</h2><h2 id="get、post区别"><a href="#get、post区别" class="headerlink" title="get、post区别"></a>get、post区别</h2><ol>
<li>本质：获取资源、增删改资源</li>
<li>缓存：get可以强制缓存、协商缓存</li>
<li>幂等：get是幂等的、post不是</li>
<li>请求体：get请求有长度限制，编码只能是url编码；post请求可以放在请求体，编码格式多种。</li>
</ol>
<h2 id="call、apply、bind区别"><a href="#call、apply、bind区别" class="headerlink" title="call、apply、bind区别"></a>call、apply、bind区别</h2><h1 id="12-18"><a href="#12-18" class="headerlink" title="12.18"></a>12.18</h1><h2 id="returnType、parameters"><a href="#returnType、parameters" class="headerlink" title="returnType、parameters"></a>returnType、parameters</h2><h2 id="Required、Patical、Readonly"><a href="#Required、Patical、Readonly" class="headerlink" title="Required、Patical、Readonly"></a>Required、Patical、Readonly</h2><h2 id="Pick、Omit"><a href="#Pick、Omit" class="headerlink" title="Pick、Omit"></a>Pick、Omit</h2><h2 id="exclude、extract"><a href="#exclude、extract" class="headerlink" title="exclude、extract"></a>exclude、extract</h2><h2 id="XSS-、CSRF攻击"><a href="#XSS-、CSRF攻击" class="headerlink" title="XSS 、CSRF攻击"></a>XSS 、CSRF攻击</h2><ul>
<li>XSS浏览器无法识别恶意js代码，都会执行。<br>破坏DOM、读取cookie、localSessionStorage<br>解决方案：http-only、csp白名单</li>
<li>CSRF攻击，跨站请求伪造，利用cookie同源请求会发送的性质，cookie里存储了session信息。<br>解决方案：samesite，token，双认证，origin、referer。</li>
</ul>
<h2 id="XSS攻击三种类型"><a href="#XSS攻击三种类型" class="headerlink" title="XSS攻击三种类型"></a>XSS攻击三种类型</h2><ol>
<li>存储型：恶意代码在服务端，论坛评论了恶意代码，其他用户访问论坛评论。</li>
<li>反射型：访问恶意url，请求发送到服务端，服务端响应带有恶意代码的页面。</li>
<li>DOM型：是前端从url拿取恶意代码执行。innerHTML、eval函数。</li>
</ol>
<h2 id="set-cookie"><a href="#set-cookie" class="headerlink" title="set-cookie"></a>set-cookie</h2><ul>
<li>服务端响应头返回的字段，可以设置cookie的内容</li>
</ul>
<h2 id="中间人攻击-1"><a href="#中间人攻击-1" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><ul>
<li>tls握手中，需要三个随机数完成会话密钥的协商，第一次握手拿到第一个随机数。第二次服务端返回数字证书和第二个随机数，中间人服务器拦截服务端数字证书，将自己的数字证书发送给客户端，客户端如果信任了就会出问题，用中间人的公钥加密第三个随机数，中间人私钥解密拿到三个随机数生成会话密钥。同时用服务端的公钥加密第三个随机数给服务端。</li>
</ul>
<h2 id="强制缓存、协商缓存"><a href="#强制缓存、协商缓存" class="headerlink" title="强制缓存、协商缓存"></a>强制缓存、协商缓存</h2><ul>
<li>cache-control&#x2F;expires</li>
<li>last-modifed&#x2F;if-modifed-since；etag&#x2F;if-none-match</li>
</ul>
<!--
 晚上休息前搞完渲染原理、本地存储、同源策略
 晚上项目
 -->
<h2 id="浏览器渲染原理-2"><a href="#浏览器渲染原理-2" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000042909353">https://segmentfault.com/a/1190000042909353</a></li>
</ul>
<ol>
<li>解析html文档,生成DOM树,由html元素和属性节点组成.</li>
<li>解析css,生成css树.</li>
<li>根据DOM树和CSS树构建渲染树</li>
<li>布局(回流):渲染树进行布局计算每个渲染节点的位置和大小.</li>
<li>绘制(重绘):将渲染树的节点绘制到页面上.</li>
<li>复合: 浏览器的绘制是绘制到多层,每一层单独渲染,最后合成到一起形成页面.</li>
<li>重绘:重绘不会带来重新布局,一般是修改背景颜色,边框阴影等属性.</li>
<li>回流:消耗性能,改变元素位置,DOM结构发生变化.</li>
</ol>
<h2 id="如何优化浏览器渲染"><a href="#如何优化浏览器渲染" class="headerlink" title="如何优化浏览器渲染"></a>如何优化浏览器渲染</h2><ol>
<li>js：async、defer、写在后面。js线程和渲染线程是冲突的。</li>
<li>css：link、@import、style。</li>
<li>减少回流重绘</li>
</ol>
<h2 id="减少回流、重绘"><a href="#减少回流、重绘" class="headerlink" title="减少回流、重绘"></a>减少回流、重绘</h2><ol>
<li>浏览器任务队列机制。</li>
<li>脱离文档流，减少对其他元素的影响。</li>
<li>操作低层次dom。</li>
<li>利用GPU加速渲染，单独抽离出合成层。</li>
<li>documentFragment文档碎片，不在DOM中，操作其不会触发回流重绘。</li>
</ol>
<h2 id="浏览器的本地存储-2"><a href="#浏览器的本地存储-2" class="headerlink" title="浏览器的本地存储"></a>浏览器的本地存储</h2><h3 id="cookie-2"><a href="#cookie-2" class="headerlink" title="cookie"></a>cookie</h3><ol>
<li>大小限制4kb,不能跨域.</li>
<li>主要和seesion配合,存储sessionid,发送请求时候可以携带cookie,服务器识别sessionid来识别身份.</li>
</ol>
<h3 id="localStorage-2"><a href="#localStorage-2" class="headerlink" title="localStorage"></a>localStorage</h3><ol>
<li>大小5MB,存储在本地,请求不会携带.</li>
<li>除非主动删除,否则不会消失.</li>
<li>同源多个标签可以共享数据.</li>
</ol>
<h3 id="sessionStorage-2"><a href="#sessionStorage-2" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><ol>
<li>同.</li>
<li>关闭窗口后会消失</li>
<li>同源多个标签不可以共享数据.</li>
</ol>
<h2 id="cookie字段-2"><a href="#cookie字段-2" class="headerlink" title="cookie字段"></a>cookie字段</h2><ol>
<li>domain:可以访问该cookie的域名</li>
<li>path:域名下的哪些路径可以访问该cookie</li>
<li>Expires:cookie过期时间,注意这个是cookie的expires!和缓存的不一样,缓存的是在请求头中!</li>
<li>name,value,size.</li>
</ol>
<ul>
<li>服务端在响应头可以用set-cookie来配置cookie信息.http-only限制cookie不能被js脚本读取.也有domain,path,expires.<br>(不要把缓存的六个字段和cookie的搞混了,缓存的是在请求头和响应头中)</li>
</ul>
<h2 id="indexDB-2"><a href="#indexDB-2" class="headerlink" title="indexDB"></a>indexDB</h2><ol>
<li>键值对存储,异步,支持事务(不会出现只修改部分数据情况),存储空间大(250MB+)</li>
</ol>
<h2 id="同源策略-1"><a href="#同源策略-1" class="headerlink" title="同源策略"></a>同源策略</h2><ol>
<li>安全机制,隔离恶意文件.要求协议域名端口号都相同.</li>
<li>限制cookie,localstorage,indexDB&#x2F;DOM&#x2F;跨域请求.</li>
</ol>
<h2 id="如何解决跨域"><a href="#如何解决跨域" class="headerlink" title="如何解决跨域"></a>如何解决跨域</h2><ol>
<li>CORS：简单请求、非简单请求。</li>
<li>JSONP：利用script标签没有跨域限制。</li>
<li>postmessage：多窗口之间通信。</li>
<li>nginx</li>
<li>代理服务器</li>
</ol>
<h2 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h2><ol>
<li>第一个、最后一个交换，第二个和倒数第二个交换……时间复杂度On，空间O1</li>
<li>新数组，旧数组从后往前遍历，拿一个放一个，拿一个放一个。时间复杂度On，空间On。</li>
</ol>
<h1 id="12-19"><a href="#12-19" class="headerlink" title="12.19"></a>12.19</h1><h2 id="TCP、UDP区别"><a href="#TCP、UDP区别" class="headerlink" title="TCP、UDP区别"></a>TCP、UDP区别</h2><ol>
<li>连接</li>
<li>服务对象</li>
<li>可靠、不可靠</li>
<li>拥塞控制、流量控制</li>
<li>传输：字节流：tcp的数据包可以按字节大小拆分成多个数据包，udp每次一个包一个包完整的发送。</li>
</ol>
<h2 id="浏览器渲染原理-3"><a href="#浏览器渲染原理-3" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><h2 id="浏览器渲染优化-3"><a href="#浏览器渲染优化-3" class="headerlink" title="浏览器渲染优化"></a>浏览器渲染优化</h2><h2 id="减少回流重绘"><a href="#减少回流重绘" class="headerlink" title="减少回流重绘"></a>减少回流重绘</h2><h2 id="cookie、local、sessionStorage区别"><a href="#cookie、local、sessionStorage区别" class="headerlink" title="cookie、local、sessionStorage区别"></a>cookie、local、sessionStorage区别</h2><h2 id="cookie字段-3"><a href="#cookie字段-3" class="headerlink" title="cookie字段"></a>cookie字段</h2><h2 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h2><h2 id="跨域-1"><a href="#跨域-1" class="headerlink" title="跨域"></a>跨域</h2><ol>
<li>CORS：简单请求、非简单请求。预检请求，options缓存。</li>
<li>JSONP：传入回调函数名为参数，返回的脚本代码调用回调函数传入参数。</li>
<li>代理服务器</li>
<li>postmessage，多窗口之间跨域。</li>
</ol>
<h2 id="事件模型-4"><a href="#事件模型-4" class="headerlink" title="事件模型"></a>事件模型</h2><ol>
<li>DOM0 事件触发</li>
<li>IE 事件触发，事件冒泡</li>
<li>DOM2 事件捕获 事件触发 事件冒泡</li>
</ol>
<h2 id="事件委托-2"><a href="#事件委托-2" class="headerlink" title="事件委托"></a>事件委托</h2><ol>
<li>利用事件冒泡的机制，子元素的监听事件绑定到父元素上，父元素集中处理子元素的事件</li>
<li>减少内存消耗、动态事件绑定</li>
<li>缺点：focus事件没有冒泡机制、DOM层数深不建议消耗性能。</li>
</ol>
<h1 id="12-20"><a href="#12-20" class="headerlink" title="12.20"></a>12.20</h1><!-- go big or go home -->
<h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><ul>
<li>两者都是CS架构</li>
</ul>
<ol>
<li>正向代理：是客户端这边设置的代理，隐藏客户端身份。</li>
<li>反向代理：是服务端这边设置，将请求分散到多个服务器，减少服务端压力，隐藏服务端身份。</li>
</ol>
<h2 id="事件循环-2"><a href="#事件循环-2" class="headerlink" title="事件循环"></a>事件循环</h2><h2 id="内存泄漏-1"><a href="#内存泄漏-1" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><ol>
<li>未关闭的定时器setInterval</li>
<li>未使用的全局变量</li>
<li>不恰当的闭包使用</li>
<li>DOM元素的引用</li>
</ol>
<h2 id="浏览器进程-2"><a href="#浏览器进程-2" class="headerlink" title="浏览器进程"></a>浏览器进程</h2><ol>
<li>主进程</li>
<li>插件进程</li>
<li>GPU进程</li>
<li>渲染进程（内核）：渲染线程、js线程</li>
</ol>
<h2 id="浏览器组成部分"><a href="#浏览器组成部分" class="headerlink" title="浏览器组成部分"></a>浏览器组成部分</h2><!-- 微前端网课 -->


<h2 id="externals优化"><a href="#externals优化" class="headerlink" title="externals优化"></a>externals优化</h2><ul>
<li>部分资源不会打包到输出目录中，而是作为外部依赖通过script标签引入。</li>
<li>减少打包体积也能提高构建速度。</li>
</ul>
<h2 id="string的replace方法-10024-1"><a href="#string的replace方法-10024-1" class="headerlink" title="string的replace方法 &#10024;"></a>string的replace方法 &#10024;</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46658751/article/details/123390095">https://blog.csdn.net/qq_46658751/article/details/123390095</a></li>
</ul>
<ol>
<li>replace(字符串，字符串)，只能替换一次</li>
<li>replace（正则，字符串）多次替换</li>
<li>replace（正则，函数）核心用法，函数第一个参数是匹配到的子串，第二个是起始索引，第三个是字符串本身。如果有捕获器的值则插入在第二个参数，起始索引变第三个参数，字符串本身变第四个参数。</li>
</ol>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">templat.replace(<span class="hljs-regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/g</span>,<span class="hljs-function"><span class="hljs-params">(match,key)</span>=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> data[key];<br>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="字符串没有splice"><a href="#字符串没有splice" class="headerlink" title="字符串没有splice"></a>字符串没有splice</h2><ul>
<li>splice是数组方法</li>
</ul>
<h2 id="比较含退格的字符串"><a href="#比较含退格的字符串" class="headerlink" title="比较含退格的字符串"></a>比较含退格的字符串</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/backspace-string-compare/description/">https://leetcode.cn/problems/backspace-string-compare/description/</a></li>
</ul>
<h1 id="12-21"><a href="#12-21" class="headerlink" title="12.21"></a>12.21</h1><h2 id="模块加载对window影响"><a href="#模块加载对window影响" class="headerlink" title="模块加载对window影响"></a>模块加载对window影响</h2><ul>
<li>不管是react、还是vue加载都会在window对象上创建属性。比如window.React、window.ReactDom</li>
</ul>
<h2 id="systemJS"><a href="#systemJS" class="headerlink" title="systemJS"></a>systemJS</h2><ul>
<li>是一个模块规范，类似commonjs、esmodule</li>
</ul>
<ol>
<li>systemjs的模块规范，主要分为三个部分。<br>第一个是script标签里写上外部依赖的映射表（这些外部依赖不会打包，而是通过cdn引入），<br>第二个是system.import(‘打包后的项目index.js’)，<br>第三个是打包后项目文件里system.register([‘react’,’react-dom’],function(){<br> return {<br>  setters:[<br> function，function &#x2F;&#x2F; 这里的function是把window上的依赖给到webpack<br>  ],<br>  execute:{</li>
</ol>
<p>  }<br> }<br>}).<br>2. 封装一个loader方法：创建script标签，设置script标签的src属性，添加到页面中。 这个方法可以加载对应文件。<br>4. register方法就是获取传入的参数。<br>5. import方法：获取页面中script标签中的映射，然后promise.then拼接import要加载的页面路径，然后promise.then调用loader方法去加载打包的项目index.js，在register中获取传入的参数。然后promise.then去加载依赖的外部组件，外部组件加载完后会调用register的第二个参数中的setters中的方法，将外部依赖放到webpack上。这样webpack在加载模块时候可以使用。<br>3. getter里面是传入window上新增的属性 &#x3D; 依赖，将这个依赖放到wbpack上，wbpack模块解析时候会使用到。</p>
<!-- 他们以为击败我的会是终结，而我必将归来将之改写 -->

<h1 id="12-23"><a href="#12-23" class="headerlink" title="12.23"></a>12.23</h1><h2 id="vue生命周期unmounted时候事件监听器是如何移除的？"><a href="#vue生命周期unmounted时候事件监听器是如何移除的？" class="headerlink" title="vue生命周期unmounted时候事件监听器是如何移除的？"></a>vue生命周期unmounted时候事件监听器是如何移除的？</h2><ul>
<li>两种情况，$on绑定和原生的addListeners绑定；前者原理是在组件实例对象的event属性数组上添加元素，会随组件对象卸载自动卸载；如果是后者则需要用户自己删除。</li>
</ul>
<h2 id="微前端网课"><a href="#微前端网课" class="headerlink" title="微前端网课"></a>微前端网课</h2><h1 id="12-24"><a href="#12-24" class="headerlink" title="12.24"></a>12.24</h1><h2 id="手写reduce"><a href="#手写reduce" class="headerlink" title="手写reduce"></a>手写reduce</h2><h2 id="如何提高webpack构建速度-1"><a href="#如何提高webpack构建速度-1" class="headerlink" title="如何提高webpack构建速度"></a>如何提高webpack构建速度</h2><ol>
<li>cache-loader</li>
<li>thread-loader：babel-loader支持多线程执行。</li>
<li>dllplugin</li>
<li>exclude loader的作用范围不包括node_modules</li>
<li>代码分割，动态加载，加载资源速度更快。</li>
</ol>
<h2 id="如何减小打包体积"><a href="#如何减小打包体积" class="headerlink" title="如何减小打包体积"></a>如何减小打包体积</h2><ol>
<li>tree-shaking</li>
<li>js代码压缩：空格、注释、log、变量名</li>
<li>css压缩：空格、注释</li>
<li>图片压缩</li>
<li>组件库按需加载</li>
<li>下载到开发依赖</li>
<li>externals不把某些依赖打包到项目中，而是通过cdn引入。</li>
</ol>
<h2 id="externals优化-1"><a href="#externals优化-1" class="headerlink" title="externals优化"></a>externals优化</h2><ul>
<li>部分资源不会打包到输出目录中，而是作为外部依赖通过script标签引入。</li>
<li>减少打包体积也能提高构建速度。</li>
</ul>
<h2 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h2><ol>
<li>时间空间都为On</li>
<li>时间为On2，空间O1</li>
<li>时间On，空间O1</li>
</ol>
<h2 id="微前端知识"><a href="#微前端知识" class="headerlink" title="微前端知识"></a>微前端知识</h2><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol>
<li>虚拟列表</li>
<li>webworker</li>
<li>代码分割，路由动态加载</li>
</ol>
<h2 id="虚拟DOM相比真实DOM的优点？"><a href="#虚拟DOM相比真实DOM的优点？" class="headerlink" title="虚拟DOM相比真实DOM的优点？"></a>虚拟DOM相比真实DOM的优点？</h2><ol>
<li><strong>异步批量更新</strong>（watch队列，nextTick的缓冲队列），减少频繁的DOM操作。</li>
<li><strong>最小化DOM操作</strong>：通过diff算法对比两次虚拟DOM树的区别，尽可能复用现有的真实DOM，减少DOM操作。</li>
<li><strong>跨平台渲染</strong>：浏览器渲染，服务端渲染。</li>
</ol>
<h2 id="虚拟DOM一定比真实DOM更快吗？"><a href="#虚拟DOM一定比真实DOM更快吗？" class="headerlink" title="虚拟DOM一定比真实DOM更快吗？"></a>虚拟DOM一定比真实DOM更快吗？</h2><ol>
<li>不一定。解析模板、ast语法树、渲染函数、虚拟DOM创建、diff对比、真实DOM创建都是要消耗性能的。如果是简单的页面，直接操作真实DOM效率更高。</li>
<li>也增加了内存消耗。</li>
</ol>
<h1 id="12-25"><a href="#12-25" class="headerlink" title="12.25"></a>12.25</h1><h2 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h2><h2 id="最长重复子数组-1"><a href="#最长重复子数组-1" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2><ul>
<li>二维dp数组去表示状态，</li>
</ul>
<h2 id="diffjs"><a href="#diffjs" class="headerlink" title="diffjs"></a>diffjs</h2><ul>
<li>采用最长公共子序列方法</li>
</ul>
<h2 id="最长公共子序列-1"><a href="#最长公共子序列-1" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h2 id="为什么采用diffjs而不是其他比如json-diff"><a href="#为什么采用diffjs而不是其他比如json-diff" class="headerlink" title="为什么采用diffjs而不是其他比如json-diff"></a>为什么采用diffjs而不是其他比如json-diff</h2><ul>
<li>diffjs使用方便，只有三种状态added，removed，value表示没修改的。</li>
<li>json-diff复杂，数组比完后返回一个数组，数组里面还套了数组，很难获取数据。</li>
<li>其次我们需要个性化的展示，符合用户需求，数据转换为字符串，字符串对比更适合使用diffjs。</li>
</ul>
<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><h2 id="虚拟列表-1"><a href="#虚拟列表-1" class="headerlink" title="虚拟列表"></a>虚拟列表</h2><h2 id="git-merge-git-rebase区别"><a href="#git-merge-git-rebase区别" class="headerlink" title="git merge&#x2F;git rebase区别"></a>git merge&#x2F;git rebase区别</h2><h2 id="盒马电话二面"><a href="#盒马电话二面" class="headerlink" title="盒马电话二面"></a>盒马电话二面</h2><h1 id="12-26"><a href="#12-26" class="headerlink" title="12.26"></a>12.26</h1><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/leman314/article/details/111936863">https://blog.csdn.net/leman314/article/details/111936863</a></li>
</ul>
<ol>
<li>布局视口：文档对象的逻辑尺寸，pc端和浏览器窗口大小差不多。移动端远大于手机尺寸。</li>
<li>理想视口：是布局视口的理想尺寸，和设备宽度相同。</li>
<li>视觉视口：用户在网页看到的区域。理想视口尺寸&#x2F;缩放比例。</li>
</ol>
<h2 id="只设置initial-scale，不设置width可以吗？"><a href="#只设置initial-scale，不设置width可以吗？" class="headerlink" title="只设置initial-scale，不设置width可以吗？"></a>只设置initial-scale，不设置width可以吗？</h2><ol>
<li>问题：initial-scale是理想&#x2F;视觉，如果不设置width，那么布局也等于视觉（这是一条定律），布局＝视觉＝理想不就可以了吗？</li>
<li>IE浏览器使用横屏时候，布局会等于竖屏的理想视口。</li>
</ol>
<h2 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h2><ol>
<li>使用视口配置，width定义布局视口大小等于理想视口，initial-scale设置理想视口和视觉视口比例。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span> = <span class="hljs-string">&quot;width = device-width ,initial-scale = 1.0&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol start="2">
<li>媒体查询</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span> :<span class="hljs-number">1024px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>:<span class="hljs-number">768px</span>)&#123;<br>  <span class="hljs-selector-tag">html</span> : &#123;<br>    <span class="hljs-attribute">font-size</span>:<span class="hljs-number">18px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li>百分比布局</li>
</ol>
<ul>
<li>使用%、em、rem相对单位，不要用px绝对单位。</li>
</ul>
<ol start="4">
<li>弹性盒子flex</li>
</ol>
<ul>
<li>flex：主轴、侧轴、排列方式（align-items、justify-content）</li>
</ul>
<ol start="5">
<li><p>组件库vant</p>
</li>
<li><p>设计稿匹配</p>
</li>
</ol>
<ul>
<li>主流设备的375px（iphone6&#x2F;7&#x2F;8）</li>
</ul>
<h1 id="12-27"><a href="#12-27" class="headerlink" title="12.27"></a>12.27</h1><h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><h2 id="查询数组中元素出现的位置"><a href="#查询数组中元素出现的位置" class="headerlink" title="查询数组中元素出现的位置"></a>查询数组中元素出现的位置</h2><h2 id="手写single-spa-1-3"><a href="#手写single-spa-1-3" class="headerlink" title="手写single-spa 1&#x2F;3"></a>手写single-spa 1&#x2F;3</h2><h1 id="12-30"><a href="#12-30" class="headerlink" title="12.30"></a>12.30</h1><h2 id="旋转数组的最小值-I-II"><a href="#旋转数组的最小值-I-II" class="headerlink" title="旋转数组的最小值 I &#x2F; II"></a>旋转数组的最小值 I &#x2F; II</h2><ul>
<li>二分法</li>
</ul>
<h2 id="单词搜索-1"><a href="#单词搜索-1" class="headerlink" title="单词搜索"></a>单词搜索</h2><ul>
<li>回溯</li>
</ul>
<h2 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h2><h1 id="12-31"><a href="#12-31" class="headerlink" title="12.31"></a>12.31</h1><h2 id="parseInt-值，进制"><a href="#parseInt-值，进制" class="headerlink" title="parseInt(值，进制);"></a>parseInt(值，进制);</h2><ul>
<li>是把 值 按 进制解析后，返回十进制结果。</li>
</ul>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h3 id="JavaScript-的数值表示"><a href="#JavaScript-的数值表示" class="headerlink" title="JavaScript 的数值表示"></a>JavaScript 的数值表示</h3><p>JavaScript 使用 64位标准双精度浮点数 来表示数字，但实际计算时，整数是 32位带符号整数（对于大多数常规运算）。<br>32位带符号整数的范围为 -2的31次幂到2的31次幂 - 1， 即从 -2147483648 到 2147483647。</p>
<h3 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h3><ul>
<li>当数值超出范围时（如负数 -2147483648 转为正数），JavaScript 会 自动将其转换为无符号整数，这会导致在某些运算中产生意料之外的结果。</li>
</ul>
<h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><p>算术移位：右移补1.<br>逻辑移位：补0.</p>
<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><ul>
<li>时间复杂度降到logn，递归。</li>
<li>问题：-2147483648 转为正数2147483648，变为无符号位，但如果算术右移以为还是符号位，补1导致错误。</li>
</ul>
<h2 id="window-addListeners"><a href="#window-addListeners" class="headerlink" title="window.addListeners"></a>window.addListeners</h2><ul>
<li>window.addEventListener 本身并不决定事件的同步或异步性质，具体取决于事件的触发方式：</li>
</ul>
<ol>
<li>使用 dispatchEvent 显式触发时，事件处理函数可能同步执行。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Event triggered&#x27;</span>);<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;customEvent&#x27;</span>, handler);<br><br><span class="hljs-comment">// 同步触发</span><br><span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Event</span>(<span class="hljs-string">&#x27;customEvent&#x27;</span>);<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">dispatchEvent</span>(event);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;End of script&#x27;</span>);<br><br></code></pre></td></tr></table></figure>
<p>由浏览器环境触发的事件(比如点击、滚动、hashchange)通常是在宏任务任务队列中异步执行。</p>
<h1 id="2025-1-1"><a href="#2025-1-1" class="headerlink" title="2025.1.1"></a>2025.1.1</h1><h2 id="pushstate、popstate、replacestate"><a href="#pushstate、popstate、replacestate" class="headerlink" title="pushstate、popstate、replacestate"></a>pushstate、popstate、replacestate</h2><ol>
<li>pushstate：向浏览器历史记录栈添加新的条目，不会刷新页面加载资源，需要手动更新（前端js实现路由切换）</li>
<li>replacestate：替换当前的条目。</li>
<li>popstate：<strong>只有</strong>浏览器的前进和后退会触发popstate（replace改变记录不会触发）</li>
</ol>
<h2 id="a标签跳转"><a href="#a标签跳转" class="headerlink" title="a标签跳转"></a>a标签跳转</h2><ol>
<li>情况一： <code>&lt;a href=&quot;#/a&quot;&gt;a应用&lt;/a&gt;</code>hash跳转，触发hashchange</li>
<li>情况二：<code>&lt;a href=&quot;/a&quot;&gt;a应用&lt;/a&gt;</code> 页面会刷新，向服务器发送请求。</li>
</ol>
<h2 id="single-spa手写完毕"><a href="#single-spa手写完毕" class="headerlink" title="single-spa手写完毕"></a>single-spa手写完毕</h2><h1 id="2025-1-2"><a href="#2025-1-2" class="headerlink" title="2025.1.2"></a>2025.1.2</h1><h2 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h2><h2 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h2><h2 id="调整数组顺序"><a href="#调整数组顺序" class="headerlink" title="调整数组顺序"></a>调整数组顺序</h2><h2 id="链表中倒数第K个节点"><a href="#链表中倒数第K个节点" class="headerlink" title="链表中倒数第K个节点"></a>链表中倒数第K个节点</h2><h1 id="2025-1-3"><a href="#2025-1-3" class="headerlink" title="2025.1.3"></a>2025.1.3</h1><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h2 id="合并两个排序链表"><a href="#合并两个排序链表" class="headerlink" title="合并两个排序链表"></a>合并两个排序链表</h2><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><h2 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h2><h2 id="翻转二叉树-1"><a href="#翻转二叉树-1" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><h2 id="qiankun基本使用"><a href="#qiankun基本使用" class="headerlink" title="qiankun基本使用"></a>qiankun基本使用</h2><h1 id="2025-1-4"><a href="#2025-1-4" class="headerlink" title="2025.1.4"></a>2025.1.4</h1><h2 id="对称二叉树-1"><a href="#对称二叉树-1" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><h2 id="栈的压入压出"><a href="#栈的压入压出" class="headerlink" title="栈的压入压出"></a>栈的压入压出</h2><h1 id="2025-1-5"><a href="#2025-1-5" class="headerlink" title="2025.1.5"></a>2025.1.5</h1><h2 id="最小栈（重复添加"><a href="#最小栈（重复添加" class="headerlink" title="最小栈（重复添加"></a>最小栈（重复添加</h2><h2 id="层序遍历-1-2-3"><a href="#层序遍历-1-2-3" class="headerlink" title="层序遍历 1.2.3"></a>层序遍历 1.2.3</h2><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><ul>
<li>左边<strong>都</strong>根小，右边<strong>都</strong>比根大</li>
</ul>
<h2 id="二叉搜索树的后序遍历顺序"><a href="#二叉搜索树的后序遍历顺序" class="headerlink" title="二叉搜索树的后序遍历顺序"></a>二叉搜索树的后序遍历顺序</h2><h2 id="路径总和-1-2"><a href="#路径总和-1-2" class="headerlink" title="路径总和 1.2"></a>路径总和 1.2</h2><ul>
<li>与常规递归思路区别：不要遍历到空节点再判断</li>
</ul>
<h2 id="qiankun的使用注意事项"><a href="#qiankun的使用注意事项" class="headerlink" title="qiankun的使用注意事项"></a>qiankun的使用注意事项</h2><h3 id="public-path"><a href="#public-path" class="headerlink" title="public-path"></a>public-path</h3><ul>
<li>解决子应用资源路径无法加载的问题</li>
</ul>
<h3 id="qiankun打包格式为umd"><a href="#qiankun打包格式为umd" class="headerlink" title="qiankun打包格式为umd"></a>qiankun打包格式为umd</h3><h3 id="容器挂载"><a href="#容器挂载" class="headerlink" title="容器挂载"></a>容器挂载</h3><ul>
<li>container里面的root，而不是根root</li>
</ul>
<h3 id="qiankun全局标识"><a href="#qiankun全局标识" class="headerlink" title="qiankun全局标识"></a>qiankun全局标识</h3><ul>
<li>qiankun提供了标识，用于当前应用是否在父应用中被引用<br><code>if(!window.__POWERED_BY_QIANKUN__)</code></li>
</ul>
<h1 id="2025-1-6"><a href="#2025-1-6" class="headerlink" title="2025.1.6"></a>2025.1.6</h1><h2 id="链表的复制"><a href="#链表的复制" class="headerlink" title="链表的复制"></a>链表的复制</h2><h2 id="二叉搜索树第k大的节点"><a href="#二叉搜索树第k大的节点" class="headerlink" title="二叉搜索树第k大的节点"></a>二叉搜索树第k大的节点</h2><h2 id="字符串全排列"><a href="#字符串全排列" class="headerlink" title="字符串全排列"></a>字符串全排列</h2><h2 id="数组中出现次数超过一半的值"><a href="#数组中出现次数超过一半的值" class="headerlink" title="数组中出现次数超过一半的值"></a>数组中出现次数超过一半的值</h2><h2 id="二叉搜索树-9997"><a href="#二叉搜索树-9997" class="headerlink" title="二叉搜索树 &#9997;"></a>二叉搜索树 &#9997;</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li>左边都比根小，右边都比根大</li>
<li>子树也是二叉搜索树</li>
</ul>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ol>
<li>比当前节点小去左子树，比当前节点大去右子树</li>
<li>最大值一直往右，最小值一直往左</li>
</ol>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul>
<li>一定会插入到叶子节点</li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ol>
<li>情况一：叶子（没有子节点）节点，直接删除即可。</li>
<li>情况二：一个子节点，直接替换即可。</li>
<li>情况三：两个子节点，找左边最大值，或者右边最小值，保持二叉搜索树规律（左小，右大）。</li>
</ol>
<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p><code>div[data-qiankun=&quot;reactApp&quot;]</code>,div元素data-qiankun属性为reactApp时候样式才生效。</p>
<h1 id="2025-1-7"><a href="#2025-1-7" class="headerlink" title="2025.1.7"></a>2025.1.7</h1><h2 id="二叉树转换为双向链表"><a href="#二叉树转换为双向链表" class="headerlink" title="二叉树转换为双向链表"></a>二叉树转换为双向链表</h2><h2 id="连续子数组最大值"><a href="#连续子数组最大值" class="headerlink" title="连续子数组最大值"></a>连续子数组最大值</h2><h2 id="堆基础知识"><a href="#堆基础知识" class="headerlink" title="堆基础知识"></a>堆基础知识</h2><h1 id="2025-1-8"><a href="#2025-1-8" class="headerlink" title="2025.1.8"></a>2025.1.8</h1><h2 id="qiankun源码"><a href="#qiankun源码" class="headerlink" title="qiankun源码"></a>qiankun源码</h2><h1 id="2025-1-9"><a href="#2025-1-9" class="headerlink" title="2025.1.9"></a>2025.1.9</h1><h2 id="01背包问题基础"><a href="#01背包问题基础" class="headerlink" title="01背包问题基础"></a>01背包问题基础</h2><ol>
<li>二维：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + weight[i]);<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>一维：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dp[j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[j],dp[j - weight[i]] + weight[i]);<br></code></pre></td></tr></table></figure>
<h2 id="数组翻译成字符串"><a href="#数组翻译成字符串" class="headerlink" title="数组翻译成字符串"></a>数组翻译成字符串</h2><h2 id="礼物得最大价值"><a href="#礼物得最大价值" class="headerlink" title="礼物得最大价值"></a>礼物得最大价值</h2><h2 id="丑数1"><a href="#丑数1" class="headerlink" title="丑数1"></a>丑数1</h2><h1 id="2025-1-10"><a href="#2025-1-10" class="headerlink" title="2025.1.10"></a>2025.1.10</h1><h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><h2 id="第一次只出现一次的数字"><a href="#第一次只出现一次的数字" class="headerlink" title="第一次只出现一次的数字"></a>第一次只出现一次的数字</h2><ul>
<li>lastIndexOf、 indexOf</li>
</ul>
<h2 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="两个链表的公共节点"><a href="#两个链表的公共节点" class="headerlink" title="两个链表的公共节点"></a>两个链表的公共节点</h2><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h2 id="single-spa进行了总结"><a href="#single-spa进行了总结" class="headerlink" title="single-spa进行了总结"></a>single-spa进行了总结</h2><h2 id="qiankun使用"><a href="#qiankun使用" class="headerlink" title="qiankun使用"></a>qiankun使用</h2><ol>
<li>主应用注册子应用</li>
<li>子应用暴露接口协议</li>
<li>public-path.js：改变静态资源路径为子应用ip地址，默认会是父应用ip地址导致静态资源无法加载。</li>
<li>挂载位置：子应用挂载到app，根应用也是app的div，这时候需要限制查找范围。props参数有个container属性是dom元素。主应用的html下面有一个container div，container div上挂载子应用的html，子应用html有app。</li>
<li>webpack打包格式为umd格式</li>
<li>除了微前端启动，还有正常启动，qiankun会在window放个全局属性powerbyqiankun没有的话直接调render函数就好。</li>
</ol>
<h2 id="js沙箱"><a href="#js沙箱" class="headerlink" title="js沙箱"></a>js沙箱</h2><ol>
<li>快照沙箱</li>
<li>单实例</li>
<li>多实例沙箱</li>
</ol>
<h2 id="css样式隔离-1"><a href="#css样式隔离-1" class="headerlink" title="css样式隔离"></a>css样式隔离</h2><h1 id="1-11"><a href="#1-11" class="headerlink" title="1.11"></a>1.11</h1><h2 id="异或两道题"><a href="#异或两道题" class="headerlink" title="异或两道题"></a>异或两道题</h2><h2 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h2><h2 id="和为s的连续数字"><a href="#和为s的连续数字" class="headerlink" title="和为s的连续数字"></a>和为s的连续数字</h2><h2 id="双指针总结"><a href="#双指针总结" class="headerlink" title="双指针总结"></a>双指针总结</h2><ul>
<li>双指针有两种类型，一种是left &#x3D; 0;right &#x3D; arr.length; while(left &lt; right)</li>
<li>另一种是： left &#x3D; 0, right &#x3D; 1; while(right &lt; arr.length)</li>
</ul>
<h2 id="字符串trim方法"><a href="#字符串trim方法" class="headerlink" title="字符串trim方法"></a>字符串trim方法</h2><ul>
<li>去除前后的空格</li>
</ul>
<h2 id="qiankun源码-1"><a href="#qiankun源码-1" class="headerlink" title="qiankun源码"></a>qiankun源码</h2><h2 id="import-html-entry"><a href="#import-html-entry" class="headerlink" title="import-html-entry"></a>import-html-entry</h2><h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="category-chain-item">学习记录</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>秋招学习记录</div>
      <div>http://example.com/2025/04/05/学习记录/1.秋招学习记录/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Wayne Chen</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年4月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/04/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2.%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="大四寒假学习记录">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">大四寒假学习记录</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/04/05/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%85%AB%E8%82%A1%E6%B1%87%E6%80%BB/" title="八股汇总">
                        <span class="hidden-mobile">八股汇总</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"ohWadpEWlT0Q54ERBAkcKH6S-MdYXbMMI","appKey":"vCuFIlABwAvv2H6Ambf1u5e4","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/custom.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
